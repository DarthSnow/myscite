--- LuaExtension.cxx	2017-04-06 17:32:54.477599700 +0200
+++ mod_LuaExtension.cxx	2017-04-06 17:37:00.597278200 +0200
@@ -24,12 +24,19 @@
 #include "IFaceTable.h"
 #include "SciTEKeys.h"
 
+#define LUA_COMPAT_5_1
 extern "C" {
 #include "lua.h"
 #include "lualib.h"
 #include "lauxlib.h"
 }
 
+#if (LUA_VERSION_NUM < 502)
+#define lua_pushglobaltable(L) lua_pushvalue(L, LUA_GLOBALSINDEX)
+#else
+#define LUA_GLOBALSINDEX LUA_RIDX_GLOBALS
+#endif
+
 #if defined(_WIN32) && defined(_MSC_VER)
 
 // MSVC looks deeper into the code than other compilers, sees that
@@ -119,11 +126,21 @@
 	lua_error(L);
 }
 
+// lua_absindex for LUA <5.1
 inline int absolute_index(lua_State *L, int index) {
-	return ((index < 0) && (index != LUA_REGISTRYINDEX) && (index != LUA_GLOBALSINDEX))
-	       ? (lua_gettop(L) + index + 1) : index;
+	if (index > LUA_REGISTRYINDEX && index < 0)
+		return lua_gettop(L) + index + 1;
+	else
+		return index;
 }
 
+/**
+* merge_table / clone_table / clear_table utilized to
+* "soft-replace" an existing global scope instead of using using new_table,
+* because then startup script would be bound to a different copy
+* of the globals than the extension script.
+**/
+
 // copy the contents of one table into another returning the size
 static int merge_table(lua_State *L, int destTableIdx, int srcTableIdx, bool copyMetatable = false) {
 	int count = 0;
@@ -1239,36 +1256,41 @@
 }
 
 static void PublishGlobalBufferData() {
+// release 1.62
+// A Lua table called 'buffer' is associated with each buffer
+// and can be used to maintain buffer-specific state.
 	lua_pushliteral(luaState, "buffer");
 	if (curBufferIndex >= 0) {
 		lua_pushliteral(luaState, "SciTE_BufferData_Array");
 		lua_rawget(luaState, LUA_REGISTRYINDEX);
+		// Create new SciTE_BufferData_Array / append to LUA_REGISTRYINDEX
 		if (!lua_istable(luaState, -1)) {
 			lua_pop(luaState, 1);
-
 			lua_newtable(luaState);
 			lua_pushliteral(luaState, "SciTE_BufferData_Array");
 			lua_pushvalue(luaState, -2);
 			lua_rawset(luaState, LUA_REGISTRYINDEX);
 		}
+		//  create new entry for current buffer in SciTE_BufferData_Array(idx)
 		lua_rawgeti(luaState, -1, curBufferIndex);
 		if (!lua_istable(luaState, -1)) {
-			// create new buffer-data
 			lua_pop(luaState, 1);
 			lua_newtable(luaState);
 			// remember it
 			lua_pushvalue(luaState, -1);
 			lua_rawseti(luaState, -3, curBufferIndex);
 		}
-		// Replace SciTE_BufferData_Array in the stack, leaving (buffer=-1, 'buffer'=-2)
+		// replace SciTE_BufferData_Array on the Stack (Leaving (buffer=-1, 'buffer'=-2))
+		// done to apply the expanded  SciTE_BufferData_Array ?
 		lua_replace(luaState, -2);
 	} else {
-		// for example, during startup, before any InitBuffer / ActivateBuffer
+		/// ensure that the luatable "buffer" will be empty during startup and before any InitBuffer / ActivateBuffer
 		lua_pushnil(luaState);
 	}
-	lua_rawset(luaState, LUA_GLOBALSINDEX);
+	lua_setglobal(luaState, "buffer");
 }
 
+
 static bool InitGlobalScope(bool checkProperties, bool forceReload = false) {
 	bool reload = forceReload;
 	if (checkProperties) {
@@ -1287,11 +1309,11 @@
 		// copy of the initialized global environment, and uses that to re-init the scope.
 
 		if (!reload) {
+			lua_pushglobaltable(luaState);
 			lua_getfield(luaState, LUA_REGISTRYINDEX, "SciTE_InitialState");
 			if (lua_istable(luaState, -1)) {
-				clear_table(luaState, LUA_GLOBALSINDEX, true);
-				merge_table(luaState, LUA_GLOBALSINDEX, -1, true);
-				lua_pop(luaState, 1);
+				clear_table(luaState, -2, true);
+				merge_table(luaState, -2, -1, true);
 
 				// restore initial package.loaded state
 				lua_getfield(luaState, LUA_REGISTRYINDEX, "SciTE_InitialPackageState");
@@ -1321,7 +1343,9 @@
 
 		// Don't replace global scope using new_table, because then startup script is
 		// bound to a different copy of the globals than the extension script.
-		clear_table(luaState, LUA_GLOBALSINDEX, true);
+
+		lua_pushglobaltable(luaState);
+		clear_table(luaState, -1, true);
 
 		// Lua 5.1: _LOADED is in LUA_REGISTRYINDEX, so it must be cleared before
 		// loading libraries or they will not load because Lua's package system
@@ -1330,7 +1354,7 @@
 		lua_setfield(luaState, LUA_REGISTRYINDEX, "_LOADED");
 
 	} else if (!luaDisabled) {
-		luaState = lua_open();
+		luaState = luaL_newstate();
 		if (!luaState) {
 			luaDisabled = true;
 			host->Trace("> Lua: scripting engine failed to initialise\n");
@@ -1417,7 +1441,10 @@
 		lua_pushcfunction(luaState, cf_global_metatable_index);
 		lua_setfield(luaState, -2, "__index");
 	}
-	lua_setmetatable(luaState, LUA_GLOBALSINDEX);
+	//Set above created table as new metatable for globalsindex
+	lua_pushglobaltable(luaState);
+	lua_setmetatable(luaState, -1);
+	lua_pop(luaState,1);
 
 	if (checkProperties && reload) {
 		CheckStartupScript();
@@ -1443,11 +1470,14 @@
 		}
 	}
 
-	// Clone the initial state (including metatable) in the registry so that it can be restored.
+	// Clone the initial (globalsindex) state (including metatable) in the registry so that it can be restored.
 	// (If reset==1 this will not be used, but this is a shallow copy, not very expensive, and
 	// who knows what the value of reset will be the next time InitGlobalScope runs.)
-	clone_table(luaState, LUA_GLOBALSINDEX, true);
-	lua_setfield(luaState, LUA_REGISTRYINDEX, "SciTE_InitialState");
+
+	lua_pushglobaltable(luaState);
+	clone_table(luaState, -1, true);
+	lua_setfield(luaState, LUA_REGISTRYINDEX, "SciTE_InitialState");;
+	lua_pop(luaState, 1); //FIX_HERE
 
 	// Clone loaded packages (package.loaded) state in the registry so that it can be restored.
 	lua_getfield(luaState, LUA_REGISTRYINDEX, "_LOADED");
@@ -1520,9 +1550,11 @@
 
 
 bool LuaExtension::InitBuffer(int index) {
-	//char msg[100];
-	//sprintf(msg, "InitBuffer(%d)\n", index);
-	//host->Trace(msg);
+	/*
+	char msg[100];
+	sprintf(msg, "InitBuffer(%d)\n", index);
+	host->Trace(msg);
+	*/
 
 	if (index > maxBufferIndex)
 		maxBufferIndex = index;
@@ -1548,9 +1580,11 @@
 }
 
 bool LuaExtension::ActivateBuffer(int index) {
-	//char msg[100];
-	//sprintf(msg, "ActivateBuffer(%d)\n", index);
-	//host->Trace(msg);
+	/*
+	char msg[100];
+	sprintf(msg, "ActivateBuffer(%d)\n", index);
+	host->Trace(msg);
+	*/
 
 	// Probably don't need to do anything with Lua here.  Setting
 	// curBufferIndex is important so that InitGlobalScope knows
@@ -1599,15 +1633,22 @@
 }
 
 bool LuaExtension::OnExecute(const char *s) {
+// gets called when selecting a luaScript within the tools menu
+// pcalls string.find(s) -> if that succeeds, insert the function onto the stack and try to call_function(s).
 	bool handled = false;
+	/*	std::string msg = "lua: selected Tools->";
+		msg.append(s);
+		msg.append("\n");
+		host->Trace(msg.c_str());
+	*/
 
 	if (luaState || InitGlobalScope(false)) {
 		// May as well use Lua's pattern matcher to parse the command.
 		// Scintilla's RESearch was the other option.
 		int stackBase = lua_gettop(luaState);
-
+		lua_pushglobaltable(luaState);
 		lua_pushliteral(luaState, "string");
-		lua_rawget(luaState, LUA_GLOBALSINDEX);
+		lua_rawget(luaState, -2);
 		if (lua_istable(luaState, -1)) {
 			lua_pushliteral(luaState, "find");
 			lua_rawget(luaState, -2);
@@ -1616,7 +1657,7 @@
 				lua_pushliteral(luaState, "^%s*([%a_][%a%d_]*)%s*(.-)%s*$");
 				int status = lua_pcall(luaState, 2, 4, 0);
 				if (status==0) {
-					lua_insert(luaState, stackBase+1);
+					lua_insert(luaState, stackBase+1);	//function
 					lua_gettable(luaState, LUA_GLOBALSINDEX);
 					if (!lua_isnil(luaState, -1)) {
 						if (lua_isfunction(luaState, -1)) {
@@ -1636,7 +1677,6 @@
 		} else {
 			host->Trace("> Lua: string library not loaded\n");
 		}
-
 		lua_settop(luaState, stackBase);
 	}
 
