##
# C/CPP API, as fetched from CPlusPlus.com / Februar2017, Marcedo@HabmalneFrage.de | https://sourceforge.net/projects/scite-webdev
##
atol( const char * str )Param: (C-string containing the representation of an integral number.)\t\nDesc: Convert string to long integer (function)\t\nProto: long int atol ( const char * str );\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
atoll( const char * str )Param: (C-string containing the representation of an integral number.)\t\nDesc: Convert string to long long integer (function)\t\nProto: long long int atoll ( const char * str );\t\n[c99 cpp11] [<cstdlib> (stdlib.h)]
atoi(const char * str)Param: (C-string beginning with the representation of an integral number.)\t\nDesc: Convert string to integer (function)\t\nProto: int atoi (const char * str);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
atof(const char* str)Param: (C-string beginning with the representation of a floating-point number.)\t\nDesc: Convert string to double (function)\t\nProto: double atof (const char* str);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
asctime(const struct tm * timeptr)Param: (Pointer to a tm structure that contains a calendar time broken down into its components (see struct tm).)\t\nDesc: Convert tm structure to string (function)\t\nProto: char* asctime (const struct tm * timeptr);\t\n[c90 c99 arm cpp98 cpp11] [<ctime> (time.h)]
acos(double x)Param: (Value whose arc cosine is computed, in the interval [-1,+1].)\t\nDesc: Compute arc cosine (function)\t\nProto: double acos (double x);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
asin(double x)Param: (Value whose arc sine is computed, in the interval [-1,+1].)\t\nDesc: Compute arc sine (function)\t\nProto: double asin(double x);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
atan(double x)Param: (Value whose arc tangent is computed.)\t\nDesc: Compute arc tangent (function)\t\nProto: double atan(double x);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
abs(double x)Param: (Value whose absolute value is returned.)\t\nDesc: Compute absolute value (function)\t\nProto: double abs (double x); float abs (float x);long double abs (long double x);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
acosh(double x)Param: (Value whose arc hyperbolic cosine is computed.)\t\nDesc: Compute arc hyperbolic cosine (function)\t\nProto: double acosh (double x); float acoshf (float x);long double acoshl (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
asinh(double x)Param: (Value whose arc hyperbolic sine is computed.)\t\nDesc: Compute arc hyperbolic sine (function)\t\nProto: double asinh (double x); float asinhf (float x);long double asinhl (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
atanh(double x)Param: (Value whose arc hyperbolic tangent is computed, in the interval [-1,+1].)\t\nDesc: Compute arc hyperbolic tangent (function)\t\nProto: double atanh (double x); float atanhf (float x);long double atanhl (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
atan2(double y, double x)Param: (Value representing the proportion of the y-coordinate.)\t\nDesc: Compute arc tangent with two parameters (function)\t\nProto: double atan2(double y, double x);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
assert(int expression)Param: (Expression to be evaluated.)\t\nDesc: Evaluate assertion (macro)\t\nProto: void assert (int expression);\t\n[c90 c99 arm cpp98 cpp11] [<cassert> (assert.h)]
atexit(void (*func)(void))Param: (Function to be called.)\t\nDesc: Set function to be executed on exit (function)\t\nProto: int atexit (void (*func)(void));\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
at_quick_exit(void (*func)(void))Param: (Function to be called.)\t\nDesc: Set function to be executed on quick exit (function)\t\nProto: int at_quick_exit (void (*func)(void));\t\n[c11 cpp11] [<cstdlib> (stdlib.h)]
abort(void)Param: ()\t\nDesc: Abort current process (function)\t\nProto: void abort (void);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
bsearch(const void* key, const void* base,   size_t num, size_t size,   int (*compar)(const void*,const void*))Param: (Pointer to the object that serves as key for the search, type-casted to a )\t\nDesc: Binary search in array (function)\t\nProto: void* bsearch (const void* key, const void* base,   size_t num, size_t size,   int (*compar)(const void*,const void*));\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
clock_t()Param: ()\t\nDesc: Clock type (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<ctime> (time.h)]
c16rtomb( char * pmb, char16_t c16, mbstate_t * ps )Param: (Pointer to an array large enough to hold a multibyte sequence.)\t\nDesc: Convert 16-bit character to multibyte sequence (function)\t\nProto: size_t c16rtomb ( char * pmb, char16_t c16, mbstate_t * ps );\t\n[c11 cpp11] [<cuchar> (uchar.h)]
c32rtomb( char * pmb, char32_t c32, mbstate_t * ps )Param: (Pointer to an array large enough to hold a multibyte sequence.)\t\nDesc: Convert 32-bit character to multibyte sequence (function)\t\nProto: size_t c32rtomb ( char * pmb, char32_t c32, mbstate_t * ps );\t\n[c11 cpp11] [<cuchar> (uchar.h)]
clearerr( FILE * stream )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Clear error indicators (function)\t\nProto: void clearerr ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
ceil(double x)Param: (Value to round up.)\t\nDesc: Round up value (function)\t\nProto: double ceil (double x);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
cbrt(double x)Param: (Value whose cubit root is computed.)\t\nDesc: Compute cubic root (function)\t\nProto: double cbrt (double x); float cbrtf (float x);long double cbrtl (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
copysign(double x)Param: (Value with the magnitude of the resulting value.)\t\nDesc: Copy sign (function)\t\nProto: double copysign (double x, double y); float copysignf (float x , float y);long double copysignl (long double x, long double y);\t\n[c99 cpp11] [<cmath> (math.h)]
calloc(size_t num, size_t size)Param: (Number of elements to allocate.)\t\nDesc: Allocate and zero-initialize array (function)\t\nProto: void* calloc (size_t num, size_t size);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
clock(void)Param: ()\t\nDesc: Clock program (function)\t\nProto: clock_t clock (void);\t\n[c90 c99 arm cpp98 cpp11] [<ctime> (time.h)]
double_t()Param: ()\t\nDesc: Floating-point type (type)\t\nProto: no-proto\t\n[c99 cpp11] [<cmath> (math.h)]
div_t(quot)Param: (Represents the quotient of the integral division operation performed by div, which is the integer of lesser magnitude that is nearest to the algebraic quotient.)\t\nDesc: Structure returned by div (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
div(int numer, int denom)Param: (Numerator.)\t\nDesc: Integral division (function)\t\nProto: div_t div (int numer, int denom);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
difftime(time_t end, time_t beginning)Param: (Higher bound of the time interval whose length is calculated.)\t\nDesc: Return difference between two times (function)\t\nProto: double difftime (time_t end, time_t beginning);\t\n[c90 c99 arm cpp98 cpp11] [<ctime> (time.h)]
errno()Param: ()\t\nDesc: Last error number (macro)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cerrno> (errno.h)]
exp(double x)Param: (Value of the exponent.)\t\nDesc: Compute exponential function (function)\t\nProto: double exp (double x);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
erfc(double x)Param: (Parameter for the complementary error function.)\t\nDesc: Compute complementary error function (function)\t\nProto: double erfc (double x); float erfcf (float x);long double erfcl (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
erf(double x)Param: (Parameter for the error function.)\t\nDesc: Compute error function (function)\t\nProto: double erf (double x); float erff (float x);long double erfl (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
exp2(double x)Param: (Value of the exponent.)\t\nDesc: Compute binary exponential function (function)\t\nProto: double exp2 (double x); float exp2f (float x);long double exp2l (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
expm1(double x)Param: (Value of the exponent.)\t\nDesc: Compute exponential minus one (function)\t\nProto: double expm1 (double x); float expm1f (float x);long double expm1l (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
fenv_t()Param: ()\t\nDesc: Floating-point environment type (type)\t\nProto: no-proto\t\n[c99 cpp11] [<cfenv> (fenv.h)]
fexcept_t()Param: ()\t\nDesc: Floating-point exceptions type (type)\t\nProto: no-proto\t\n[c99 cpp11] [<cfenv> (fenv.h)]
fpclassify(x)Param: ()\t\nDesc: Classify floating-point value (macro/function)\t\nProto: fpclassify(x)\t\n[c99 cpp11] [<cmath> (math.h)]
float_t()Param: ()\t\nDesc: Floating-point type (type)\t\nProto: no-proto\t\n[cpp99 cpp11] [<cmath> (math.h)]
fpos_t()Param: ()\t\nDesc: Object containing information to specify a position within a file (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fgets( char * str, int num, FILE * stream )Param: (Pointer to an array of chars where the string read is copied.)\t\nDesc: Get string from stream (function)\t\nProto: char * fgets ( char * str, int num, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fopen( const char * filename, const char * mode )Param: (C string containing the name of the file to be opened.)\t\nDesc: Open file (function)\t\nProto: FILE * fopen ( const char * filename, const char * mode );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
freopen( const char * filename, const char * mode, FILE * stream )Param: (C string containing the name of the file to be opened.)\t\nDesc: Reopen stream with different file or mode (function)\t\nProto: FILE * freopen ( const char * filename, const char * mode, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fputs( const char * str, FILE * stream )Param: (C string with the content to be written to stream.)\t\nDesc: Write string to stream (function)\t\nProto: int fputs ( const char * str, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fwrite( const void * ptr, size_t size, size_t count, FILE * stream )Param: (Pointer to the array of elements to be written, converted to a const )\t\nDesc: Write block of data to stream (function)\t\nProto: size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fclose( FILE * stream )Param: (Pointer to a FILE object that specifies the stream to be closed.)\t\nDesc: Close file (function)\t\nProto: int fclose ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
feof( FILE * stream )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Check end-of-file indicator (function)\t\nProto: int feof ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
ferror( FILE * stream )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Check error indicator (function)\t\nProto: int ferror ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fflush( FILE * stream )Param: (Pointer to a FILE object that specifies a buffered stream.)\t\nDesc: Flush stream (function)\t\nProto: int fflush ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fgetc( FILE * stream )Param: (Pointer to a FILE object that identifies an input stream.)\t\nDesc: Get character from stream (function)\t\nProto: int fgetc ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
ftell( FILE * stream )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Get current position in stream (function)\t\nProto: long int ftell ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fprintf( FILE * stream, const char * format, ... )Param: (Pointer to a FILE object that identifies an output stream.)\t\nDesc: Write formatted data to stream (function)\t\nProto: int fprintf ( FILE * stream, const char * format, ... );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fscanf( FILE * stream, const char * format, ... )Param: (Pointer to a FILE object that identifies the input stream to read data from.)\t\nDesc: Read formatted data from stream (function)\t\nProto: int fscanf ( FILE * stream, const char * format, ... );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fsetpos( FILE * stream, const fpos_t * pos )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Set position indicator of stream (function)\t\nProto: int fsetpos ( FILE * stream, const fpos_t * pos );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fgetpos( FILE * stream, fpos_t * pos )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Get current position in stream (function)\t\nProto: int fgetpos ( FILE * stream, fpos_t * pos );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fseek( FILE * stream, long int offset, int origin )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Reposition stream position indicator (function)\t\nProto: int fseek ( FILE * stream, long int offset, int origin );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fputc( int character, FILE * stream )Param: (The int promotion of the character to be written.)\t\nDesc: Write character to stream (function)\t\nProto: int fputc ( int character, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fread( void * ptr, size_t size, size_t count, FILE * stream )Param: (Pointer to a block of memory with a size of at least (size*count) bytes, converted to a )\t\nDesc: Read block of data from stream (function)\t\nProto: size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
fesetenv(const fenv_t* envp)Param: (Either a pointer to a fenv_t value (filled by a previous call to fegetenv or feholdexcept), or one of the floating-point environment macro.)\t\nDesc: Set floating-point environment (function)\t\nProto: int fesetenv (const fenv_t* envp);\t\n[c99 cpp11] [<cfenv> (fenv.h)]
feupdateenv(const fenv_t* envp)Param: (Either a pointer to a fenv_t value (filled by a previous call to fegetenv or feholdexcept), or one of the floating-point environment macro values.)\t\nDesc: Update floating-point environment (function)\t\nProto: int feupdateenv (const fenv_t* envp);\t\n[c99 cpp11] [<cfenv> (fenv.h)]
fesetexceptflag(const fexcept_t* flagp, int excepts)Param: (Pointer to a fexcept_t object with a representation of floating-point exceptions.)\t\nDesc: Set floating-point exception flags (function)\t\nProto: int fesetexceptflag (const fexcept_t* flagp, int excepts);\t\n[c99 cpp11] [<cfenv> (fenv.h)]
fputws(const wchar_t* ws, FILE* stream)Param: (C wide string with the content to write to the stream.)\t\nDesc: Write wide string to stream (function)\t\nProto: int fputws (const wchar_t* ws, FILE* stream);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
fmod(double numer, double denom)Param: (Value of the quotient numerator.)\t\nDesc: Compute remainder of division (function)\t\nProto: double fmod (double numer, double denom);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
fabs(double x)Param: (Value whose absolute value is returned.)\t\nDesc: Compute absolute value (function)\t\nProto: double fabs (double x);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
floor(double x)Param: (Value to round down.)\t\nDesc: Round down value (function)\t\nProto: double floor (double x);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
fdim(double x)Param: (Values whose difference is calculated.)\t\nDesc: Positive difference (function)\t\nProto: double fdim (double x, double y); float fdimf (float x , float y);long double fdiml (long double x, long double y);\t\n[c99 cpp11] [<cmath> (math.h)]
fmax(double x)Param: (Values among which the function selects a maximum.)\t\nDesc: Maximum value (function)\t\nProto: double fmax (double x, double y); float fmaxf (float x , float y);long double fmaxl (long double x, long double y);\t\n[c99 cpp11] [<cmath> (math.h)]
fmin(double x)Param: (Values among which the function selects a minimum.)\t\nDesc: Minimum value (function)\t\nProto: double fmin (double x, double y); float fminf (float x , float y);long double fminl (long double x, long double y);\t\n[c99 cpp11] [<cmath> (math.h)]
fma(double x)Param: (Values to be multiplied.)\t\nDesc: Multiply-add (function)\t\nProto: double fma (double x, double y, double z); float fmaf (float x , float y , float z);long double fmal (long double x, long double y, long double z);\t\n[c99 cpp11] [<cmath> (math.h)]
frexp(double x)Param: (Value to be decomposed.)\t\nDesc: Get significand and exponent (function)\t\nProto: double frexp (double x, int* exp);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
fegetenv(fenv_t* envp)Param: (Pointer to a fenv_t object where the state of the floating-point environment is stored.)\t\nDesc: Get floating-point environment (function)\t\nProto: int fegetenv (fenv_t* envp);\t\n[c99 cpp11] [<cfenv> (fenv.h)]
feholdexcept(fenv_t* envp)Param: (Pointer to a fenv_t object where the state of the floating-point environment is stored.)\t\nDesc: Hold floating-point exceptions (function)\t\nProto: int feholdexcept (fenv_t* envp);\t\n[c99 cpp11] [<cfenv> (fenv.h)]
fegetexceptflag(fexcept_t* flagp, int excepts)Param: (Pointer to a fexcept_t object where the representation is stored.)\t\nDesc: Get floating-point exception flags (function)\t\nProto: int fegetexceptflag (fexcept_t* flagp, int excepts);\t\n[c99 cpp11] [<cfenv> (fenv.h)]
fgetwc(FILE * stream)Param: (Pointer to a FILE object that identifies an input stream.)\t\nDesc: Get wide character from stream (function)\t\nProto: wint_t fgetwc (FILE * stream);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
fwprintf(FILE* stream, const wchar_t* format, ...)Param: (Pointer to a FILE object that identifies an output stream.)\t\nDesc: Write formatted data to stream (function)\t\nProto: int fwprintf (FILE* stream, const wchar_t* format, ...);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
fwscanf(FILE* stream, const wchar_t* format, ...)Param: (Pointer to a FILE object that identifies the input stream to read data from.)\t\nDesc: Read formatted data from stream (function)\t\nProto: int fwscanf (FILE* stream, const wchar_t* format, ...);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
fwide(FILE* stream, int mode)Param: (Pointer to a FILE object that identifies a stream.)\t\nDesc: Stream orientation (function)\t\nProto: int fwide (FILE* stream, int mode);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
feclearexcept(int excepts)Param: (Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation.)\t\nDesc: Clear floating-point exceptions (function)\t\nProto: int feclearexcept (int excepts);\t\n[c99 cpp11] [<cfenv> (fenv.h)]
feraiseexcept(int excepts)Param: (Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation.)\t\nDesc: Raise floating-point exception (function)\t\nProto: int feraiseexcept (int excepts);\t\n[c99 cpp11] [<cfenv> (fenv.h)]
fetestexcept(int excepts)Param: (Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation.)\t\nDesc: Test for floating-point exceptions (function)\t\nProto: int fetestexcept (int excepts);\t\n[c99 cpp11] [<cfenv> (fenv.h)]
fesetround(int rdir)Param: (One of the values defined as rounding direction mode.)\t\nDesc: Set rounding direction mode (function)\t\nProto: int fesetround (int rdir);\t\n[c99 cpp11] [<cfenv> (fenv.h)]
fegetround(void)Param: ()\t\nDesc: Get rounding direction mode (function)\t\nProto: int fegetround (void);\t\n[c99 cpp11] [<cfenv> (fenv.h)]
free(void* ptr)Param: (Pointer to a memory block previously allocated with malloc, calloc or realloc.)\t\nDesc: Deallocate memory block (function)\t\nProto: void free (void* ptr);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
fputwc(wchar_t wc, FILE * stream)Param: (The wide character to write.)\t\nDesc: Write wide character to stream (function)\t\nProto: wint_t fputwc (wchar_t wc, FILE * stream);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
fgetws(wchar_t* ws, int num, FILE* stream)Param: (Pointer to an array of wchar_t where the wide string read is copied.)\t\nDesc: Get wide string from stream (function)\t\nProto: wchar_t* fgetws (wchar_t* ws, int num, FILE* stream);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
getchar( void )Param: ()\t\nDesc: Get character from stdin (function)\t\nProto: int getchar ( void );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
gmtime(const time_t * timer)Param: (Pointer to an object of type time_t that contains a time value.)\t\nDesc: Convert time_t to tm as UTC time (function)\t\nProto: struct tm * gmtime (const time_t * timer);\t\n[c90 c99 arm cpp98 cpp11] [<ctime> (time.h)]
getwchar(void)Param: ()\t\nDesc: Get wide character from stdin (function)\t\nProto: wint_t getwchar (void);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
hypot(double x)Param: (Floating point values corresponding to the legs of a right-angled triangle for which the hypotenuse is computed.)\t\nDesc: Compute hypotenuse (function)\t\nProto: double hypot (double x, double y); float hypotf (float x , float y);long double hypotl (long double x, long double y);\t\n[c99 cpp11] [<cmath> (math.h)]
isfinite(x)Param: (A floating-point value.)\t\nDesc: Is finite value (macro)\t\nProto: isfinite(x)\t\n[c99 cpp11] [<cmath> (math.h)]
isgreater(x, y)Param: (Values to be compared.)\t\nDesc: Is greater (macro)\t\nProto: isgreater(x,y)\t\n[c99 cpp11] [<cmath> (math.h)]
isgreaterequal(x, y)Param: (Values to be compared.)\t\nDesc: Is greater or equal (macro)\t\nProto: isgreaterequal(x,y)\t\n[c99 cpp11] [<cmath> (math.h)]
isinf(x)Param: (A floating-point value.)\t\nDesc: Is infinity (macro/function)\t\nProto: isinf(x)\t\n[c99 cpp11] [<cmath> (math.h)]
isless(x, y)Param: (Values to be compared.)\t\nDesc: Is less (macro)\t\nProto: isless(x,y)\t\n[c99 cpp11] [<cmath> (math.h)]
islessequal(x, y)Param: (Values to be compared.)\t\nDesc: Is less or equal (macro)\t\nProto: islessequal(x,y)\t\n[c99 cpp11] [<cmath> (math.h)]
islessgreater(x, y)Param: (Values to be compared.)\t\nDesc: Is less or greater (macro)\t\nProto: islessgreater(x,y)\t\n[c99 cpp11] [<cmath> (math.h)]
isnan(x)Param: (A floating-point value.)\t\nDesc: Is Not-A-Number (macro/function)\t\nProto: isnan(x)\t\n[c99 cpp11] [<cmath> (math.h)]
isnormal(x)Param: (A floating-point value.)\t\nDesc: Is normal (macro/function)\t\nProto: isnormal(x)\t\n[c99 cpp11] [<cmath> (math.h)]
isunordered(x, y)Param: (Values to check whether they are unordered.)\t\nDesc: Is unordered (macro)\t\nProto: isunordered(x,y)\t\n[c99 cpp11] [<cmath> (math.h)]
isalnum( int c )Param: (Character to be checked, casted as an int, or EOF.)\t\nDesc: Check if character is alphanumeric (function)\t\nProto: int isalnum ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
isalpha( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is alphabetic (function)\t\nProto: int isalpha ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
isblank( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is blank (function)\t\nProto: int isblank ( int c );\t\n[c99 cpp11] [<cctype> (ctype.h)]
iscntrl( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is a control character (function)\t\nProto: int iscntrl ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
isdigit( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is decimal digit (function)\t\nProto: int isdigit ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
isgraph( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character has graphical representation (function)\t\nProto: int isgraph ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
islower( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is lowercase letter (function)\t\nProto: int islower ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
isprint( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is printable (function)\t\nProto: int isprint ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
ispunct( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is a punctuation character (function)\t\nProto: int ispunct ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
isspace( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is a white-space (function)\t\nProto: int isspace ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
isupper( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is uppercase letter (function)\t\nProto: int isupper ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
isxdigit( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is hexadecimal digit (function)\t\nProto: int isxdigit ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
itoa( int value, char * str, int base )Param: (Value to be converted to a string.)\t\nDesc: no-Description (other)\t\nProto: char * itoa ( int value, char * str, int base );\t\n[arm] [<cstdlib> (stdlib.h)]
ilogb(double x)Param: (Value whose ilogb is returned.)\t\nDesc: Integer binary logarithm (function)\t\nProto: int ilogb (double x);int ilogbf (float x);int ilogbl (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
iswalnum(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is alphanumeric (function)\t\nProto: int iswalnum (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
iswalpha(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is alphabetic (function)\t\nProto: int iswalpha (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
iswblank(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is blank (function)\t\nProto: int iswblank (wint_t c);\t\n[c99 cpp11] [<cwctype> (wctype.h)]
iswcntrl(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is a control character (function)\t\nProto: int iswcntrl (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
iswdigit(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is decimal digit (function)\t\nProto: int iswdigit (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
iswgraph(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character has graphical representation (function)\t\nProto: int iswgraph (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
iswlower(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is lowercase letter (function)\t\nProto: int iswlower (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
iswprint(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is printable (function)\t\nProto: int iswprint (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
iswpunct(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is punctuation character (function)\t\nProto: int iswpunct (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
iswspace(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is a white-space (function)\t\nProto: int iswspace (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
iswupper(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is uppercase letter (function)\t\nProto: int iswupper (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
iswxdigit(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is hexadecimal digit (function)\t\nProto: int iswxdigit (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
iswctype(wint_t c, wctype_t desc)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character has property (function)\t\nProto: int iswctype(wint_t c, wctype_t desc);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
jmp_buf()Param: ()\t\nDesc: Type to hold information to restore calling environment (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<csetjmp> (setjmp.h)]
ldiv_t(quot)Param: (Represents the quotient of the integral division operation performed by ldiv, which is the integer of lesser magnitude that is nearest to the algebraic quotient.)\t\nDesc: Structure returned by ldiv (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
lldiv_t(quot)Param: (Represents the quotient of the integral division operation performed by lldiv, which is the integer of lesser magnitude that is nearest to the algebraic quotient.)\t\nDesc: Structure returned by lldiv (type)\t\nProto: no-proto\t\n[c99 cpp11] [<cstdlib> (stdlib.h)]
localtime(const time_t * timer)Param: (Pointer to an object of type time_t that contains a time value.)\t\nDesc: Convert time_t to tm as local time (function)\t\nProto: struct tm * localtime (const time_t * timer);\t\n[c90 c99 arm cpp98 cpp11] [<ctime> (time.h)]
log10(double x)Param: (Value whose logarithm is calculated.)\t\nDesc: Compute common logarithm (function)\t\nProto: double log10 (double x);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
lgamma(double x)Param: (Parameter for the log-gamma function.)\t\nDesc: Compute log-gamma function (function)\t\nProto: double lgamma (double x); float lgammaf (float x);long double lgammal (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
log1p(double x)Param: (Value whose logarithm is calculated.)\t\nDesc: Compute logarithm plus one (function)\t\nProto: double log1p (double x); float log1pf (float x);long double log1pl (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
log2(double x)Param: (Value whose logarithm is calculated.)\t\nDesc: Compute binary logarithm (function)\t\nProto: double log2 (double x); float log2f (float x);long double log2l (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
llrint(double x)Param: (Value to round.)\t\nDesc: Round and cast to long long integer (function)\t\nProto: long long int llrint (double x);long long int llrintf (float x);long long int llrintl (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
llround(double x)Param: (Value to round.)\t\nDesc: Round to nearest and cast to long long integer (function)\t\nProto: long long int llround (double x);long long int llroundf (float x);long long int llroundl (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
ldexp(double x)Param: (Floating point value representing the significand.)\t\nDesc: Generate value from significand and exponent (function)\t\nProto: double ldexp (double x, int exp);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
longjmp(jmp_buf env, int val)Param: (Object of type jmp_buf filled by a previous call to setjmp that contains information to restore the environment to that point.)\t\nDesc: Long jump (function)\t\nProto: void longjmp (jmp_buf env, int val);\t\n[c90 c99 arm cpp98 cpp11] [<csetjmp> (setjmp.h)]
labs(long int n)Param: (Integral value.)\t\nDesc: Absolute value (function)\t\nProto: long int labs (long int n);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
ldiv(long int numer, long int denom)Param: (Numerator.)\t\nDesc: Integral division (function)\t\nProto: ldiv_t ldiv (long int numer, long int denom);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
llabs(long long int n)Param: (Integral value.)\t\nDesc: Absolute value (function)\t\nProto: long long int llabs (long long int n);\t\n[c99 cpp11] [<cstdlib> (stdlib.h)]
lldiv(long long int numer, long long int denom)Param: (Numerator.)\t\nDesc: Integral division (function)\t\nProto: lldiv_t lldiv (long long int numer, long long int denom);\t\n[c99 cpp11] [<cstdlib> (stdlib.h)]
localeconv(void)Param: ()\t\nDesc: Get locale formatting parameters for quantities (function)\t\nProto: struct lconv* localeconv (void);\t\n[c90 c99 arm cpp98 cpp11] [<clocale> (locale.h)]
math_errhandling()Param: ()\t\nDesc: Error handling (macro)\t\nProto: no-proto\t\n[c99 cpp11] [<cmath> (math.h)]
max_align_t()Param: ()\t\nDesc: Type with widest scalar alignment (type)\t\nProto: no-proto\t\n[cpp11] [<cstddef> (stddef.h)]
mbstate_t()Param: ()\t\nDesc: Multibyte conversion state (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
mbrtoc16( char16_t * pc16, const char * pmb, size_t max, mbstate_t * ps)Param: (Pointer to an object of type char16_t.)\t\nDesc: Convert multibyte sequence to 16-bit character (function)\t\nProto: size_t mbrtoc16 ( char16_t * pc16, const char * pmb, size_t max, mbstate_t * ps);\t\n[c11 cpp11] [<cuchar> (uchar.h)]
mbrtoc32( char32_t * pc32, const char * pmb, size_t max, mbstate_t * ps)Param: (Pointer to an object of type char32_t.)\t\nDesc: Convert multibyte sequence to 32-bit character (function)\t\nProto: size_t mbrtoc32 ( char32_t * pc32, const char * pmb, size_t max, mbstate_t * ps);\t\n[c11 cpp11] [<cuchar> (uchar.h)]
memchr( const void * ptr, int value, size_t num )Param: (Pointer to the block of memory where the search is performed.)\t\nDesc: Locate character in block of memory (function)\t\nProto: const void * memchr ( const void * ptr, int value, size_t num );void * memchr ( void * ptr, int value, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
memcmp( const void * ptr1, const void * ptr2, size_t num )Param: (Pointer to block of memory.)\t\nDesc: Compare two blocks of memory (function)\t\nProto: int memcmp ( const void * ptr1, const void * ptr2, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
memcpy( void * destination, const void * source, size_t num )Param: (Pointer to the destination array where the content is to be copied, type-casted to a pointer of type )\t\nDesc: Copy block of memory (function)\t\nProto: void * memcpy ( void * destination, const void * source, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
memmove( void * destination, const void * source, size_t num )Param: (Pointer to the destination array where the content is to be copied, type-casted to a pointer of type )\t\nDesc: Move block of memory (function)\t\nProto: void * memmove ( void * destination, const void * source, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
memset( void * ptr, int value, size_t num )Param: (Pointer to the block of memory to fill.)\t\nDesc: Fill block of memory (function)\t\nProto: void * memset ( void * ptr, int value, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
mblen(const char* pmb, size_t max)Param: (Pointer to the first byte of a multibyte character.)\t\nDesc: Get length of multibyte character (function)\t\nProto: int mblen (const char* pmb, size_t max);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
mbrlen(const char* pmb, size_t max, mbstate_t* ps)Param: (Pointer to the first byte of a multibyte character.)\t\nDesc: Get length of multibyte character (function)\t\nProto: size_t mbrlen (const char* pmb, size_t max, mbstate_t* ps);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
mbsinit(const mbstate_t* ps)Param: (Pointer to an mbstate_t object.)\t\nDesc: Check if initial conversion state (function)\t\nProto: int mbsinit (const mbstate_t* ps);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
modf(double x)Param: (Floating point value to break into parts.)\t\nDesc: Break into fractional and integral parts (function)\t\nProto: double modf (double x, double* intpart);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
malloc(size_t size)Param: (Size of the memory block, in bytes.)\t\nDesc: Allocate memory block (function)\t\nProto: void* malloc (size_t size);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
mktime(struct tm * timeptr)Param: (Pointer to a tm structure that contains a calendar time broken down into its components (see struct tm).)\t\nDesc: Convert tm structure to time_t (function)\t\nProto: time_t mktime (struct tm * timeptr);\t\n[c90 c99 arm cpp98 cpp11] [<ctime> (time.h)]
mbstowcs(wchar_t* dest, const char* src, size_t max)Param: (Pointer to an array of wchar_t elements long enough to contain the resulting sequence (at most, max wide characters).)\t\nDesc: Convert multibyte string to wide-character string (function)\t\nProto: size_t mbstowcs (wchar_t* dest, const char* src, size_t max);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
mbsrtowcs(wchar_t* dest, const char** src, size_t max, mbstate_t* ps)Param: (Pointer to an array of wchar_t elements long enough to store a string of max wide characters.)\t\nDesc: Convert multibyte string to wide-character string (function)\t\nProto: size_t mbsrtowcs (wchar_t* dest, const char** src, size_t max, mbstate_t* ps);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
mbtowc(wchar_t* pwc, const char* pmb, size_t max)Param: (Pointer to an object of type wchar_t.)\t\nDesc: Convert multibyte sequence to wide character (function)\t\nProto: int mbtowc (wchar_t* pwc, const char* pmb, size_t max);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
mbrtowc(wchar_t* pwc, const char* pmb, size_t max, mbstate_t* ps)Param: (Pointer to an object of type wchar_t.)\t\nDesc: Convert multibyte sequence to wide character (function)\t\nProto: size_t mbrtowc (wchar_t* pwc, const char* pmb, size_t max, mbstate_t* ps);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
nanf(const char* tagp)Param: (An implementation-specific C-string.)\t\nDesc: no-Description (other)\t\nProto: float nanf (const char* tagp);\t\n[c99 cpp11] [<cmath> (math.h)]
nanl(const char* tagp)Param: (An implementation-specific C-string.)\t\nDesc: no-Description (other)\t\nProto: float nanl (const char* tagp);\t\n[c99 cpp11] [<cmath> (math.h)]
nearbyint(double x)Param: (Value to round.)\t\nDesc: Round to nearby integral value (function)\t\nProto: double nearbyint (double x); float nearbyintf (float x);long double nearbyintl (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
nextafter(double x)Param: (Base value.)\t\nDesc: Next representable value (function)\t\nProto: double nextafter (double x, double y); float nextafterf (float x , float y);long double nextafterl (long double x, long double y);\t\n[c99 cpp11] [<cmath> (math.h)]
nexttoward(double x)Param: (Base value.)\t\nDesc: Next representable value toward precise value (function)\t\nProto: double nexttoward (double x, long double y); float nexttowardf (float x , long double y);long double nexttowardl (long double x, long double y);\t\n[c99 cpp11] [<cmath> (math.h)]
nullptr_t(nullptr) nullptr_t;Param: ()\t\nDesc: Null pointer type (C++) (type)\t\nProto: typedef decltype(nullptr) nullptr_t;\t\n[cpp11] [<cstddef> (stddef.h)]
offsetof(type,member)Param: (A type in which member is a valid member designator.)\t\nDesc: Return member offset (macro)\t\nProto: offsetof (type,member)\t\n[c90 c99 arm cpp98 cpp11] [<cstddef> (stddef.h)]
ptrdiff_t()Param: ()\t\nDesc: Result of pointer subtraction (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstddef> (stddef.h)]
perror( const char * str )Param: (C string containing a custom message to be printed before the error message itself.)\t\nDesc: Print error message (function)\t\nProto: void perror ( const char * str );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
putchar( int character )Param: (The int promotion of the character to be written.)\t\nDesc: Write character to stdout (function)\t\nProto: int putchar ( int character );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
pow(double base, double exponent)Param: (Base value.)\t\nDesc: Raise to power (function)\t\nProto: double pow (double base, double exponent);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
putwchar(wchar_t wc)Param: (The wide character to be written.)\t\nDesc: Write wide character to stdout (function)\t\nProto: wint_t putwchar (wchar_t wc);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
qsort(void* base, size_t num, size_t size, int (*compar)(const void*,const void*))Param: (Pointer to the first object of the array to be sorted, converted to a )\t\nDesc: Sort elements of array (function)\t\nProto: void qsort (void* base, size_t num, size_t size, int (*compar)(const void*,const void*));\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
remove( const char * filename )Param: (C string containing the name of the file to be deleted.)\t\nDesc: Remove file (function)\t\nProto: int remove ( const char * filename );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
rename( const char * oldname, const char * newname )Param: (C string containing the name of an existing file to be renamed and/or moved.)\t\nDesc: Rename file (function)\t\nProto: int rename ( const char * oldname, const char * newname );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
rewind( FILE * stream )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Set position of stream to the beginning (function)\t\nProto: void rewind ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
remainder(double numer, double denom)Param: (Value of the quotient numerator.)\t\nDesc: Compute remainder (IEC 60559) (function)\t\nProto: double remainder (double numer, double denom); float remainderf (float numer , float denom);long double remainderl (long double numer, long double denom);\t\n[c99 cpp11] [<cmath> (math.h)]
remquo(double numer, double denom, int* quot)Param: (Floating point value with the quotient numerator.)\t\nDesc: Compute remainder and quotient (function)\t\nProto: double remquo (double numer, double denom, int* quot); float remquof (float numer , float denom , int* quot);long double remquol (long double numer, long double denom, int* quot);\t\n[c99 cpp11] [<cmath> (math.h)]
rand(void)Param: ()\t\nDesc: Generate random number (function)\t\nProto: int rand (void);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
realloc(void* ptr, size_t size)Param: (Pointer to a memory block previously allocated with malloc, calloc or realloc.)\t\nDesc: Reallocate memory block (function)\t\nProto: void* realloc (void* ptr, size_t size);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
struct lconv()Param: ()\t\nDesc: Formatting info for numeric values (type)\t\nProto: struct lconv;\t\n[c90 c99 arm cpp98 cpp11] [<clocale> (locale.h)]
signbit(x)Param: (A floating-point value.)\t\nDesc: Sign bit (macro/function)\t\nProto: signbit(x)\t\n[c99 cpp11] [<cmath> (math.h)]
size_t()Param: ()\t\nDesc: Unsigned integral type (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstddef> (stddef.h)]
stderr()Param: ()\t\nDesc: no-Description (other)\t\nProto: FILE * stderr;\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
stdin()Param: ()\t\nDesc: no-Description (other)\t\nProto: FILE * stdin;\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
stdout()Param: ()\t\nDesc: no-Description (other)\t\nProto: FILE * stdout;\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
struct tm()Param: ()\t\nDesc: Time structure (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<ctime> (time.h)]
strcat( char * destination, const char * source )Param: (Pointer to the destination array, which should contain a C string, and be large enough to contain the concatenated resulting string.)\t\nDesc: Concatenate strings (function)\t\nProto: char * strcat ( char * destination, const char * source );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strcpy( char * destination, const char * source )Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Copy string (function)\t\nProto: char * strcpy ( char * destination, const char * source );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strncat( char * destination, const char * source, size_t num )Param: (Pointer to the destination array, which should contain a C string, and be large enough to contain the concatenated resulting string, including the additional null-character.)\t\nDesc: Append characters from string (function)\t\nProto: char * strncat ( char * destination, const char * source, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strncpy( char * destination, const char * source, size_t num )Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Copy characters from string (function)\t\nProto: char * strncpy ( char * destination, const char * source, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strxfrm( char * destination, const char * source, size_t num )Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Transform string using locale (function)\t\nProto: size_t strxfrm ( char * destination, const char * source, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
snprintf( char * s, size_t n, const char * format, ... )Param: (Pointer to a buffer where the resulting C-string is stored.)\t\nDesc: Write formatted output to sized buffer (function)\t\nProto: int snprintf ( char * s, size_t n, const char * format, ... );\t\n[c99 cpp11] [<cstdio> (stdio.h)]
strtok( char * str, const char * delimiters )Param: (C string to truncate.)\t\nDesc: Split string into tokens (function)\t\nProto: char * strtok ( char * str, const char * delimiters );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
sprintf( char * str, const char * format, ... )Param: (Pointer to a buffer where the resulting C-string is stored.)\t\nDesc: Write formatted data to string (function)\t\nProto: int sprintf ( char * str, const char * format, ... );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
sscanf( const char * s, const char * format, ...)Param: (C string that the function processes as its source to retrieve the data.)\t\nDesc: Read formatted data from string (function)\t\nProto: int sscanf ( const char * s, const char * format, ...);\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
strlen( const char * str )Param: (C string.)\t\nDesc: Get string length (function)\t\nProto: size_t strlen ( const char * str );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strchr( const char * str, int character )Param: (C string.)\t\nDesc: Locate first occurrence of character in string (function)\t\nProto: const char * strchr ( const char * str, int character );char * strchr ( char * str, int character );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strrchr( const char * str, int character )Param: (C string.)\t\nDesc: Locate last occurrence of character in string (function)\t\nProto: const char * strrchr ( const char * str, int character );char * strrchr ( char * str, int character );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strcmp( const char * str1, const char * str2 )Param: (C string to be compared.)\t\nDesc: Compare two strings (function)\t\nProto: int strcmp ( const char * str1, const char * str2 );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strcoll( const char * str1, const char * str2 )Param: (C string to be compared.)\t\nDesc: Compare two strings using locale (function)\t\nProto: int strcoll ( const char * str1, const char * str2 );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strcspn( const char * str1, const char * str2 )Param: (C string to be scanned.)\t\nDesc: Get span until character in string (function)\t\nProto: size_t strcspn ( const char * str1, const char * str2 );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strspn( const char * str1, const char * str2 )Param: (C string to be scanned.)\t\nDesc: Get span of character set in string (function)\t\nProto: size_t strspn ( const char * str1, const char * str2 );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strpbrk( const char * str1, const char * str2 )Param: (C string to be scanned.)\t\nDesc: Locate characters in string (function)\t\nProto: const char * strpbrk ( const char * str1, const char * str2 );char * strpbrk ( char * str1, const char * str2 );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strstr( const char * str1, const char * str2 )Param: (C string to be scanned.)\t\nDesc: Locate substring (function)\t\nProto: const char * strstr ( const char * str1, const char * str2 );char * strstr ( char * str1, const char * str2 );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
strncmp( const char * str1, const char * str2, size_t num )Param: (C string to be compared.)\t\nDesc: Compare characters of two strings (function)\t\nProto: int strncmp ( const char * str1, const char * str2, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
setbuf( FILE * stream, char * buffer )Param: (Pointer to a FILE object that identifies an open stream.)\t\nDesc: Set stream buffer (function)\t\nProto: void setbuf ( FILE * stream, char * buffer );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
setvbuf( FILE * stream, char * buffer, int mode, size_t size )Param: (Pointer to a FILE object that identifies an open stream.)\t\nDesc: Change stream buffering (function)\t\nProto: int setvbuf ( FILE * stream, char * buffer, int mode, size_t size );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
strerror( int errnum )Param: (Error number.)\t\nDesc: Get pointer to error message string (function)\t\nProto: char * strerror ( int errnum );\t\n[c90 c99 arm cpp98 cpp11] [<cstring> (string.h)]
signal( void * ptr, size_t size, size_t count, FILE * stream )Param: (The signal value to which a handling function is set.)\t\nDesc: Set function to handle signal (function)\t\nProto: void (*signal(int sig, void (*func)(int)))(int);\t\n[c90 c99 arm cpp98 cpp11] [<csignal> (signal.h)]
strftime(char* ptr, size_t maxsize, const char* format,const struct tm* timeptr )Param: (Pointer to the destination array where the resulting C string is copied.)\t\nDesc: Format time as string (function)\t\nProto: size_t strftime (char* ptr, size_t maxsize, const char* format,const struct tm* timeptr );\t\n[c90 c99 arm cpp98 cpp11] [<ctime> (time.h)]
system(const char* command)Param: (C-string containing the system command to be executed.)\t\nDesc: Execute system command (function)\t\nProto: int system (const char* command);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
strtod(const char* str, char** endptr)Param: (C-string beginning with the representation of a floating-point number.)\t\nDesc: Convert string to double (function)\t\nProto: double strtod (const char* str, char** endptr);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
strtof(const char* str, char** endptr)Param: (C-string beginning with the representation of a floating-point number.)\t\nDesc: Convert string to float (function)\t\nProto: float strtof (const char* str, char** endptr);\t\n[c99 cpp11] [<cstdlib> (stdlib.h)]
strtold(const char* str, char** endptr)Param: (C string beginning with the representation of a floating-point number.)\t\nDesc: Convert string to long double (function)\t\nProto: long double strtold (const char* str, char** endptr);\t\n[c99 cpp11] [<cstdlib> (stdlib.h)]
strtol(const char* str, char** endptr, int base)Param: (C-string beginning with the representation of an integral number.)\t\nDesc: Convert string to long integer (function)\t\nProto: long int strtol (const char* str, char** endptr, int base);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
strtoll(const char* str, char** endptr, int base)Param: (C-string beginning with the representation of an integral number.)\t\nDesc: Convert string to long long integer (function)\t\nProto: long long int strtoll (const char* str, char** endptr, int base);\t\n[c99 cpp11] [<cstdlib> (stdlib.h)]
strtoul(const char* str, char** endptr, int base)Param: (C-string containing the representation of an integral number.)\t\nDesc: Convert string to unsigned long integer (function)\t\nProto: unsigned long int strtoul (const char* str, char** endptr, int base);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
strtoull(const char* str, char** endptr, int base)Param: (C-string beginning with the representation of an integral number.)\t\nDesc: Convert string to unsigned long long integer (function)\t\nProto: unsigned long long int strtoull (const char* str, char** endptr, int base);\t\n[c99 cpp11] [<cstdlib> (stdlib.h)]
swscanf(const wchar_t* ws, const wchar_t* format, ...)Param: (C wide string that the function processes as its source to retrieve the data.)\t\nDesc: Read formatted data from string (function)\t\nProto: int swscanf (const wchar_t* ws, const wchar_t* format, ...);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
sqrt(double x)Param: (Value whose square root is computed.)\t\nDesc: Compute square root (function)\t\nProto: double sqrt (double x);\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
scalbn(double x)Param: (Value representing the significand.)\t\nDesc: Scale significand using floating-point base exponent (function)\t\nProto: double scalbn (double x, int n); float scalbnf (float x , int n);long double scalbnl (long double x, int n);\t\n[c99 cpp11] [<cmath> (math.h)]
scalbln(double x)Param: (significand.)\t\nDesc: Scale significand using floating-point base exponent (long) (function)\t\nProto: double scalbln (double x, long int n); float scalblnf (float x , long int n);long double scalblnl (long double x, long int n);\t\n[c99 cpp11] [<cmath> (math.h)]
setlocale(int category, const char* locale)Param: (Portion of the locale affected.)\t\nDesc: Set or retrieve locale (function)\t\nProto: char* setlocale (int category, const char* locale);\t\n[c90 c99 arm cpp98 cpp11] [<clocale> (locale.h)]
setjmp(jmp_buf env)Param: (Object of type jmp_buf where the environment information is stored.)\t\nDesc: Save calling environment for long jump (macro)\t\nProto: int setjmp (jmp_buf env);\t\n[c90 c99 arm cpp98 cpp11] [<csetjmp> (setjmp.h)]
srand(unsigned int seed)Param: (An integer value to be used as seed by the pseudo-random number generator algorithm.)\t\nDesc: Initialize random number generator (function)\t\nProto: void srand (unsigned int seed);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
swprintf(wchar_t* ws, size_t len, const wchar_t* format, ...)Param: (Pointer to a buffer where the resulting C wide string is stored.)\t\nDesc: Write formatted data to wide string (function)\t\nProto: int swprintf (wchar_t* ws, size_t len, const wchar_t* format, ...);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
time_t()Param: ()\t\nDesc: Time type (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<ctime> (time.h)]
tmpnam( char * str )Param: (Pointer to an array of characters where the proposed temporary name will be stored as a C string.)\t\nDesc: Generate temporary filename (function)\t\nProto: char * tmpnam ( char * str );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
tolower( int c )Param: (Character to be converted, casted to an int, or EOF.)\t\nDesc: Convert uppercase letter to lowercase (function)\t\nProto: int tolower ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
toupper( int c )Param: (Character to be converted, casted to an int, or EOF.)\t\nDesc: Convert lowercase letter to uppercase (function)\t\nProto: int toupper ( int c );\t\n[c90 c99 arm cpp98 cpp11] [<cctype> (ctype.h)]
tmpfile( void )Param: ()\t\nDesc: Open a temporary file (function)\t\nProto: FILE * tmpfile ( void );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
towlower( void * ptr, size_t size, size_t count, FILE * stream )Param: (Wide character to be converted, casted to a wint_t value, or WEOF.)\t\nDesc: Convert uppercase wide character to lowercase (function)\t\nProto: wint_t towlower ( wint_t c );\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
tgamma(double x)Param: (Parameter for the gamma function.)\t\nDesc: Compute gamma function (function)\t\nProto: double tgamma (double x); float tgammaf ( float x);long double tgammal (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
trunc(double x)Param: (Value to truncate.)\t\nDesc: Truncate value (function)\t\nProto: double trunc (double x); float truncf ( float x);long double truncl (long double x);\t\n[c99 cpp11] [<cmath> (math.h)]
towupper(wint_t c)Param: (Wide character to be converted, casted to a wint_t value, or WEOF.)\t\nDesc: Convert lowercase wide character to uppercase (function)\t\nProto: wint_t towupper (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
towctrans(wint_t c, wctrans_t desc)Param: (Wide character to be transformed, casted to a wint_t value, or WEOF.)\t\nDesc: Convert using transformation (function)\t\nProto: wint_t towctrans(wint_t c, wctrans_t desc);\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
ungetc( int character, FILE * stream )Param: (The int promotion of the character to be put back.)\t\nDesc: Unget character from stream (function)\t\nProto: int ungetc ( int character, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
ungetwc(wint_t wc, FILE* stream)Param: (The wint_t promotion of the wide character to be put back.)\t\nDesc: Unget wide character from stream (function)\t\nProto: wint_t ungetwc (wint_t wc, FILE* stream);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
va_list()Param: ()\t\nDesc: Type to hold information about variable arguments (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdarg> (stdarg.h)]
vprintf( const char * format, va_list arg )Param: (C string that contains a format string that follows the same specifications as format in printf (see printf for details).)\t\nDesc: Print formatted data from variable argument list to stdout (function)\t\nProto: int vprintf ( const char * format, va_list arg );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
vscanf( const char * format, va_list arg )Param: (C string that contains a format string that follows the same specifications as format in scanf (see scanf for details).)\t\nDesc: Read formatted data into variable argument list (function)\t\nProto: int vscanf ( const char * format, va_list arg );\t\n[c99 cpp11] [<cstdio> (stdio.h)]
vsscanf( const char * s, const char * format, va_list arg )Param: (C string that the function processes as its source to retrieve the data.)\t\nDesc: Read formatted data from string into variable argument list (function)\t\nProto: int vsscanf ( const char * s, const char * format, va_list arg );\t\n[c99 cpp11] [<cstdio> (stdio.h)]
vwscanf( const wchar_t * format, va_list arg )Param: (C wide string that contains a format string that follows the same specifications as format in scanf (see scanf for details).)\t\nDesc: Read formatted data into variable argument list (function)\t\nProto: int vwscanf ( const wchar_t * format, va_list arg );\t\n[c99 cpp11] [<cwchar> (wchar.h)]
vfprintf( FILE * stream, const char * format, va_list arg )Param: (Pointer to a FILE object that identifies an output stream.)\t\nDesc: Write formatted data from variable argument list to stream (function)\t\nProto: int vfprintf ( FILE * stream, const char * format, va_list arg );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
vfscanf( FILE * stream, const char * format, va_list arg )Param: (Pointer to a FILE object that identifies an input stream.)\t\nDesc: Read formatted data from stream into variable argument list (function)\t\nProto: int vfscanf ( FILE * stream, const char * format, va_list arg );\t\n[c99 cpp11] [<cstdio> (stdio.h)]
vsprintf(char * s, const char * format, va_list arg )Param: (Pointer to a buffer where the resulting C-string is stored.)\t\nDesc: Write formatted data from variable argument list to string (function)\t\nProto: int vsprintf (char * s, const char * format, va_list arg );\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
vsnprintf(char * s, size_t n, const char * format, va_list arg )Param: (Pointer to a buffer where the resulting C-string is stored.)\t\nDesc: Write formatted data from variable argument list to sized buffer (function)\t\nProto: int vsnprintf (char * s, size_t n, const char * format, va_list arg );\t\n[c99 cpp11] [<cstdio> (stdio.h)]
vwprintf(const wchar_t* format, va_list arg)Param: (C wide string that contains a format string that follows the same specifications as format in printf (see printf for details).)\t\nDesc: Print formatted data from variable argument list to stdout (function)\t\nProto: int vwprintf (const wchar_t* format, va_list arg);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
vswscanf(const wchar_t* ws, const wchar_t* format, va_list arg)Param: (C wide string that the function processes as its source to retrieve the data.)\t\nDesc: Read formatted data from wide string into variable argument list (function)\t\nProto: int vswscanf (const wchar_t* ws, const wchar_t* format, va_list arg);\t\n[c99 cpp11] [<cwchar> (wchar.h)]
vfwprintf(FILE* stream, const wchar_t* format, va_list arg)Param: (Pointer to a FILE object that identifies an output stream.)\t\nDesc: Write formatted data from variable argument list to stream (function)\t\nProto: int vfwprintf (FILE* stream, const wchar_t* format, va_list arg);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
vfwscanf(FILE* stream, const wchar_t* format, va_list arg)Param: (Pointer to a FILE object that identifies an input stream.)\t\nDesc: Read formatted data from stream into variable argument list (function)\t\nProto: int vfwscanf (FILE* stream, const wchar_t* format, va_list arg);\t\n[c99 cpp11] [<cwchar> (wchar.h)]
va_end(va_list ap)Param: (va_list object previously initialized by va_start or va_copy.)\t\nDesc: End using variable argument list (macro)\t\nProto: void va_end (va_list ap);\t\n[c90 c99 arm cpp98 cpp11] [<cstdarg> (stdarg.h)]
va_start(va_list ap, paramN)Param: (Uninitialized object of type va_list.)\t\nDesc: Initialize a variable argument list (macro)\t\nProto: void va_start (va_list ap, paramN);\t\n[c90 c99 arm cpp98 cpp11] [<cstdarg> (stdarg.h)]
va_arg(va_list ap, type)Param: (Object of type va_list carrying information about the current retrieval state of a variable argument list.)\t\nDesc: Retrieve next argument (macro)\t\nProto: type va_arg (va_list ap, type)\t\n[c90 c99 arm cpp98 cpp11] [<cstdarg> (stdarg.h)]
va_copy(va_list dest, va_list src)Param: (Uninitialized object of type va_list.)\t\nDesc: Copy variable argument list (macro)\t\nProto: void va_copy (va_list dest, va_list src);\t\n[c99 cpp11] [<cstdarg> (stdarg.h)]
vswprintf(wchar_t * ws, size_t len, const wchar_t * format, va_list arg )Param: (Pointer to a buffer where the resulting C wide string is stored.)\t\nDesc: Write formatted data from variable argument list to sized buffer (function)\t\nProto: int vswprintf (wchar_t * ws, size_t len, const wchar_t * format, va_list arg );\t\n[c99 cpp11] [<cwchar> (wchar.h)]
wchar_t()Param: ()\t\nDesc: Wide character (type)\t\nProto: no-proto\t\n[c99] [<cwchar> (wchar.h)]
wint_t()Param: ()\t\nDesc: Wide int type (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wctrans_t()Param: ()\t\nDesc: Wide character transformation (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
wctype_t()Param: ()\t\nDesc: Wide character type (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cwctype> (wctype.h)]
wcstombs(char* dest, const wchar_t* src, size_t max)Param: (Pointer to an array of char elements long enough to contain the resulting sequence (at most, max bytes).)\t\nDesc: Convert wide-character string to multibyte string (function)\t\nProto: size_t wcstombs (char* dest, const wchar_t* src, size_t max);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
wcsrtombs(char* dest, const wchar_t** src, size_t max, mbstate_t* ps)Param: (Pointer to an array of char elements long enough to store a C string of max bytes.)\t\nDesc: Convert wide-character string to multibyte string (function)\t\nProto: size_t wcsrtombs (char* dest, const wchar_t** src, size_t max, mbstate_t* ps);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wctomb(char* pmb, wchar_t wc)Param: ()\t\nDesc: Convert wide character to multibyte sequence (function)\t\nProto: int wctomb (char* pmb, wchar_t wc);\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
wcrtomb(char* pmb, wchar_t wc, mbstate_t* ps)Param: (Pointer to an array large enough to hold a multibyte sequence.)\t\nDesc: Convert wide character to multibyte sequence (function)\t\nProto: size_t wcrtomb (char* pmb, wchar_t wc, mbstate_t* ps);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wmemchr(const wchar_t* ptr, wchar_t wc, size_t num)wchar_t* wmemchr (wchar_t* ptr, wchar_t wc, size_t num)Param: (Pointer to the array of wchar_t elements to be searched.)\t\nDesc: Locate character in block of wide characters (function)\t\nProto: const wchar_t* wmemchr (const wchar_t* ptr, wchar_t wc, size_t num);wchar_t* wmemchr (wchar_t* ptr, wchar_t wc, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wmemcmp(const wchar_t* ptr1, const wchar_t* ptr2, size_t num)Param: (Pointer to block of elements of type wchar_t.)\t\nDesc: Compare two blocks of wide characters (function)\t\nProto: int wmemcmp (const wchar_t* ptr1, const wchar_t* ptr2, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcstod(const wchar_t* str, wchar_t** endptr)Param: (C wide string beginning with the representation of a floating-point number.)\t\nDesc: Convert wide string to double (function)\t\nProto: double wcstod (const wchar_t* str, wchar_t** endptr);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcstof(const wchar_t* str, wchar_t** endptr)Param: (C wide string beginning with the representation of a floating-point number.)\t\nDesc: Convert wide string to float (function)\t\nProto: float wcstof (const wchar_t* str, wchar_t** endptr);\t\n[c99 cpp11] [<cwchar> (wchar.h)]
wcstold(const wchar_t* str, wchar_t** endptr)Param: (C wide string beginning with the representation of a floating-point number.)\t\nDesc: Convert wide string to long double (function)\t\nProto: long double wcstold (const wchar_t* str, wchar_t** endptr);\t\n[c99 cpp11] [<cwchar> (wchar.h)]
wcstol(const wchar_t* str, wchar_t** endptr, int base)Param: (C wide string beginning with the representation of an integral number.)\t\nDesc: Convert wide string to long integer (function)\t\nProto: long int wcstol (const wchar_t* str, wchar_t** endptr, int base);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcstoll(const wchar_t* str, wchar_t** endptr, int base)Param: (C wide string beginning with the representation of an integral number.)\t\nDesc: Convert wide string to long long integer (function)\t\nProto: long long int strtoll (const wchar_t* str, wchar_t** endptr, int base);\t\n[c99 cpp11] [<cwchar> (wchar.h)]
wcstoul(const wchar_t* str, wchar_t** endptr, int base)Param: (C wide string containing the representation of an integral number.)\t\nDesc: Convert wide string to unsigned long integer (function)\t\nProto: unsigned long int wcstoul (const wchar_t* str, wchar_t** endptr, int base);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcstoull(const wchar_t* str, wchar_t** endptr, int base)Param: (C wide string beginning with the representation of an integral number.)\t\nDesc: Convert wide string to unsigned long long integer (function)\t\nProto: unsigned long long int wcstoull (const wchar_t* str, wchar_t** endptr, int base);\t\n[c99 cpp11] [<cwchar> (wchar.h)]
wcslen(const wchar_t* wcs)Param: (C wide string.)\t\nDesc: Get wide string length (function)\t\nProto: size_t wcslen (const wchar_t* wcs);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcscmp(const wchar_t* wcs1, const wchar_t* wcs2)Param: (C wide string to be compared.)\t\nDesc: Compare two strings (function)\t\nProto: int wcscmp (const wchar_t* wcs1, const wchar_t* wcs2);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcscoll(const wchar_t* wcs1, const wchar_t* wcs2)Param: (C wide string to be compared.)\t\nDesc: Compare two wide strings using locale (function)\t\nProto: int wcscoll (const wchar_t* wcs1, const wchar_t* wcs2);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcscspn(const wchar_t* wcs1, const wchar_t* wcs2)Param: (C wide string to be scanned.)\t\nDesc: Get span until character in wide string (function)\t\nProto: size_t wcscspn (const wchar_t* wcs1, const wchar_t* wcs2);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcsspn(const wchar_t* wcs1, const wchar_t* wcs2)Param: (C wide string to be scanned.)\t\nDesc: Get span of character set in wide string (function)\t\nProto: size_t wcsspn (const wchar_t* wcs1, const wchar_t* wcs2);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcspbrk(const wchar_t* wcs1, const wchar_t* wcs2)Param: (C wide string to be scanned.)\t\nDesc: Locate characters in wide string (function)\t\nProto: const wchar_t* wcspbrk (const wchar_t* wcs1, const wchar_t* wcs2);wchar_t* wcspbrk (wchar_t* wcs1, const wchar_t* wcs2);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcsstr(const wchar_t* wcs1, const wchar_t* wcs2)Param: (C wide string to be scanned.)\t\nDesc: Locate substring of wide string (function)\t\nProto: const wchar_t* wcsstr (const wchar_t* wcs1, const wchar_t* wcs2);wchar_t* wcsstr (wchar_t* wcs1, const wchar_t* wcs2);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcsncmp(const wchar_t* wcs1, const wchar_t* wcs2, size_t num)Param: (C wide string to be compared.)\t\nDesc: Compare characters of two wide strings (function)\t\nProto: int wcsncmp (const wchar_t* wcs1, const wchar_t* wcs2, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcschr(const wchar_t* ws, wchar_t wc)Param: (C wide string.)\t\nDesc: Locate first occurrence of character in wide string (function)\t\nProto: const wchar_t* wcschr (const wchar_t* ws, wchar_t wc);wchar_t* wcschr (wchar_t* ws, wchar_t wc);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcsrchr(const wchar_t* ws, wchar_t wc)Param: (C wide string.)\t\nDesc: Locate last occurrence of character in wide string (function)\t\nProto: const wchar_t* wcsrchr (const wchar_t* ws, wchar_t wc);wchar_t* wcsrchr (wchar_t* ws, wchar_t wc);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcscat(wchar_t* destination, const wchar_t* source)Param: (Pointer to the destination array, which should contain a C wide string, and be large enough to contain the concatenated resulting string.)\t\nDesc: Concatenate wide strings (function)\t\nProto: wchar_t* wcscat (wchar_t* destination, const wchar_t* source);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcscpy(wchar_t* destination, const wchar_t* source)Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Copy wide string (function)\t\nProto: wchar_t* wcscpy (wchar_t* destination, const wchar_t* source);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcsncat(wchar_t* destination, const wchar_t* source, size_t num)Param: (Pointer to the destination array, which should contain a C wide string, and be large enough to contain the concatenated resulting string, including the additional null wide character.)\t\nDesc: Append characters from wide string (function)\t\nProto: wchar_t* wcsncat (wchar_t* destination, const wchar_t* source, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcsncpy(wchar_t* destination, const wchar_t* source, size_t num)Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Copy characters from wide string (function)\t\nProto: wchar_t* wcsncpy (wchar_t* destination, const wchar_t* source, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcsxfrm(wchar_t* destination, const wchar_t* source, size_t num)Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Transform wide string using locale (function)\t\nProto: size_t wcsxfrm (wchar_t* destination, const wchar_t* source, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wmemcpy(wchar_t* destination, const wchar_t* source, size_t num)Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Copy block of wide characters (function)\t\nProto: wchar_t* wmemcpy (wchar_t* destination, const wchar_t* source, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wmemmove(wchar_t* destination, const wchar_t* source, size_t num)Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Move block of wide characters (function)\t\nProto: wchar_t* wmemmove (wchar_t* destination, const wchar_t* source, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcsftime(wchar_t* ptr, size_t maxsize, const wchar_t* format,const struct tm* timeptr)Param: (Pointer to the destination array where the resulting C wide string is copied.)\t\nDesc: Format time as wide string (function)\t\nProto: size_t wcsftime (wchar_t* ptr, size_t maxsize, const wchar_t* format,const struct tm* timeptr);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wmemset(wchar_t* ptr, wchar_t wc, size_t num)Param: (Pointer to the array to fill.)\t\nDesc: Fill array of wide characters (function)\t\nProto: wchar_t* wmemset (wchar_t* ptr, wchar_t wc, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wcstok(wchar_t* wcs, const wchar_t* delimiters)Param: (C wide string to truncate.)\t\nDesc: Split wide string into tokens (function)\t\nProto: wchar_t* wcstok (wchar_t* wcs, const wchar_t* delimiters);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
wctob(wint_t wc)Param: (The wint_t promotion of a wide character.)\t\nDesc: Convert wide character to single byte (function)\t\nProto: int wctob (wint_t wc);\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
array(T)Param: (Type of the elements contained.)\t\nDesc: Array class (class template)\t\nProto: template < class T, size_t N > class array;\t\n[cpp11 ] [<array>]
async(policy)Param: ()\t\nDesc: Call function asynchronously (function template)\t\nProto: long-proto\t\n[] [<future>]
adopt_lock_t()Param: ()\t\nDesc: Type of adopt_lock (class)\t\nProto: struct adopt_lock_t {};\t\n[cpp11] [<mutex>]
adjacent_find(first, last)Param: (Forward iterators to the initial and final positions of the searched sequence.)\t\nDesc: Find equal adjacent elements in range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
allocator(T)Param: (Type of the elements allocated by the object (aliased as member type value_type).)\t\nDesc: Default allocator (class template)\t\nProto: template <class T> class allocator;\t\n[cpp98 cpp11 ] [<memory>]
allocator_arg_t()Param: ()\t\nDesc: Allocator arg type (class)\t\nProto: struct allocator_arg_t {};\t\n[cpp11] [<memory>]
allocator_traits(Alloc)Param: (The allocator type, aliased as member type allocator_type.)\t\nDesc: Allocator traits (class template)\t\nProto: template <class Alloc> struct allocator_traits;\t\n[cpp11 ] [<memory>]
auto_ptr(X)Param: (The type of the managed object, aliased as member type element_type.)\t\nDesc: Automatic Pointer [deprecated] (class template)\t\nProto: template <class X> class auto_ptr;\t\n[cpp98 cpp11 ] [<memory>]
auto_ptr_ref()Param: ()\t\nDesc: Reference to automatic pointer (class template)\t\nProto: template <class Y> struct auto_ptr_ref;\t\n[cpp98 cpp11] [<memory>]
accumulate(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Accumulate values in range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<numeric>]
adjacent_difference(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Compute adjacent difference of range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<numeric>]
allocate_shared(const Alloc& alloc, Args&&... args)Param: (An allocator object.)\t\nDesc: Allocate shared_ptr (function template)\t\nProto: template <class T, class Alloc, class... Args>\t\nshared_ptr<T> allocate_shared (const Alloc& alloc, Args&&... args);\t\n[cpp11] [<memory>]
all_of(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Test condition on all elements in range (function template)\t\nProto: template <class InputIterator, class UnaryPredicate>\t\nbool all_of (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp11] [<algorithm>]
any_of(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Test if any element in range fulfills condition (function template)\t\nProto: template <class InputIterator, class UnaryPredicate>\t\nbool any_of (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp11] [<algorithm>]
advance(InputIterator& it, Distance n)Param: (Iterator to be advanced.)\t\nDesc: Advance iterator (function template)\t\nProto: template <class InputIterator, class Distance>\t\nvoid advance (InputIterator& it, Distance n);\t\n[cpp98 cpp11] [<iterator>]
addressof(T& ref)Param: (An object or function.)\t\nDesc: Address of object or function (function template)\t\nProto: template <class T> T* addressof (T& ref) noexcept;\t\n[cpp11] [<memory>]
basic_filebuf(charT)Param: (Character type.)\t\nDesc: File stream buffer (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_filebuf;\t\n[cpp98 cpp11 ] [<fstream>]
basic_fstream(charT)Param: (Character type.)\t\nDesc: File stream (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_fstream;\t\n[cpp98 cpp11 ] [<fstream>]
basic_ifstream(charT)Param: (Character type.)\t\nDesc: Input file stream (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_ifstream;\t\n[cpp98 cpp11 ] [<fstream>]
basic_ofstream(charT)Param: (Character type.)\t\nDesc: Output file stream (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_ofstream;\t\n[cpp98 cpp11 ] [<fstream>]
basic_ios(charT)Param: (Character type.)\t\nDesc: Base class for streams (type-dependent components) (class template)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_ios;\t\n[cpp98 cpp11 ] [<ios>]
basic_iostream(charT)Param: (Character type.)\t\nDesc: Input/output stream (class template)\t\nProto: template <class charT, class traits = char_traits<charT> > class basic_iostream;\t\n[cpp98 cpp11 ] [<istream>]
basic_istream(charT)Param: (Character type.)\t\nDesc: Input stream (class template)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_istream;\t\n[cpp98 cpp11 ] [<istream>]
basic_ostream(charT)Param: (Character type.)\t\nDesc: Output stream (class)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_ostream;\t\n[cpp98 cpp11 ] [<ostream>]
basic_istringstream(charT)Param: (Character type used by both the stream and the basic_string objects it accepts or generates.)\t\nDesc: Input string stream (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [<sstream>]
basic_ostringstream(charT)Param: (Character type used by both the stream and the basic_string objects it accepts or generates.)\t\nDesc: Output string stream (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [<sstream>]
basic_stringbuf(charT)Param: (Character type used by both the stream buffer and the basic_string objects it accepts or generates.)\t\nDesc: String stream buffer (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [<sstream>]
basic_stringstream(charT)Param: (Character type used by both the stream and the basic_string objects it accepts or generates.)\t\nDesc: String stream (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [<sstream>]
basic_streambuf(charT)Param: (Character type.)\t\nDesc: Base buffer class for streams (class template)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_streambuf;\t\n[cpp98 cpp11 ] [<streambuf>]
binary_search(first, last)Param: (Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.)\t\nDesc: Test if value exists in sorted sequence (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
bitset(N)Param: (Size of the bitset, in terms of number of bits.)\t\nDesc: Bitset (class template)\t\nProto: template <size_t N> class bitset;\t\n[cpp98 cpp11 ] [<bitset>]
bad_exception()Param: ()\t\nDesc: Exception thrown by unexpected handler (class)\t\nProto: class bad_exception;\t\n[cpp98 cpp11] [<exception>]
bind(fn)Param: (A function object, pointer to function or pointer to member.)\t\nDesc: Bind function arguments (function template)\t\nProto: long-proto\t\n[cpp11] [<functional>]
binary_negate(Predicate)Param: (A binary function object class, with members first_argument_type and second_argument_type defined.)\t\nDesc: Negate binary function object class (class template)\t\nProto: template <class Predicate> class binary_negate;\t\n[cpp98 cpp11] [<functional>]
bit_and(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Bitwise AND function object class (class template)\t\nProto: template <class T> struct bit_and;\t\n[cpp11] [<functional>]
bit_or(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Bitwise OR function object class (class template)\t\nProto: template <class T> struct bit_or;\t\n[class template] [cpp11]
bit_xor(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Bitwise XOR function object class (class template)\t\nProto: template <class T> struct bit_xor;\t\n[cpp11] [<functional>]
bad_function_call()Param: ()\t\nDesc: Exception thrown on bad call (class)\t\nProto: class bad_function_call;\t\n[cpp11] [<functional>]
binary_function()Param: ()\t\nDesc: Binary function object base class (class template)\t\nProto: template <class Arg1, class Arg2, class Result> struct binary_function;\t\n[cpp98 cpp11] [<functional>]
binder1st()Param: ()\t\nDesc: Generate function object class with 1st parameter bound (class template)\t\nProto: template <class Operation> class binder1st;\t\n[cpp98 cpp11] [<functional>]
binder2nd()Param: ()\t\nDesc: Generate function object class with 2nd parameter bound (class template)\t\nProto: template <class Operation> class binder2nd;\t\n[cpp98 cpp11] [<functional>]
bidirectional_iterator_tag()Param: ()\t\nDesc: Bidirectional iterator category (class)\t\nProto: struct bidirectional_iterator_tag {}\t\n[cpp98 cpp11] [<iterator>]
back_insert_iterator(Container)Param: (A container class with member push_back defined (such as the standard containers vector, deque and list).)\t\nDesc: Back insert iterator (class template)\t\nProto: template <class Container> class back_insert_iterator;\t\n[cpp98 cpp11] [<iterator>]
bad_weak_ptr()Param: ()\t\nDesc: no-Description (other)\t\nProto: class bad_weak_ptr: public exception;\t\n[cpp11 ] [<memory>]
bad_alloc()Param: ()\t\nDesc: Exception thrown on failure allocating memory (class)\t\nProto: class bad_alloc;\t\n[cpp98 cpp11] [<new>]
bad_array_new_length()Param: ()\t\nDesc: Exception on bad array length (class)\t\nProto: class bad_array_new_length;\t\n[cpp11] [<new>]
bernoulli_distribution()Param: ()\t\nDesc: Bernoulli distribution (class)\t\nProto: class bernoulli_distribution;\t\n[cpp11 ] [<random>]
binomial_distribution(IntType)Param: (An integer type.)\t\nDesc: Binomial distribution (class template)\t\nProto: template <class IntType = int> class binomial_distribution;\t\n[cpp11 ] [<random>]
basic_regex(charT)Param: (The character type.)\t\nDesc: Regular expression (class template)\t\nProto: template <class charT, class traits = regex_traits<charT> > class basic_regex;\t\n[cpp11 ] [<regex>]
bad_cast()Param: ()\t\nDesc: Exception thrown on failure to dynamic cast (class)\t\nProto: class bad_cast;\t\n[cpp98 cpp11] [<typeinfo>]
bad_typeid()Param: ()\t\nDesc: Exception thrown on typeid of null pointer (class)\t\nProto: class bad_typeid;\t\n[cpp98 cpp11] [<typeinfo>]
bind1st(const Operation& op, const T& x)Param: ()\t\nDesc: Return function object with first parameter bound (function template)\t\nProto: template <class Operation, class T>\t\nbinder1st<Operation> bind1st (const Operation& op, const T& x);\t\n[cpp98 cpp11] [<functional>]
bind2nd(const Operation& op, const T& x)Param: ()\t\nDesc: Return function object with second parameter bound (function template)\t\nProto: template <class Operation, class T>\t\nbinder2nd<Operation> bind2nd (const Operation& op, const T& x);\t\n[cpp98 cpp11] [<functional>]
begin(Container& cont)Param: (An object of a class type for which member begin is defined.)\t\nDesc: Iterator to beginning (function template)\t\nProto: template <class Container> auto begin (Container& cont) -> decltype (cont.begin());template <class Container> auto begin (const Container& cont) -> decltype (cont.begin());\t\n[cpp11] [<iterator>]
back_inserter(Container& x)Param: (Container on which the iterator will insert new elements.)\t\nDesc: Construct back insert iterator (function template)\t\nProto: template <class Container>\t\nback_insert_iterator<Container> back_inserter (Container& x);\t\n[cpp98 cpp11] [<iterator>]
boolalpha(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Alphanumerical bool values (function)\t\nProto: ios_base& boolalpha (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
cerr()Param: ()\t\nDesc: Standard output stream for errors (object)\t\nProto: extern ostream cerr;\t\n[arm cpp98 cpp11] [<iostream>]
cin()Param: ()\t\nDesc: Standard input stream (object)\t\nProto: extern istream cin;\t\n[arm cpp98 cpp11] [<iostream>]
clog()Param: ()\t\nDesc: Standard output stream for logging (object)\t\nProto: extern ostream clog;\t\n[arm cpp98 cpp11] [<iostream>]
cout()Param: ()\t\nDesc: Standard output stream (object)\t\nProto: extern ostream cout;\t\n[arm cpp98 cpp11] [<iostream>]
condition_variable()Param: ()\t\nDesc: Condition variable (class)\t\nProto: class condition_variable;\t\n[cpp11 ] [<condition_variable>]
condition_variable_any()Param: ()\t\nDesc: Condition variable (any lock) (class)\t\nProto: class condition_variable_any;\t\n[cpp11 ] [<condition_variable>]
cv_status()Param: ()\t\nDesc: Condition variable status (enum class)\t\nProto: enum class cv_status;\t\n[cpp11] [<condition_variable>]
copy_backward(first, last)Param: (Bidirectional iterators to the initial and final positions in a sequence to be copied.)\t\nDesc: Copy range of elements backward (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
common_type (duration)(Rep1, Rep2)Param: (Count representation types.)\t\nDesc: Specialization of common_type for duration (class template)\t\nProto: template <class Rep1, class Period1, class Rep2, class Period2>\t\nclass common_type<chrono::duration<Rep1,Period1>,chrono::duration<Rep2,Period2>>;\t\n[cpp11] [<chrono>]
common_type (time_point)(Clock)Param: (The clock used by both time_point types.)\t\nDesc: no-Description (other)\t\nProto: template <class Clock, class Duration1, class Duration2>\t\nclass common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>>;\t\n[cpp11] [<chrono>]
codecvt_utf16(Elem)Param: (The internal character type, aliased as member intern_type.)\t\nDesc: Convert UTF-16 (class template)\t\nProto: template < class Elem, unsigned long MaxCode = 0x10ffffUL, codecvt_mode Mode = (codecvt_mode)0 >\t\nclass codecvt_utf16 : public codecvt <Elem, char, mbstate_t>\t\n[cpp11] [<codecvt>]
codecvt_utf8(Elem)Param: (The internal character type, aliased as member intern_type.)\t\nDesc: Convert UTF-8 (class template)\t\nProto: template < class Elem, unsigned long MaxCode = 0x10ffffUL, codecvt_mode Mode = (codecvt_mode)0 >\t\nclass codecvt_utf8 : public codecvt <Elem, char, mbstate_t>\t\n[cpp11] [<codecvt>]
codecvt_utf8_utf16(Elem)Param: (The internal character type, aliased as member intern_type.)\t\nDesc: Convert between UTF-8 and UTF-16 (class template)\t\nProto: template < class Elem, unsigned long MaxCode = 0x10ffffUL, codecvt_mode Mode = (codecvt_mode)0 >\t\nclass codecvt_utf8_utf16 : public codecvt <Elem, char, mbstate_t>\t\n[cpp11] [<codecvt>]
codecvt_mode()Param: ()\t\nDesc: Codecvt mode (enum)\t\nProto: enum codecvt_mode {\t\nconsume_header = 4,\t\ngenerate_header = 2,\t\nlittle_endian = 1\t\n};\t\n[cpp11] [<codecvt>]
complex(T)Param: (Type of both the real and imaginary components of the complex number.)\t\nDesc: Complex number class (class template)\t\nProto: template <class T> class complex;\t\n[cpp98 cpp11 ] [<complex>]
cref(elem)Param: (An lvalue reference, whose const reference is stored in the object.)\t\nDesc: Construct reference_wrapper to const (function template)\t\nProto: long-proto\t\n[cpp11] [<functional>]
const_mem_fun1_ref_t()Param: ()\t\nDesc: Generate function object class from single-parameter const member (reference version) (class template)\t\nProto: template <class S, class T, class A> class const_mem_fun1_ref_t;\t\n[cpp98 cpp11] [<functional>]
const_mem_fun1_t()Param: ()\t\nDesc: Generate function object class from single-parameter const member (pointer version) (class template)\t\nProto: template <class S, class T, class A> class const_mem_fun1_t;\t\n[cpp98 cpp11] [<functional>]
const_mem_fun_ref_t()Param: ()\t\nDesc: Generate function object class from const parameterless member (reference version) (class template)\t\nProto: template <class S, class T> class const_mem_fun_ref_t;\t\n[cpp98 cpp11] [<functional>]
const_mem_fun_t()Param: ()\t\nDesc: Generate function object class from const parameterless member (pointer version) (class template)\t\nProto: template <class S, class T> class const_mem_fun_t;\t\n[cpp98 cpp11] [<functional>]
codecvt_base()Param: ()\t\nDesc: Base class for codecvt (class)\t\nProto: class codecvt_base;\t\n[cpp98 cpp11] [<locale>]
codecvt_byname()Param: ()\t\nDesc: Convert codeset facet (class template)\t\nProto: template <class internT, class externT, class stateT> class codecvt_byname;\t\n[cpp98 cpp11] [<locale>]
collate(charT)Param: (Character type.)\t\nDesc: Facet to compare and hash strings (class template)\t\nProto: template <class charT> class collate;\t\n[cpp98 cpp11 ] [<locale>]
collate_byname()Param: ()\t\nDesc: Facet to compare and hash strings (class template)\t\nProto: template <class charT> class collate_byname;\t\n[cpp98 cpp11] [<locale>]
ctype_base()Param: ()\t\nDesc: Base class for ctype (class)\t\nProto: class ctype_base;\t\n[cpp98 cpp11] [<locale>]
ctype_byname()Param: ()\t\nDesc: Character type facet (class template)\t\nProto: template <class charT> class ctype_byname;\t\n[cpp98 cpp11] [<locale>]
cauchy_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Cauchy distribution (class template)\t\nProto: template <class RealType = double> class cauchy_distribution;\t\n[cpp11 ] [<random>]
chi_squared_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Chi-squared distribution (class template)\t\nProto: template <class RealType = double> class chi_squared_distribution;\t\n[cpp11 ] [<random>]
cmatch()Param: ()\t\nDesc: match_results for string literals (class)\t\nProto: typedef match_results<const char*> cmatch;\t\n[cpp11] [<regex>]
csub_match()Param: ()\t\nDesc: sub_match for string literals (class)\t\nProto: typedef sub_match<const char*> csub_match;\t\n[cpp11] [<regex>]
char_traits(charT)Param: (Character type.)\t\nDesc: Character traits (class template)\t\nProto: template <class charT> struct char_traits;template <> struct char_traits<char>;template <> struct char_traits<wchar_t>;\t\n[cpp98 cpp11 ] [<string>]
current_exception( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get smart pointer to current exception (function)\t\nProto: exception_ptr current_exception() noexcept;\t\n[cpp11] [<exception>]
conj(const complex<T>& x)Param: (Complex value.)\t\nDesc: Complex conjugate (function template)\t\nProto: template<class T> complex<T> conj (const complex<T>& x);\t\n[cpp98 cpp11] [<complex>]
const_pointer_cast(const shared_ptr<T>& sp)Param: (A shared_pointer.)\t\nDesc: Const cast of shared_ptr (function template)\t\nProto: template <class T, class U>\t\nshared_ptr<T> const_pointer_cast (const shared_ptr<U>& sp) noexcept;\t\n[cpp11] [<memory>]
count(InputIterator first, InputIterator last, const T& val)Param: (Input iterators to the initial and final positions of the sequence of elements.)\t\nDesc: Count appearances of value in range (function template)\t\nProto: template <class InputIterator, class T>\t\ntypename iterator_traits<InputIterator>::difference_type\t\n count (InputIterator first, InputIterator last, const T& val);\t\n[cpp98 cpp11] [<algorithm>]
copy_if(InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Copy certain elements of range (function template)\t\nProto: template <class InputIterator, class OutputIterator, class UnaryPredicate>\t\nOutputIterator copy_if (InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred);\t\n[cpp11] [<algorithm>]
count_if(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions of the sequence of elements.)\t\nDesc: Return number of elements in range satisfying condition (function template)\t\nProto: template <class InputIterator, class UnaryPredicate>\t\ntypename iterator_traits<InputIterator>::difference_type\t\n count_if (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp98 cpp11] [<algorithm>]
copy_n(InputIterator first, Size n, OutputIterator result)Param: (Input iterators to the initial position in a sequence of at least n elements to be copied.)\t\nDesc: Copy elements (function template)\t\nProto: template <class InputIterator, class Size, class OutputIterator>\t\nOutputIterator copy_n (InputIterator first, Size n, OutputIterator result);\t\n[cpp11] [<algorithm>]
call_once(once_flag& flag, Fn&& fn, Args&&... args)Param: (Object used by the function to track the state of invocations.)\t\nDesc: Call function once (public member function)\t\nProto: template <class Fn, class... Args> void call_once (once_flag& flag, Fn&& fn, Args&&... args);\t\n[cpp11] [<mutex>]
cos(double x):double  #Returns the cosine of a radian angle x
cosh(double x):double  #Returns the hyperbolic cosine of x
ctime(const time_t *timer):char *  #Returns a string representing the localtime based on the argument timer
deque(T)Param: (Type of the elements.)\t\nDesc: Double ended queue (class template)\t\nProto: template < class T, class Alloc = allocator<T> > class deque;\t\n[cpp98 cpp11 ] [<deque>]
defer_lock_t()Param: ()\t\nDesc: Type of defer_lock (class)\t\nProto: struct defer_lock_t {};\t\n[cpp11] [<mutex>]
duration_values(Rep)Param: (Count representation type.)\t\nDesc: Duration values (class template)\t\nProto: template <class Rep> class duration_values;\t\n[cpp11 ] [<chrono>]
divides(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Division function object class (class template)\t\nProto: template <class T> struct divides;\t\n[cpp98 cpp11] [<functional>]
default_delete(T)Param: (The type of object to be deleted.)\t\nDesc: Default deleter (class template)\t\nProto: non-specialized\t\ntemplate <class T> class default_delete;array specialization\t\ntemplate <class T> class default_delete<T[]>;\t\n[cpp11 ] [<memory>]
discrete_distribution(IntType)Param: (An integer type.)\t\nDesc: Discrete distribution (class template)\t\nProto: template <class IntType = int> class discrete_distribution;\t\n[cpp11 ] [<random>]
default_random_engine()Param: ()\t\nDesc: Default random engine (class)\t\nProto: no-proto\t\n[cpp11] [<random>]
discard_block_engine(Engine)Param: (A random number engine type.)\t\nDesc: Discard-block random number engine adaptor (class template)\t\nProto: template <class Engine, size_t p, size_t r>\t\nclass discard_block_engine;\t\n[cpp11 ] [<random>]
domain_error()Param: ()\t\nDesc: Domain error exception (class)\t\nProto: class domain_error;\t\n[cpp98 cpp11] [<stdexcept>]
declval( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Declaration value (function template)\t\nProto: template <class T>\t\ntypename add_rvalue_reference<T>::type declval() noexcept;\t\n[cpp11] [<utility>]
declare_no_pointers(char* p, size_t n)Param: (Pointer to the first byte of the range to be declared.)\t\nDesc: Declare memory block as containing no pointers (function)\t\nProto: void declare_no_pointers (char* p, size_t n);\t\n[cpp11] [<memory>]
duration_cast(const duration<Rep,Period>& dtn)Param: (A duration object.)\t\nDesc: Duration cast (function template)\t\nProto: template <class ToDuration, class Rep, class Period>\t\nconstexpr ToDuration duration_cast (const duration<Rep,Period>& dtn);\t\n[cpp11] [<chrono>]
dynamic_pointer_cast(const shared_ptr<T>& sp)Param: (A shared_ptr.)\t\nDesc: Dynamic cast of shared_ptr (function template)\t\nProto: template <class T, class U>\t\nshared_ptr<T> dynamic_pointer_cast (const shared_ptr<U>& sp) noexcept;\t\n[cpp11] [<memory>]
distance(InputIterator first, InputIterator last)Param: (Iterator pointing to the initial element.)\t\nDesc: Return distance between iterators (function template)\t\nProto: template<class InputIterator>\t\ntypename iterator_traits<InputIterator>::difference_type\t\n distance (InputIterator first, InputIterator last);\t\n[cpp98 cpp11] [<iterator>]
dec(ios_base& str)Param: (Stream object whose basefield format flag is affected.)\t\nDesc: Use decimal base (function)\t\nProto: ios_base& dec (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
defaultfloat(ios_base& str)Param: (Stream object whose floatfield format flag is affected.)\t\nDesc: no-Description (other)\t\nProto: ios_base& defaultfloat (ios_base& str);\t\n[cpp11] [<ios>]
declare_reachable(void* p)Param: (A safely-derived pointer, or a null pointer.)\t\nDesc: Declare pointer as reachable (function)\t\nProto: void declare_reachable (void* p);\t\n[cpp11] [<memory>]
equal_range(first, last)Param: (Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.)\t\nDesc: Get subrange of equal elements (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
equal_to(T)Param: (Type of the arguments to compare by the functional call.)\t\nDesc: Function object class for equality comparison (class template)\t\nProto: template <class T> struct equal_to;\t\n[cpp98 cpp11] [<functional>]
enable_shared_from_this(T)Param: (Full type of the pointed class (generally the final class inheriting from this).)\t\nDesc: Enable shared_from_this (class template)\t\nProto: template <class T> class enable_shared_from_this;\t\n[cpp11 ] [<memory>]
exponential_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Exponential distribution (class template)\t\nProto: template <class RealType = double> class exponential_distribution;\t\n[cpp11 ] [<random>]
extreme_value_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Extreme Value distribution (class template)\t\nProto: template <class RealType = double> class extreme_value_distribution;\t\n[cpp11 ] [<random>]
error_category()Param: ()\t\nDesc: Error category (abstract class)\t\nProto: class error_category;\t\n[cpp11 ] [<system_error>]
error_code()Param: ()\t\nDesc: Error code (class)\t\nProto: class error_code;\t\n[cpp11 ] [<system_error>]
error_condition()Param: ()\t\nDesc: Error condition (class)\t\nProto: class error_condition;\t\n[cpp11 ] [<system_error>]
endl(ostream& os)Param: (Output stream object affected.)\t\nDesc: Insert newline and flush (function)\t\nProto: for ostream\t\nostream& endl (ostream& os);basic template\t\ntemplate <class charT, class traits>\t\nbasic_ostream<charT,traits>& endl (basic_ostream<charT,traits>& os);\t\n[arm cpp98 cpp11] [<ostream>]
ends(ostream& os)Param: (Output stream object where character is inserted.)\t\nDesc: Insert null character (function)\t\nProto: for ostream\t\nostream& ends (ostream& os);basic template\t\ntemplate <class charT, class traits>\t\nbasic_ostream<charT,traits>& ends (basic_ostream<charT,traits>& os);\t\n[arm cpp98 cpp11] [<ostream>]
exit(int status):void  #Causes the program to terminate normally
forward_list(T)Param: (Type of the elements.)\t\nDesc: Forward list (class template)\t\nProto: template < class T, class Alloc = allocator<T> > class forward_list;\t\n[cpp11 ] [<forward_list>]
future()Param: ()\t\nDesc: Future (class template)\t\nProto: template <class T> future;template <class R&> future<R&>; \t\n[cpp11 ] [<future>]
future_error()Param: ()\t\nDesc: Future error exception (class)\t\nProto: class future_error : public logic_error;\t\n[cpp11 ] [<future>]
future_errc()Param: ()\t\nDesc: Error conditions for future objects (enum class)\t\nProto: enum class future_errc;\t\n[cpp11 ] [<future>]
future_status()Param: ()\t\nDesc: Return value for timed future operations (enum class)\t\nProto: enum class future_status;\t\n[cpp11] [<future>]
function(T)Param: (A type.)\t\nDesc: Function wrapper (class template)\t\nProto: template <class T> function; \t\n[cpp11 ] [<functional>]
forward_iterator_tag()Param: ()\t\nDesc: Forward iterator category (class)\t\nProto: struct forward_iterator_tag {};\t\n[cpp98 cpp11] [<iterator>]
front_insert_iterator(Container)Param: (A container class with member push_front defined (such as the standard containers deque and list).)\t\nDesc: Front insert iterator (class template)\t\nProto: template <class Container> class front_insert_iterator;\t\n[cpp98 cpp11] [<iterator>]
float_denorm_style()Param: ()\t\nDesc: Enum type for float denormalization style (type)\t\nProto: enum float_denorm_style;\t\n[cpp98 cpp11] [<limits>]
float_round_style()Param: ()\t\nDesc: Enum type for float rounding style (type)\t\nProto: enum float_round_style;\t\n[cpp98 cpp11] [<limits>]
fisher_f_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Fisher F-distribution (class template)\t\nProto: template <class RealType = double> class fisher_f_distribution;\t\n[cpp11 ] [<random>]
future_category( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return future category (function)\t\nProto: const error_category& future_category() noexcept;\t\n[cpp11] [<future>]
front_inserter(Container& x)Param: (Container on which the iterator will insert new elements.)\t\nDesc: Constructs front insert iterator (function template)\t\nProto: template <class Container>\t\nfront_insert_iterator<Container> front_inserter (Container& x);\t\n[cpp98 cpp11] [<iterator>]
find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,   ForwardIterator2 first2, ForwardIterator2 last2)Param: (Forward iterators to the initial and final positions of the searched sequence.)\t\nDesc: Find element from set in range (function template)\t\nProto: template <class ForwardIterator1, class ForwardIterator2>  ForwardIterator1 find_first_of (ForwardIterator1 first1, ForwardIterator1 last1,   ForwardIterator2 first2, ForwardIterator2 last2);\t\n[cpp98 cpp11] [<algorithm>]
find_end(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)Param: (Forward iterators to the initial and final positions of the searched sequence.)\t\nDesc: Find last subsequence in range (function template)\t\nProto: template <class ForwardIterator1, class ForwardIterator2>  ForwardIterator1 find_end (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);\t\n[cpp98 cpp11] [<algorithm>]
for_each(InputIterator first, InputIterator last, Function fn)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Apply function to range (function template)\t\nProto: template <class InputIterator, class Function>  Function for_each (InputIterator first, InputIterator last, Function fn);\t\n[cpp98 cpp11] [<algorithm>]
find_if(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Find element in range (function template)\t\nProto: template <class InputIterator, class UnaryPredicate>\t\n InputIterator find_if (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp98 cpp11] [<algorithm>]
find_if_not(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Find element in range (negative condition) (function template)\t\nProto: template <class InputIterator, class UnaryPredicate>\t\n InputIterator find_if_not (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp11] [<algorithm>]
fixed(ios_base& str)Param: (Stream object whose floatfield format flag is affected.)\t\nDesc: Use fixed floating-point notation (function)\t\nProto: ios_base& fixed (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
fill_n(OutputIterator first, Size n, const T& val)Param: (Output iterators to the initial position in a sequence of at least n elements that support being assigned a value of type T.)\t\nDesc: Fill sequence with value (function template)\t\nProto: template <class OutputIterator, class Size, class T> void fill_n (OutputIterator first, Size n, const T& val);\t\n[cpp98 cpp11] [<algorithm>]
forward_as_tuple(Types&&... args)Param: (List of elements to be forwarded as a tuple object of references.)\t\nDesc: Forward as tuple (function template)\t\nProto: template<class... Types> tuple<Types&&...> forward_as_tuple (Types&&... args) noexcept;\t\n[cpp11] [<tuple>]
greater_equal(T)Param: (Type of the arguments to compare by the functional call.)\t\nDesc: Function object class for greater-than-or-equal-to comparison (class template)\t\nProto: template <class T> struct greater_equal;\t\n[cpp98 cpp11] [<functional>]
gamma_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Gamma distribution (class template)\t\nProto: template <class RealType = double> class gamma_distribution;\t\n[cpp11 ] [<random>]
geometric_distribution(IntType)Param: (An integer type.)\t\nDesc: Geometric distribution (class template)\t\nProto: template <class IntType = int> class geometric_distribution;\t\n[cpp11 ] [<random>]
gslice()Param: ()\t\nDesc: Valarray generalized slice selector (class)\t\nProto: class gslice;\t\n[cpp98 cpp11 ] [<valarray>]
gslice_array()Param: ()\t\nDesc: Valarray gslice selection (class template)\t\nProto: template <class T> gslice_array;\t\n[cpp98 cpp11] [<valarray>]
get_temporary_buffer( ptrdiff_t n )Param: (Number of elements of type T for which temporary memory is requested.)\t\nDesc: Get block of temporary memory (function template)\t\nProto: template <class T> pair <T*,ptrdiff_t> get_temporary_buffer ( ptrdiff_t n );\t\n[cpp98 cpp11] [<memory>]
get_terminate( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get terminate handler function (function)\t\nProto: terminate_handler get_terminate() noexcept;\t\n[cpp11] [<exception>]
get_unexpected( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get unexpected handler function (function)\t\nProto: unexpected_handler get_unexpected() noexcept;\t\n[cpp11] [<exception>]
get_pointer_safety( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get pointer safety (function)\t\nProto: pointer_safety get_pointer_safety() noexcept;\t\n[cpp11] [<memory>]
get_new_handler( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get new handler function (function)\t\nProto: new_handler get_new_handler() noexcept;\t\n[cpp11] [<new>]
generic_category( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return generic category (function)\t\nProto: const error_category& generic_category() noexcept;\t\n[cpp11] [<system_error>]
get_deleter(const shared_ptr<T>& sp)Param: (A shared_ptr object.)\t\nDesc: Get deleter from shared_ptr (function template)\t\nProto: template <class D, class T>\t\nD* get_deleter (const shared_ptr<T>& sp) noexcept;\t\n[cpp11] [<memory>]
generate(ForwardIterator first, ForwardIterator last, Generator gen)Param: (Forward iterators to the initial and final positions in a sequence.)\t\nDesc: Generate values for range with function (function template)\t\nProto: template <class ForwardIterator, class Generator>\t\nvoid generate (ForwardIterator first, ForwardIterator last, Generator gen);\t\n[cpp98 cpp11] [<algorithm>]
get_money(moneyT& mon, bool intl = false)Param: (Object where the monetary value is stored.)\t\nDesc: Get monetary value (function)\t\nProto: template <class moneyT>\t\n/*unspecified*/ get_money (moneyT& mon, bool intl = false);\t\n[cpp11] [<iomanip>]
generate_n(OutputIterator first, Size n, Generator gen)Param: (Output iterators to the initial positions in a sequence of at least n elements that support being assigned a value of the type returned by gen.)\t\nDesc: Generate values for sequence with function (function template)\t\nProto: template <class OutputIterator, class Size, class Generator> void generate_n (OutputIterator first, Size n, Generator gen);\t\n[cpp98 cpp11] [<algorithm>]
get_time(struct tm* tmb, const charT* fmt)Param: (Pointer to an object of type struct tm where the time and date information extracted is stored.)\t\nDesc: Get date and time (function)\t\nProto: template <class charT>\t\n/*unspecified*/ get_time (struct tm* tmb, const charT* fmt);\t\n[cpp11] [<iomanip>]
generate_canonical(URNG& g)Param: (A floating-point type.)\t\nDesc: Generate canonical numbers (function template)\t\nProto: template <class RealType, size_t bits, class URNG>\t\nRealType generate_canonical (URNG& g);\t\n[cpp11] [<random>]
getc(FILE *stream):int  #Gets the next character (an unsigned char) from the specified stream and advances the position indicator for the stream
getenv(const char *name):char *  #Searches for the environment string pointed to by name and returns the associated value to the string
gets(char *str):char *  #Reads a line from stdin and stores it into the string pointed to by str
high_resolution_clock()Param: ()\t\nDesc: High resolution clock (class)\t\nProto: class high_resolution_clock;\t\n[cpp11 ] [<chrono>]
hours()Param: ()\t\nDesc: Duration in hours (class)\t\nProto: typedef duration < /*see rep below*/, ratio<3600,1> > hours;\t\n[cpp11] [<chrono>]
hash()Param: ()\t\nDesc: Default hash function object class (class template)\t\nProto: template <class T> struct hash;\t\n[cpp11] [<functional>]
has_facet(const locale& loc)Param: (locale object.)\t\nDesc: Check if locale has facet (function template)\t\nProto: template <class Facet> bool has_facet (const locale& loc) throw();\t\n[cpp98 cpp11] [<locale>]
hex(ios_base& str)Param: (Stream object whose basefield format flag is affected.)\t\nDesc: Use hexadecimal base (function)\t\nProto: ios_base& hex (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
hexfloat(ios_base& str)Param: (Stream object whose floatfield format flag is affected.)\t\nDesc: no-Description (other)\t\nProto: ios_base& hexfloat (ios_base& str);\t\n[cpp11] [<ios>]
ios_base()Param: ()\t\nDesc: Base class for streams (class)\t\nProto: class ios_base;\t\n[arm cpp98 cpp11 ] [<ios>]
io_errc()Param: ()\t\nDesc: Input/output error conditions (enum class)\t\nProto: enum class io_errc;\t\n[cpp11 ] [<ios>]
includes(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence (which is tested on whether it contains the second sequence).)\t\nDesc: Test whether sorted range includes another sorted range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
inplace_merge(first)Param: (Bidirectional iterator to the initial position in the first sorted sequence to merge.)\t\nDesc: Merge consecutive sorted ranges (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
is_heap(first, last)Param: (RandomAccess iterators to the initial and final positions of the sequence.)\t\nDesc: Test if range is heap (function template)\t\nProto: long-proto\t\n[cpp11] [<algorithm>]
is_heap_until(first, last)Param: (Random-access iterators to the initial and final positions in a sequence.)\t\nDesc: Find first element not in heap order (function template)\t\nProto: long-proto\t\n[cpp11] [<algorithm>]
is_permutation(first1, last1)Param: (Input iterators to the initial and final positions of the first sequence.)\t\nDesc: Test whether range is permutation of another (function template)\t\nProto: long-proto\t\n[cpp11] [<algorithm>]
is_sorted(first, last)Param: (Forward iterators to the initial and final positions of the sequence.)\t\nDesc: Check whether range is sorted (function template)\t\nProto: long-proto\t\n[cpp11] [<algorithm>]
is_sorted_until(first, last)Param: (Forward iterators to the initial and final positions in a sequence.)\t\nDesc: Find first unsorted element in range (function template)\t\nProto: long-proto\t\n[cpp11] [<algorithm>]
is_bind_expression(T)Param: (A type.)\t\nDesc: Is bind expression (class template)\t\nProto: template <class T> struct is_bind_expression;\t\n[cpp11] [<functional>]
is_placeholder(T)Param: (A type.)\t\nDesc: Is placeholder (class template)\t\nProto: template <class T> struct is_placeholder;\t\n[cpp11] [<functional>]
initializer_list(T)Param: (Type of the elements.)\t\nDesc: Initializer list (class template)\t\nProto: template<class T> class initializer_list;\t\n[cpp11 ] [<initializer_list>]
iterator(Category)Param: (Category to which the iterator belongs to.)\t\nDesc: Iterator base class (class template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<iterator>]
iterator_traits()Param: ()\t\nDesc: Iterator traits (class template)\t\nProto: template <class Iterator> class iterator_traits;template <class T> class iterator_traits<T*>;template <class T> class iterator_traits<const T*>;\t\n[cpp98 cpp11] [<iterator>]
input_iterator_tag()Param: ()\t\nDesc: Input iterator category (class)\t\nProto: struct input_iterator_tag {};\t\n[cpp98 cpp11] [<iterator>]
istreambuf_iterator(charT)Param: (Character type.)\t\nDesc: Input stream buffer iterator (class template)\t\nProto: template <class charT, class traits=char_traits<charT> > class istreambuf_iterator;\t\n[cpp98 cpp11] [<iterator>]
istream_iterator(T)Param: (Element type for the iterator: The type of elements extracted from the stream.)\t\nDesc: Istream iterator (class template)\t\nProto: template <class T, class charT=char, class traits=char_traits<charT>, \t\n class Distance = ptrdiff_t>\t\nclass istream_iterator;\t\n[cpp98 cpp11 ] [<iterator>]
inner_product(first1, last1)Param: (Input iterators to the initial and final positions in the first sequence.)\t\nDesc: Compute cumulative inner product of range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<numeric>]
independent_bits_engine(Engine)Param: (A random number engine type.)\t\nDesc: Independent-bits random number engine adaptor (class template)\t\nProto: template <class Engine, size_t w, class UIntType>\t\nclass independent_bits_engine;\t\n[cpp11 ] [<random>]
invalid_argument()Param: ()\t\nDesc: Invalid argument exception (class)\t\nProto: class invalid_argument;\t\n[cpp98 cpp11] [<stdexcept>]
is_error_code_enum(T)Param: (A type.)\t\nDesc: error_code enum flag (class)\t\nProto: template <class T>\t\nstruct is_error_code_enum : public false_type {};\t\n[cpp11] [<system_error>]
is_error_condition_enum(T)Param: (A type.)\t\nDesc: error_condition enum flag (class)\t\nProto: template <class T>\t\nstruct is_error_condition_enum : public false_type {};template<>\t\nstruct is_error_condition_enum<errc> : true_type {};\t\n[cpp11] [<system_error>]
ignore()Param: ()\t\nDesc: Ignore assignment (object)\t\nProto: const ignore;\t\n[cpp11] [<tuple>]
indirect_array()Param: ()\t\nDesc: Valarray indirect selection (class template)\t\nProto: template <class T> indirect_array;\t\n[cpp98 cpp11] [<valarray>]
iostream_category( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return iostream category (function)\t\nProto: const error_category& iostream_category();\t\n[cpp11] [<ios>]
imag(const complex<T>& x)Param: (Complex value.)\t\nDesc: Imaginary part of complex (function template)\t\nProto: template<class T> T imag (const complex<T>& x);\t\n[cpp98 cpp11] [<complex>]
iota(ForwardIterator first, ForwardIterator last, T val)Param: (Forward iterators to the initial and final positions of the sequence to be written.)\t\nDesc: Store increasing sequence (function template)\t\nProto: template <class ForwardIterator, class T>\t\nvoid iota (ForwardIterator first, ForwardIterator last, T val);\t\n[cpp11] [<numeric>]
iter_swap(ForwardIterator1 a, ForwardIterator2 b)Param: (Forward iterators to the objects to swap.)\t\nDesc: Exchange values of objects pointed to by two iterators (function template)\t\nProto: template <class ForwardIterator1, class ForwardIterator2>\t\nvoid iter_swap (ForwardIterator1 a, ForwardIterator2 b);\t\n[cpp98 cpp11] [<algorithm>]
is_partitioned(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions of the sequence.)\t\nDesc: Test whether range is partitioned (function template)\t\nProto: template <class InputIterator, class UnaryPredicate>\t\nbool is_partitioned (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp11] [<algorithm>]
internal(ios_base& str)Param: (Stream object whose adjustfield format flag is affected.)\t\nDesc: Adjust field by inserting characters at an internal position (function)\t\nProto: ios_base& internal (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
knuth_b()Param: ()\t\nDesc: Knuth-B generator (class)\t\nProto: typedef shuffle_order_engine <minstd_rand0,256> knuth_b;\t\n[cpp11] [<random>]
launch()Param: ()\t\nDesc: Launching policy for async (enum class)\t\nProto: enum class launch;\t\n[cpp11] [<future>]
lock_guard(Mutex)Param: (A mutex-like type.)\t\nDesc: Lock guard (class template)\t\nProto: template <class Mutex> class lock_guard;\t\n[cpp11 ] [<mutex>]
lexicographical_compare(first1, last1)Param: (Input iterators to the initial and final positions of the first sequence.)\t\nDesc: Lexicographical less-than comparison (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
lower_bound(first, last)Param: (Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.)\t\nDesc: Return iterator to lower bound (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
less_equal(T)Param: (Type of the arguments to compare by the functional call.)\t\nDesc: Function object class for less-than-or-equal-to comparison (class template)\t\nProto: template <class T> struct less_equal;\t\n[cpp98 cpp11] [<functional>]
logical_and(T)Param: (Type of the arguments passed to the functional call.)\t\nDesc: Logical AND function object class (class template)\t\nProto: template <class T> struct logical_and;\t\n[cpp98 cpp11] [<functional>]
logical_not(T)Param: (Type of the argument passed to the functional call.)\t\nDesc: Logical NOT function object class (class template)\t\nProto: template <class T> struct logical_not;\t\n[cpp98 cpp11] [<functional>]
logical_or(T)Param: (Type of the arguments passed to the functional call.)\t\nDesc: Logical OR function object class (class template)\t\nProto: template <class T> struct logical_or;\t\n[).] [class template]
lognormal_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Lognormal distribution (class template)\t\nProto: template <class RealType = double> class lognormal_distribution;\t\n[cpp11 ] [<random>]
linear_congruential_engine(UIntType)Param: (An unsigned integer type.)\t\nDesc: Linear congruential random number engine (class template)\t\nProto: template <class UIntType, UIntType a, UIntType c, UIntType m>\t\nclass linear_congruential_engine;\t\n[cpp11 ] [<random>]
length_error()Param: ()\t\nDesc: Length error exception (class)\t\nProto: class length_error;\t\n[cpp98 cpp11] [<stdexcept>]
logic_error()Param: ()\t\nDesc: Logic error exception (class)\t\nProto: class logic_error;\t\n[cpp98 cpp11] [<stdexcept>]
left(ios_base& str)Param: (Stream object whose adjustfield format flag is affected.)\t\nDesc: Adjust output to the left (function)\t\nProto: ios_base& left (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
log(double x):double  #Returns the natural logarithm (base-e logarithm) of x
map(Key)Param: (Type of the keys.)\t\nDesc: Map (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [<map>]
multimap(Key)Param: (Type of the keys.)\t\nDesc: Multiple-key map (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [<map>]
multiset(T)Param: (Type of the elements.)\t\nDesc: Multiple-key set (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [<set>]
mutex()Param: ()\t\nDesc: Mutex class (class)\t\nProto: class mutex;\t\n[cpp11 ] [<mutex>]
make_heap(first, last)Param: (Random-access iterators to the initial and final positions of the sequence to be transformed into a heap.)\t\nDesc: Make heap from range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
max_element(first, last)Param: (Input iterators to the initial and final positions of the sequence to compare.)\t\nDesc: Return largest element in range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
minmax_element(first, last)Param: (Input iterators to the initial and final positions of the sequence to compare.)\t\nDesc: Return smallest and largest elements in range (function template)\t\nProto: long-proto\t\n[cpp11] [<algorithm>]
min_element(first, last)Param: (Input iterators to the initial and final positions of the sequence to compare.)\t\nDesc: Return smallest element in range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
mismatch(first1, last1)Param: (Input iterators to the initial and final positions of the first sequence.)\t\nDesc: Return first position where two ranges differ (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
move_backward(first, last)Param: (Bidirectional iterators to the initial and final positions in a sequence to be moved.)\t\nDesc: Move range of elements backward (function template)\t\nProto: long-proto\t\n[cpp11] [<algorithm>]
microseconds()Param: ()\t\nDesc: Duration in microseconds (class)\t\nProto: typedef duration < /* see rep below */, micro > microseconds;\t\n[cpp11] [<chrono>]
milliseconds()Param: ()\t\nDesc: Duration in milliseconds (class)\t\nProto: typedef duration < /* see rep below */, milli > milliseconds;\t\n[cpp11] [<chrono>]
minutes()Param: ()\t\nDesc: Duration in minutes (class)\t\nProto: typedef duration < /*see rep below*/, ratio<60,1> > minutes;\t\n[cpp11] [<chrono>]
minus(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Subtraction function object class (class template)\t\nProto: template <class T> struct minus;\t\n[cpp98 cpp11] [<functional>]
modulus(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Modulus function object class (class template)\t\nProto: template <class T> struct modulus;\t\n[cpp98 cpp11] [<functional>]
multiplies(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Multiplication function object class (class template)\t\nProto: template <class T> struct multiplies;\t\n[cpp98 cpp11] [<functional>]
messages(charT)Param: (Character type.)\t\nDesc: Facet to access message catalogs (class template)\t\nProto: template <class charT> class messages;\t\n[cpp98 cpp11 ] [<locale>]
messages_base()Param: ()\t\nDesc: no-Description (other)\t\nProto: class messages_base;\t\n[cpp98 cpp11] [<locale>]
messages_byname()Param: ()\t\nDesc: Facet to access message catalogs (class template)\t\nProto: template <class charT> class messages_byname;\t\n[cpp98 cpp11] [<locale>]
moneypunct(charT)Param: (Character type.)\t\nDesc: Monetary punctuation facet (class template)\t\nProto: template <class charT, bool International = false> class moneypunct;\t\n[cpp98 cpp11 ] [<locale>]
moneypunct_byname()Param: ()\t\nDesc: Monetary punctuation facet (class template)\t\nProto: template <class charT, bool International = false> class numpunct_byname;\t\n[cpp98 cpp11] [<locale>]
money_base()Param: ()\t\nDesc: Base class for moneypunct (class)\t\nProto: class money_base;\t\n[cpp98 cpp11] [<locale>]
money_get(charT)Param: (Character type: the type of the characters in the sequence to interpret.)\t\nDesc: Facet to parse monetary expressions (class template)\t\nProto: template <class charT, class InputIterator = istreambuf_iterator<charT> >\t\nclass money_get;\t\n[cpp98 cpp11 ] [<locale>]
money_put(charT)Param: (Character type: the type of the characters in the sequence to write.)\t\nDesc: Facet to format monetary expressions (class template)\t\nProto: template <class charT, class OutputIterator = ostreambuf_iterator<charT> > class money_put;\t\n[cpp98 cpp11 ] [<locale>]
mersenne_twister_engine(UIntType)Param: (An unsigned integer type.)\t\nDesc: Mersenne twister random number engine (class template)\t\nProto: template <class UIntType, size_t w, size_t n, size_t m, size_t r,UIntType a, size_t u, UIntType d, size_t s,UIntType b, size_t t,UIntType c, size_t l, UIntType f>\t\nclass mersenne_twister_engine;\t\n[cpp11 ] [<random>]
minstd_rand()Param: ()\t\nDesc: Minimal Standard minstd_rand generator (class)\t\nProto: typedef linear_congruential_engine<uint_fast32_t, 48271, 0, 2147483647> minstd_rand;\t\n[cpp11] [<random>]
minstd_rand0()Param: ()\t\nDesc: Minimal Standard minstd_rand0 generator (class)\t\nProto: typedef linear_congruential_engine<uint_fast32_t, 16807, 0, 2147483647> minstd_rand0;\t\n[cpp11] [<random>]
mt19937()Param: ()\t\nDesc: Mersenne Twister 19937 generator (class)\t\nProto: typedef mersenne_twister_engine<uint_fast32_t,\t\n32,624,397,31,0x9908b0df,11,0xffffffff,7,0x9d2c5680,15,0xefc60000,18,1812433253>\t\nmt19937;\t\n[cpp11] [<random>]
mt19937_64()Param: ()\t\nDesc: Mersene Twister 19937 generator (64 bit) (class)\t\nProto: typedef mersenne_twister_engine<uint_fast64_t,\t\n64,312,156,31,0xb5026f5aa96619e9,\t\n29,0x5555555555555555,\t\n17,0x71d67fffeda60000,\t\n37,0xfff7eee000000000,\t\n43,6364136223846793005> mt19937_64;\t\n[cpp11] [<random>]
match_results(BidirectionalIterator)Param: (A bidirectional iterator type that iterates on the target sequence of characters.)\t\nDesc: Match results (class template)\t\nProto: template < class BidirectionalIterator, class Alloc = allocator< sub_match<BidirectionalIterator> > > class match_results;\t\n[cpp11 ] [<regex>]
mask_array()Param: ()\t\nDesc: Valarray mask selection (class template)\t\nProto: template <class T> mask_array;\t\n[cpp98 cpp11] [<valarray>]
make_shared(Args&&... args)Param: (List of elements passed to T's constructor.)\t\nDesc: Make shared_ptr (function template)\t\nProto: template <class T, class... Args>\t\nshared_ptr<T> make_shared (Args&&... args);\t\n[cpp11] [<memory>]
make_move_iterator(const Iterator& it)Param: (An iterator.)\t\nDesc: Construct move iterator (function template)\t\nProto: template <class Iterator> move_iterator<Iterator> make_move_iterator (const Iterator& it);\t\n[cpp11] [<iterator>]
minmax(const T& a, const T& b)Param: (Values to compare.)\t\nDesc: Return smallest and largest elements (function template)\t\nProto: template <class T> pair <const T&,const T&> minmax (const T& a, const T& b);\t\n[cpp11] [<algorithm>]
make_exception_ptr(E e)Param: (An object or reference.)\t\nDesc: Make exception_ptr (function template)\t\nProto: template <class E>\t\nexception_ptr make_exception_ptr (E e) noexcept;\t\n[cpp11] [<exception>]
make_error_code(errc e)Param: (An enum value of type errc (see errc).)\t\nDesc: Make error code (function)\t\nProto: error_code make_error_code (errc e) noexcept;\t\n[cpp11] [<system_error>]
make_error_condition(errc e)Param: (An enum value of type errc (see errc).)\t\nDesc: Make error condition (function)\t\nProto: error_condition make_error_condition (errc e) noexcept;\t\n[cpp11] [<system_error>]
mem_fn(Ret T::* pm)Param: (Pointer to a member function.)\t\nDesc: Convert member function to function object (function template)\t\nProto: template <class Ret, class T>\t\n/* unspecified */ mem_fn (Ret T::* pm);\t\n[cpp11] [<functional>]
move_if_noexcept(T& arg)Param: (An object.)\t\nDesc: Move if noexcept (function template)\t\nProto: !is_copy_constructible<T>::value,T&&, const T& >::type move_if_noexcept(T& arg) noexcept;\t\n[cpp11] [<utility>]
make_pair(T1 x, T2 y)Param: (Values for the members first and second, respectively, of the pair object being constructed.)\t\nDesc: Construct pair object (function template)\t\nProto: template <class T1, class T2> pair<T1,T2> make_pair (T1 x, T2 y);\t\n[cpp98 cpp11] [<utility>]
make_tuple(Types&&... args)Param: (List of elements that the constructed tuple shall contain.)\t\nDesc: Construct tuple (function template)\t\nProto: template<class... Types>\t\ntuple<VTypes...> make_tuple (Types&&... args);\t\n[cpp11] [<tuple>]
next_permutation(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence.)\t\nDesc: Transform range to next permutation (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
nanoseconds()Param: ()\t\nDesc: Duration in nanoseconds (class)\t\nProto: typedef duration < /* see rep below */, nano > nanoseconds;\t\n[cpp11] [<chrono>]
nested_exception()Param: ()\t\nDesc: Nested exception class (class)\t\nProto: class nested_exception;\t\n[cpp11 ] [<exception>]
not_equal_to(T)Param: (Type of the arguments to compare by the functional call.)\t\nDesc: Function object class for non-equality comparison (class template)\t\nProto: template <class T> struct not_equal_to;\t\n[cpp98 cpp11] [<functional>]
numeric_limits(T)Param: (A type.)\t\nDesc: Numeric limits type (class template)\t\nProto: template <class T> numeric_limits;\t\n[cpp98 cpp11] [<limits>]
numpunct(charT)Param: (Character type.)\t\nDesc: Numeric punctuation facet (class template)\t\nProto: template <class charT> class numpunct;\t\n[cpp98 cpp11 ] [<locale>]
numpunct_byname()Param: ()\t\nDesc: Numeric puntuation facet (class template)\t\nProto: template <class charT> class numpunct_byname;\t\n[cpp98 cpp11] [<locale>]
num_get(charT)Param: (Character type: the type of the characters in the sequence to interpret.)\t\nDesc: Facet to parse numeric values (class template)\t\nProto: template <class charT, class InputIterator = istreambuf_iterator<charT> > class num_get;\t\n[cpp98 cpp11 ] [<locale>]
num_put(charT)Param: (Character type: the type of the characters in the sequence to write.)\t\nDesc: Facet to format numeric values (class template)\t\nProto: template <class charT, class OutputIterator = ostreambuf_iterator<charT> > class num_put;\t\n[cpp98 cpp11 ] [<locale>]
nothrow_t()Param: ()\t\nDesc: Nothrow type (type)\t\nProto: struct nothrow_t {};\t\n[cpp98 cpp11] [<new>]
negative_binomial_distribution(IntType)Param: (An integer type.)\t\nDesc: Negative binomial distribution (class template)\t\nProto: template <class IntType = int> class negative_binomial_distribution;\t\n[cpp11 ] [<random>]
notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lck)Param: (A condition_variable object to notify all at thread exit.)\t\nDesc: Notify all at thread exit (function)\t\nProto: void notify_all_at_thread_exit (condition_variable& cond, unique_lock<mutex> lck);\t\n[cpp11] [<condition_variable>]
not1(const Predicate& pred)Param: (Unary function object of a class type with member argument_type defined.)\t\nDesc: Return negation of unary function object (function template)\t\nProto: template <class Predicate>\t\nunary_negate<Predicate> not1 (const Predicate& pred);\t\n[cpp98 cpp11] [<functional>]
not2(const Predicate& pred)Param: (Binary function object derived from binary_function.)\t\nDesc: Return negation of binary function object (function template)\t\nProto: template <class Predicate>\t\nbinary_negate<Predicate> not2 (const Predicate& pred);\t\n[cpp98 cpp11] [<functional>]
none_of(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Test if no elements fulfill condition (function template)\t\nProto: template <class InputIterator, class UnaryPredicate>\t\nbool none_of (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp11] [<algorithm>]
noboolalpha(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: No alphanumerical bool values (function)\t\nProto: ios_base& noboolalpha (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
noshowbase(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not show numerical base prefixes (function)\t\nProto: ios_base& noshowbase (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
noshowpoint(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not show decimal point (function)\t\nProto: ios_base& noshowpoint (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
noshowpos(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not show positive signs (function)\t\nProto: ios_base& noshowpos (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
noskipws(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not skip whitespaces (function)\t\nProto: ios_base& noskipws (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
nounitbuf(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not force flushes after insertions (function)\t\nProto: ios_base& nounitbuf (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
nouppercase(ios_base& str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not generate upper case letters (function)\t\nProto: ios_base& nouppercase (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
nth_element(RandomAccessIterator first, RandomAccessIterator nth,RandomAccessIterator last)Param: (Random-access iterators to the initial and final positions of the sequence to be used.)\t\nDesc: Sort element in range (function template)\t\nProto: template <class RandomAccessIterator> void nth_element (RandomAccessIterator first, RandomAccessIterator nth,RandomAccessIterator last);\t\n[cpp98 cpp11] [<algorithm>]
once_flag()Param: ()\t\nDesc: Flag argument type for call_once (class)\t\nProto: struct once_flag;\t\n[cpp11] [<mutex>]
output_iterator_tag()Param: ()\t\nDesc: Output iterator category (class)\t\nProto: struct output_iterator_tag {};\t\n[cpp98 cpp11] [<iterator>]
ostreambuf_iterator(charT)Param: (Character type.)\t\nDesc: Output stream buffer iterator (class template)\t\nProto: template <class charT, class traits=char_traits<charT> >\t\nclass ostreambuf_iterator;\t\n[cpp98 cpp11] [<iterator>]
ostream_iterator(T)Param: ()\t\nDesc: Ostream iterator (class template)\t\nProto: template <class T, class charT=char, class traits=char_traits<charT> >\t\nclass ostream_iterator;\t\n[cpp98 cpp11 ] [<iterator>]
owner_less(Ptr)Param: (The type of the managed pointers to be ordered according to owned resource, aliased as member types first_argument_type and second_argument_type.)\t\nDesc: Owner-based less-than operation (class template)\t\nProto: template <class Ptr> struct owner_less;template <class T> struct owner_less<shared_ptr<T>>;template <class T> struct owner_less<weak_ptr<T>>;\t\n[cpp11] [<memory>]
out_of_range()Param: ()\t\nDesc: Out-of-range exception (class)\t\nProto: class out_of_range;\t\n[cpp98 cpp11] [<stdexcept>]
overflow_error()Param: ()\t\nDesc: Overflow error exception (class)\t\nProto: class overflow_error;\t\n[cpp98 cpp11] [<stdexcept>]
oct(ios_base& str)Param: (Stream object whose basefield format flag is affected.)\t\nDesc: Use octal base (function)\t\nProto: ios_base& oct (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
operator new(std::size_t size) throw (std::bad_alloc)Param: (Size in bytes of the requested memory block.)\t\nDesc: Allocate storage space (function)\t\nProto: void* operator new (std::size_t size) throw (std::bad_alloc);\t\n[cpp98 cpp11] [<new>]
operator new[](std::size_t size) throw (std::bad_alloc)Param: (Size in bytes of the requested memory block.)\t\nDesc: Allocate storage space for array (function)\t\nProto: void* operator new[] (std::size_t size) throw (std::bad_alloc);\t\n[cpp98 cpp11] [<new>]
operator delete(void* ptr)Param: (A pointer to the memory block to be released, type-casted to a )\t\nDesc: Deallocate storage space (function)\t\nProto: void operator delete (void* ptr) throw();\t\n[cpp98 cpp11] [<new>]
operator delete[](void* ptr)Param: (A pointer to the memory block to be released, type-casted to a )\t\nDesc: Deallocate storage space of array (function)\t\nProto: void operator delete[] (void* ptr) throw();\t\n[cpp98 cpp11] [<new>]
priority_queue(T)Param: (Type of the elements.)\t\nDesc: Priority queue (class template)\t\nProto: template <class T, class Container = vector<T>, class Compare = less<typename Container::value_type> > class priority_queue;\t\n[cpp98 cpp11 ] [<queue>]
packaged_task()Param: ()\t\nDesc: Packaged task (class template)\t\nProto: template <class T> packaged_task;\t\n[cpp11 ] [<future>]
promise()Param: ()\t\nDesc: Promise (class template)\t\nProto: template <class T> promise;template <class R&> promise<R&>; \t\n[cpp11 ] [<future>]
partial_sort(first, last)Param: (Random-access iterators to the initial and final positions of the sequence to be partially sorted.)\t\nDesc: Partially sort elements in range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
partial_sort_copy(first, last)Param: (Input iterators to the initial and final positions of the sequence to copy from.)\t\nDesc: Copy and partially sort range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
partition_copy(first, last)Param: (Input iterators to the initial and final positions of the range to be copy-partitioned.)\t\nDesc: Partition range into two (function template)\t\nProto: long-proto\t\n[cpp11] [<algorithm>]
pop_heap(first, last)Param: (Random-access iterators to the initial and final positions of the heap to be shrank by one.)\t\nDesc: Pop element from heap range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
prev_permutation(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence.)\t\nDesc: Transform range to previous permutation (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
push_heap(first, last)Param: (Random-access iterators to the initial and final positions of the new heap range, including the pushed element.)\t\nDesc: Push element into heap range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
plus(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Addition function object class (class template)\t\nProto: template <class T> struct plus;\t\n[cpp98 cpp11] [<functional>]
placeholders()Param: ()\t\nDesc: Bind argument placeholders (namespace)\t\nProto: namespace placeholders {\t\nextern /* unspecified */ _1;extern /* unspecified */ _2;extern /* unspecified */ _3;// ...\t\n}\t\n[cpp11] [<functional>]
pointer_to_binary_function()Param: ()\t\nDesc: Generate binary function object class from pointer (class template)\t\nProto: template <class Arg1, class Arg2, class Result> class pointer_to_binary_function;\t\n[cpp98 cpp11] [<functional>]
pointer_to_unary_function()Param: ()\t\nDesc: Generate unary function object class from pointer (class template)\t\nProto: template <class Arg, class Result> class pointer_to_unary_function;\t\n[cpp98 cpp11] [<functional>]
ptr_fun()Param: ()\t\nDesc: Convert function pointer to function object (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<functional>]
pointer_traits(Ptr)Param: (Pointer-like type.)\t\nDesc: Pointer traits (class template)\t\nProto: template <class Ptr> class pointer_traits; // template\t\ntemplate <class T> class pointer_traits<T*>; // template specialization\t\n[cpp11 ] [<memory>]
pointer_safety()Param: ()\t\nDesc: Pointer safety enum (enum class)\t\nProto: enum class pointer_safety { relaxed, preferred, strict };\t\n[cpp11] [<memory>]
partial_sum(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Compute partial sums of range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<numeric>]
piecewise_constant_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Piecewise constant distribution (class template)\t\nProto: template <class RealType = double> class piecewise_constant_distribution;\t\n[cpp11 ] [<random>]
piecewise_linear_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Piecewise linear distribution (class template)\t\nProto: template <class RealType = double> class piecewise_linear_distribution;\t\n[cpp11 ] [<random>]
poisson_distribution(IntType)Param: (An integer type.)\t\nDesc: Poisson distribution (class template)\t\nProto: template <class IntType = int> class poisson_distribution;\t\n[cpp11 ] [<random>]
pair(T1)Param: (Type of member first, aliased as first_type.)\t\nDesc: Pair of values (class template)\t\nProto: template <class T1, class T2> struct pair;\t\n[cpp98 cpp11 ] [<utility>]
piecewise_construct_t()Param: ()\t\nDesc: Piecewise construct type (type)\t\nProto: struct piecewise_construct_t {};\t\n[cpp11] [<utility>]
proj(const complex<T>& x)Param: (Complex value.)\t\nDesc: Complex projection. (function template)\t\nProto: template<class T> complex<T> proj (const complex<T>& x);\t\n[cpp11] [<complex>]
put_money(const moneyT& mon, bool intl = false)Param: (Monetary value.)\t\nDesc: Put monetary value (function)\t\nProto: template <class moneyT>\t\n/*unspecified*/ put_money (const moneyT& mon, bool intl = false);\t\n[cpp11] [<iomanip>]
put_time(const struct tm* tmb, const charT* fmt)Param: (Pointer to the object of type struct tm with the date and time information to format.)\t\nDesc: Put date and time (function)\t\nProto: template <class charT>\t\n/*unspecified*/ put_time (const struct tm* tmb, const charT* fmt);\t\n[cpp11] [<iomanip>]
polar(const T& rho, const T& theta = 0)Param: (Magnitude (modulus) of the complex number.)\t\nDesc: Complex from polar components (function template)\t\nProto: template<class T> complex<T> polar (const T& rho, const T& theta = 0);\t\n[cpp98 cpp11] [<complex>]
partition_point(ForwardIterator first, ForwardIterator last,  UnaryPredicate pred)Param: (Forward iterators to the initial and final positions of the partitioned sequence.)\t\nDesc: Get partition point (function template)\t\nProto: template <class ForwardIterator, class UnaryPredicate>\t\nForwardIterator partition_point (ForwardIterator first, ForwardIterator last,  UnaryPredicate pred);\t\n[cpp11] [<algorithm>]
printf(const char *format, ...):int  #Sends formatted output to stdout
putc(int char, FILE *stream):int  #Writes an unsigned char specified by the argument char to the specified stream and advances the position indicator for the stream
puts(const char *str):int  #Writes a string to stdout up to but not including the null character
recursive_mutex()Param: ()\t\nDesc: Recursive mutex class (class)\t\nProto: class recursive_mutex;\t\n[cpp11 ] [<mutex>]
recursive_timed_mutex()Param: ()\t\nDesc: Recursive timed mutex (class)\t\nProto: class recursive_timed_mutex;\t\n[cpp11 ] [<mutex>]
replace_copy(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Copy range replacing value (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
replace_copy_if(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Copy range replacing value (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
reference_wrapper(T)Param: (Type of the referred element.)\t\nDesc: Reference wrapper (class template)\t\nProto: template <class T> class reference_wrapper;\t\n[cpp11 ] [<functional>]
random_access_iterator_tag()Param: ()\t\nDesc: Random-access iterator category (class)\t\nProto: struct random_access_iterator_tag {};\t\n[cpp98 cpp11] [<iterator>]
reverse_iterator(Iterator)Param: (A bidirectional iterator type.)\t\nDesc: Reverse iterator (class template)\t\nProto: template <class Iterator> class reverse_iterator;\t\n[cpp98 cpp11 ] [<iterator>]
raw_storage_iterator(OutputIterator)Param: (Underlying iterator type.)\t\nDesc: Raw storage iterator (class template)\t\nProto: template <class OutputIterator, class T>\t\nclass raw_storage_iterator;\t\n[cpp98 cpp11] [<memory>]
random_device()Param: ()\t\nDesc: True random number generator (class)\t\nProto: class random_device;\t\n[cpp11 ] [<random>]
ranlux24()Param: ()\t\nDesc: Ranlux 24 generator (class)\t\nProto: typedef discard_block_engine <ranlux24_base, 223, 23> ranlux24;\t\n[cpp11] [<random>]
ranlux24_base()Param: ()\t\nDesc: Ranlux 24 base generator (class)\t\nProto: typedef subtract_with_carry_engine <uint_fast32_t, 24, 10, 24> ranlux24_base;\t\n[cpp11] [<random>]
ranlux48()Param: ()\t\nDesc: Ranlux 48 generator (class)\t\nProto: typedef discard_block_engine <ranlux48_base, 389, 11> ranlux48;\t\n[cpp11] [<random>]
ranlux48_base()Param: ()\t\nDesc: Ranlux 48 base generator (class)\t\nProto: typedef subtract_with_carry_engine <uint_fast64_t, 48, 5, 12> ranlux48_base;\t\n[cpp11] [<random>]
ratio_add(R1,R2)Param: (ratio types to be added.)\t\nDesc: Add two ratios (class template)\t\nProto: template <class R1, class R2> ratio_add;\t\n[cpp11] [<ratio>]
ratio_divide(R1,R2)Param: (ratio types to be divided.)\t\nDesc: Divide ratios (class template)\t\nProto: template <class R1, class R2> ratio_divide;\t\n[cpp11] [<ratio>]
ratio_equal(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios (class template)\t\nProto: template <class R1, class R2> ratio_equal;\t\n[cpp11] [<ratio>]
ratio_greater(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for greater than inequality (class template)\t\nProto: template <class R1, class R2> ratio_greater;\t\n[cpp11] [<ratio>]
ratio_greater_equal(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for equality or greater-than inequality (class template)\t\nProto: template <class R1, class R2> ratio_greater_equal;\t\n[cpp11] [<ratio>]
ratio_less(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for less-than inequality (class template)\t\nProto: template <class R1, class R2> ratio_less;\t\n[cpp11] [<ratio>]
ratio_less_equal(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for equality or less-than inequality (class template)\t\nProto: template <class R1, class R2> ratio_less_equal;\t\n[cpp11] [<ratio>]
ratio_multiply(R1,R2)Param: (ratio types to be multiplied.)\t\nDesc: Multiply two ratios (class template)\t\nProto: template <class R1, class R2> ratio_multiply;\t\n[cpp11] [<ratio>]
ratio_not_equal(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for inequality (class template)\t\nProto: template <class R1, class R2> ratio_not_equal;\t\n[cpp11] [<ratio>]
ratio_subtract(R1,R2)Param: (ratio types to be subtracted.)\t\nDesc: Subtract ratios (class template)\t\nProto: template <class R1, class R2> ratio_subtract;\t\n[cpp11] [<ratio>]
regex_constants()Param: ()\t\nDesc: regex constants (namespace)\t\nProto: no-proto\t\n[cpp11] [<regex>]
regex_error()Param: ()\t\nDesc: Regex exception (class)\t\nProto: class regex_error : public runtime_error { /* ... */ };\t\n[cpp11 ] [<regex>]
regex_iterator(BidirectionalIterator)Param: (A bidirectional iterator type that iterates on the target sequence of characters.)\t\nDesc: Regex iterator (class template)\t\nProto: template <class BidirectionalIterator,class charT=typename iterator_traits<BidirectionalIterator>::value_type,class traits=regex_traits<charT> > class regex_iterator;\t\n[cpp11 ] [<regex>]
regex_token_iterator(BidirectionalIterator)Param: (A bidirectional iterator type that iterates on the target sequence of characters.)\t\nDesc: Regex token iterator (class template)\t\nProto: template <class BidirectionalIterator,class charT=typename iterator_traits<BidirectionalIterator>::value_type,class traits=regex_traits<charT> > class regex_token_iterator;\t\n[cpp11 ] [<regex>]
regex_traits(charT)Param: (The character type.)\t\nDesc: Regex traits (class template)\t\nProto: template <class charT> class regex_traits;\t\n[cpp11 ] [<regex>]
regex_replace(s)Param: (A string with the target sequence (the subject).)\t\nDesc: Replace matched sequence (function template)\t\nProto: long-proto\t\n[cpp11] [<regex>]
range_error()Param: ()\t\nDesc: Range error exception (class)\t\nProto: class range_error;\t\n[cpp98 cpp11] [<stdexcept>]
runtime_error()Param: ()\t\nDesc: Runtime error exception (class)\t\nProto: class runtime_error;\t\n[cpp98 cpp11] [<stdexcept>]
rel_ops(T)Param: (For operator!=, the type shall be EqualityComparable.)\t\nDesc: Relational Operators (namespace)\t\nProto: long-proto\t\n[cpp98 cpp11] [<utility>]
reverse_copy(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence to be copied.)\t\nDesc: Copy range reversed (function template)\t\nProto: template <class BidirectionalIterator, class OutputIterator>\t\nOutputIterator reverse_copy (BidirectionalIterator first,   BidirectionalIterator last, OutputIterator result);\t\n[cpp98 cpp11] [<algorithm>]
reverse(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence to be reversed.)\t\nDesc: Reverse range (function template)\t\nProto: template <class BidirectionalIterator>\t\nvoid reverse (BidirectionalIterator first, BidirectionalIterator last);\t\n[cpp98 cpp11] [<algorithm>]
regex_match(s)Param: (A string with the target sequence (the subject) against which the regex expression is matched.)\t\nDesc: Match sequence (function template)\t\nProto: template <class charT, class traits> bool regex_match (const charT* s, const basic_regex<charT,traits>& rgx, regex_constants::match_flag_type flags = regex_constants::match_default);\t\n[cpp11] [<regex>]
regex_search(s)Param: (A string with the target sequence (the subject) to be searched for a match of the regex expression.)\t\nDesc: Search sequence (function template)\t\nProto: template <class charT, class traits> bool regex_search (const charT* s, const basic_regex<charT,traits>& rgx, regex_constants::match_flag_type flags = regex_constants::match_default);\t\n[cpp11] [<regex>]
rethrow_if_nested(const T& e)Param: (An object or reference.)\t\nDesc: Rethrow if nested (function)\t\nProto: template <class T>\t\nvoid rethrow_if_nested (const T& e);\t\n[cpp11] [<exception>]
rethrow_exception(exception_ptr p)Param: (An exception_ptr object pointing to an exception object.)\t\nDesc: Rethrow exception (function)\t\nProto: [[noreturn]] void rethrow_exception (exception_ptr p);\t\n[cpp11] [<exception>]
replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value)Param: (Forward iterators to the initial and final positions in a sequence of elements that support being compared and assigned a value of type T.)\t\nDesc: Replace value in range (function template)\t\nProto: template <class ForwardIterator, class T>\t\nvoid replace (ForwardIterator first, ForwardIterator last,   const T& old_value, const T& new_value);\t\n[cpp98 cpp11] [<algorithm>]
replace_if(ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T& new_value )Param: (Forward iterators to the initial and final positions in a sequence of elements that support being assigned a value of type T.)\t\nDesc: Replace values in range (function template)\t\nProto: template <class ForwardIterator, class UnaryPredicate, class T>\t\nvoid replace_if (ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T& new_value );\t\n[cpp98 cpp11] [<algorithm>]
remove_if(ForwardIterator first, ForwardIterator last,UnaryPredicate pred)Param: (Forward iterators to the initial and final positions in a sequence of move-assignable elements.)\t\nDesc: Remove elements from range (function template)\t\nProto: template <class ForwardIterator, class UnaryPredicate> ForwardIterator remove_if (ForwardIterator first, ForwardIterator last,UnaryPredicate pred);\t\n[cpp98 cpp11] [<algorithm>]
rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last)Param: (Forward iterators to the initial and final positions of the sequence to be rotated left.)\t\nDesc: Rotate left the elements in range (function template)\t\nProto: template <class ForwardIterator> void rotate (ForwardIterator first, ForwardIterator middle, ForwardIterator last);\t\n[cpp98 cpp11] [<algorithm>]
rotate_copy(ForwardIterator first, ForwardIterator middle,ForwardIterator last, OutputIterator result)Param: (Forward iterators to the initial and final positions of the range to be copy-rotated.)\t\nDesc: Copy range rotated left (function template)\t\nProto: template <class ForwardIterator, class OutputIterator>\t\nOutputIterator rotate_copy (ForwardIterator first, ForwardIterator middle,ForwardIterator last, OutputIterator result);\t\n[cpp98 cpp11] [<algorithm>]
remove_copy(InputIterator first, InputIterator last,   OutputIterator result, const T& val)Param: (Forward iterators to the initial and final positions in a sequence of elements supporting being compared to a value of type T.)\t\nDesc: Copy range removing value (function template)\t\nProto: template <class InputIterator, class OutputIterator, class T>\t\nOutputIterator remove_copy (InputIterator first, InputIterator last,   OutputIterator result, const T& val);\t\n[cpp98 cpp11] [<algorithm>]
remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred)Param: (Forward iterators to the initial and final positions in a sequence.)\t\nDesc: Copy range removing values (function template)\t\nProto: template <class InputIterator, class OutputIterator, class UnaryPredicate>\t\nOutputIterator remove_copy_if (InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred);\t\n[cpp98 cpp11] [<algorithm>]
right(ios_base& str)Param: (Stream object whose adjustfield format flag is affected.)\t\nDesc: Adjust output to the right (function)\t\nProto: ios_base& right (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
resetiosflags(ios_base::fmtflags mask)Param: (Mask representing the flags to be reset.)\t\nDesc: Reset format flags (function)\t\nProto: /*unspecified*/ resetiosflags (ios_base::fmtflags mask);\t\n[arm cpp98 cpp11] [<iomanip>]
random_shuffle(RandomAccessIterator first, RandomAccessIterator last)Param: (Random-access iterators to the initial and final positions of the sequence to be shuffled.)\t\nDesc: Randomly rearrange elements in range (function template)\t\nProto: template <class RandomAccessIterator> void random_shuffle (RandomAccessIterator first, RandomAccessIterator last);\t\n[cpp98 cpp11] [<algorithm>]
return_temporary_buffer(T* p)Param: (Pointer to a block of temporary memory returned by a previous call to get_temporary_buffer.)\t\nDesc: Return block of temporary memory (function template)\t\nProto: template <class T> void return_temporary_buffer (T* p);\t\n[cpp98 cpp11] [<memory>]
raise(int sig):int  #Causes signal sig to be generated
return(ret): #Returns some useful Data
stack(T)Param: (Type of the elements.)\t\nDesc: LIFO stack (class template)\t\nProto: template <class T, class Container = deque<T> > class stack;\t\n[cpp98 cpp11 ] [<stack>]
streamoff()Param: ()\t\nDesc: Stream offset type (type)\t\nProto: no-proto\t\n[arm cpp98 cpp11] [<ios>]
streampos()Param: ()\t\nDesc: Stream position type (type)\t\nProto: typedef fpos<mbstate_t> streampos;\t\n[arm cpp98 cpp11] [<ios>]
streamsize()Param: ()\t\nDesc: Stream size type (type)\t\nProto: no-proto\t\n[arm cpp98 cpp11] [<ios>]
shared_future()Param: ()\t\nDesc: Shared future (class template)\t\nProto: template <class T> shared_future;template <class R&> shared_future<R&>; \t\n[cpp11 ] [<future>]
search_n(first, last)Param: (Forward iterators to the initial and final positions of the searched sequence.)\t\nDesc: Search range for elements (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
set_difference(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence.)\t\nDesc: Difference of two sorted ranges (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
set_intersection(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence.)\t\nDesc: Intersection of two sorted ranges (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
set_symmetric_difference(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence.)\t\nDesc: Symmetric difference of two sorted ranges (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
set_union(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence.)\t\nDesc: Union of two sorted ranges (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
sort_heap(first, last)Param: (Random-access iterators to the initial and final positions of the heap range to be sorted.)\t\nDesc: Sort elements of heap (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
stable_partition(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence to partition.)\t\nDesc: Partition range in two - stable ordering (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
stable_sort(first, last)Param: (Random-access iterators to the initial and final positions of the sequence to be sorted.)\t\nDesc: Sort elements preserving order of equivalents (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
steady_clock()Param: ()\t\nDesc: Steady clock (class)\t\nProto: class steady_clock;\t\n[cpp11 ] [<chrono>]
system_clock()Param: ()\t\nDesc: System clock (class)\t\nProto: class system_clock;\t\n[cpp11 ] [<chrono>]
shared_ptr(T)Param: (The type of the managed object, aliased as member type element_type.)\t\nDesc: Shared pointer (class template)\t\nProto: template <class T> class shared_ptr;\t\n[cpp11 ] [<memory>]
student_t_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Student T-Distribution (class template)\t\nProto: template <class RealType = double> class student_t_distribution;\t\n[cpp11 ] [<random>]
shuffle_order_engine(Engine)Param: (A random number engine type.)\t\nDesc: Shuffle-order random number engine adaptor (class template)\t\nProto: template <class Engine, size_t k> class shuffle_order_engine;\t\n[cpp11 ] [<random>]
subtract_with_carry_engine(UIntType)Param: (An unsigned integer type.)\t\nDesc: Subtract-with-carry random number engine (class template)\t\nProto: template <class UIntType, size_t w, size_t s, size_t r>\t\nclass subtract_with_carry_engine;\t\n[cpp11 ] [<random>]
seed_seq()Param: ()\t\nDesc: Seed sequence (class)\t\nProto: class seed_seq;\t\n[cpp11 ] [<random>]
sub_match(BidirectionalIterator)Param: (A bidirectional iterator type that iterates on a sequence of characters.)\t\nDesc: Sub-expression match (class template)\t\nProto: template <class BidirectionalIterator>\t\nclass sub_match : public pair <BidirectionalIterator, BidirectionalIterator>;\t\n[cpp11 ] [<regex>]
ssub_match()Param: ()\t\nDesc: sub_match for strings (class)\t\nProto: typedef sub_match<string::const_iterator> ssub_match;\t\n[cpp11] [<regex>]
system_error()Param: ()\t\nDesc: System error exception (class)\t\nProto: class system_error : public runtime_error;\t\n[cpp11 ] [<system_error>]
system_category( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return system category (function)\t\nProto: const error_category& system_category() noexcept;\t\n[cpp11] [<system_error>]
setfill(char_type c)Param: (The new fill character for the stream.)\t\nDesc: Set fill character (function)\t\nProto: /*unspecified*/ setfill (char_type c);\t\n[arm cpp98 cpp11] [<iomanip>]
static_pointer_cast(const shared_ptr<T>& sp)Param: (A shared_pointer.)\t\nDesc: Static cast of shared_ptr (function template)\t\nProto: template <class T, class U>\t\nshared_ptr<T> static_pointer_cast (const shared_ptr<U>& sp) noexcept;\t\n[cpp11] [<memory>]
stoi(const string& str, size_t* idx = 0, int base = 10)Param: (String object with the representation of an integral number.)\t\nDesc: Convert string to integer (function template)\t\nProto: int stoi (const string& str, size_t* idx = 0, int base = 10);int stoi (const wstring& str, size_t* idx = 0, int base = 10);\t\n[cpp11] [<string>]
swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,ForwardIterator2 first2)Param: (Forward iterators to the initial and final positions in one of the sequences to be swapped.)\t\nDesc: Exchange values of two ranges (function template)\t\nProto: template <class ForwardIterator1, class ForwardIterator2>\t\nForwardIterator2 swap_ranges (ForwardIterator1 first1, ForwardIterator1 last1,ForwardIterator2 first2);\t\n[cpp98 cpp11] [<algorithm>]
setbase(int base)Param: (Numerical radix to be used:\t\n\t\nbase argument\t\n\t\nsame as inserting.)\t\nDesc: Set basefield flag (function)\t\nProto: /*unspecified*/ setbase (int base);\t\n[arm cpp98 cpp11] [<iomanip>]
setprecision(int n)Param: (New value for the decimal precision.)\t\nDesc: Set decimal precision (function)\t\nProto: /*unspecified*/ setprecision (int n);\t\n[arm cpp98 cpp11] [<iomanip>]
setw(int n)Param: (Number of characters to be used as field width.)\t\nDesc: Set field width (function)\t\nProto: /*undefined*/ setw (int n);\t\n[arm cpp98 cpp11] [<iomanip>]
scientific(ios_base& str)Param: (Stream object whose floatfield format flag is affected.)\t\nDesc: Use scientific floating-point notation (function)\t\nProto: ios_base& scientific (ios_base& str);\t\n[arm cpp98 cpp11] [<ios>]
set_new_handler(new_handler new_p) throw()Param: (Function that takes no arguments and returns no value ()\t\nDesc: Set new handler function (function)\t\nProto: new_handler set_new_handler (new_handler new_p) throw();\t\n[cpp98 cpp11] [<new>]
set_terminate(terminate_handler f)Param: (Function that takes no parameters and returns no value ()\t\nDesc: Set terminate handler function (function)\t\nProto: terminate_handler set_terminate (terminate_handler f) throw();\t\n[cpp98 cpp11] [<exception>]
set_unexpected(unexpected_handler f)Param: (Function that takes no parameters and returns no value ()\t\nDesc: Set unexpected handler function (function)\t\nProto: unexpected_handler set_unexpected (unexpected_handler f) throw();\t\n[cpp98 cpp11] [<exception>]
scanf(const char *format, ...):int  #Read formatted input
sin(double x):double  #Returns the sine of a radian angle x
sinh(double x):double  #Returns the hyperbolic sine of x
try_to_lock_t()Param: ()\t\nDesc: Type of try_to_lock (class)\t\nProto: struct try_to_lock_t {};\t\n[cpp11] [<mutex>]
this_thread()Param: ()\t\nDesc: This thread (namespace)\t\nProto: no-proto\t\n[cpp11 ] [<thread>]
transform(first1, last1)Param: (Input iterators to the initial and final positions of the first sequence.)\t\nDesc: Transform range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
treat_as_floating_point(Rep)Param: (Count representation type.)\t\nDesc: Treat as floating point (class template)\t\nProto: template <class Rep> struct treat_as_floating_point : is_floating_point<Rep> {};\t\n[cpp11] [<chrono>]
time_base()Param: ()\t\nDesc: Base class for time_get (class)\t\nProto: class time_base;\t\n[cpp98 cpp11] [<locale>]
time_get(charT)Param: (Character type: the type of the characters in the sequence to interpret.)\t\nDesc: Facet to parse dates and times (class template)\t\nProto: template <class charT, class InputIterator = istreambuf_iterator<charT> >\t\nclass time_get;\t\n[cpp98 cpp11 ] [<locale>]
time_get_byname()Param: ()\t\nDesc: Facet to parse dates and times (class template)\t\nProto: template <class charT, class InputIterator = istreambuf_iterator<charT> > class time_get_byname;\t\n[cpp98 cpp11] [<locale>]
time_put(charT)Param: (Character type: the type of the characters in the sequence to write.)\t\nDesc: Facet to format dates and times (class template)\t\nProto: template <class charT, class OutputIterator = ostreambuf_iterator<charT> >\t\nclass time_put;\t\n[cpp98 cpp11 ] [<locale>]
time_put_byname()Param: ()\t\nDesc: Facet to format dates and times (class template)\t\nProto: template <class charT, class OutputIterator = ostreambuf_iterator<charT> > class time_put_byname;\t\n[cpp98 cpp11] [<locale>]
to_string(val)Param: (Numerical value.)\t\nDesc: Convert numerical value to string (function)\t\nProto: long-proto\t\n[cpp11] [<string>]
to_wstring(val)Param: (Numerical value.)\t\nDesc: Convert numerical value to wide string (function)\t\nProto: long-proto\t\n[cpp11] [<string>]
tuple(Types...)Param: (A list of types used for the elements, in the same order as they are going to be ordered in the tuple.)\t\nDesc: Tuple (class template)\t\nProto: template <class... Types> class tuple;\t\n[cpp11 ] [<tuple>]
tuple_element(I)Param: (Order number of the element within the tuple (zero-based).)\t\nDesc: Tuple element type (class template)\t\nProto: long-proto\t\n[cpp11] [<tuple>]
tuple_size(T)Param: (Type for which the tuple size is obtained.)\t\nDesc: Tuple size traits (class template)\t\nProto: long-proto\t\n[cpp11] [<tuple>]
type_index()Param: ()\t\nDesc: Type index (class)\t\nProto: class type_index;\t\n[cpp11 ] [<typeindex>]
type_info()Param: ()\t\nDesc: Type information type (class)\t\nProto: class type_info;\t\n[cpp98 cpp11 ] [<typeinfo>]
terminate_handler( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Type of terminate handler function (type)\t\nProto: typedef void (*terminate_handler)();\t\n[cpp98 cpp11] [<exception>]
time_point_cast(const time_point<Clock,Duration>& tp)Param: (A time_point object.)\t\nDesc: Time_point cast (function template)\t\nProto: template <class ToDuration, class Clock, class Duration>\t\ntime_point<Clock,ToDuration> time_point_cast (const time_point<Clock,Duration>& tp);\t\n[cpp11] [<chrono>]
try_lock(Mutex1& a, Mutex2& b, Mutexes&... cde)Param: (Objects to try-lock.)\t\nDesc: Try to lock multiple mutexes (function template)\t\nProto: template <class Mutex1, class Mutex2, class... Mutexes>\t\nint try_lock (Mutex1& a, Mutex2& b, Mutexes&... cde);\t\n[cpp11] [<mutex>]
throw_with_nested(T&& e)Param: (An object or reference of a non-union class not derived from nested_exception.)\t\nDesc: Throw with nested (function)\t\nProto: [[noreturn]] template <class T>\t\nvoid throw_with_nested (T&& e);\t\n[cpp11] [<exception>]
tuple_cat(Tuples&&... tpls)Param: (Comma-separated list of tuple objects.)\t\nDesc: Concatenate tuples (function template)\t\nProto: template <class... Tuples>\t\ntuple<CTypes...> tuple_cat (Tuples&&... tpls);\t\n[cpp11] [<tuple>]
tie(Types&... args)Param: (List of objects (lvalues) to be tied as elements of a tuple.)\t\nDesc: Tie arguments to tuple elements (function template)\t\nProto: template<class... Types> tuple<Types&...> tie (Types&... args) noexcept;\t\n[cpp11] [<tuple>]
tan(double x):double  #Returns the tangent of a radian angle x
tanh(double x):double  #Returns the hyperbolic tangent of x
time(time_t *timer):time_t  #Calculates the current calender time and encodes it into time_t format
unordered_map(Key)Param: (Type of the key values.)\t\nDesc: Unordered Map (class template)\t\nProto: long-proto\t\n[cpp11 ] [<unordered_map>]
unordered_multimap(Key)Param: (Type of the key values.)\t\nDesc: Unordered Multimap (class template)\t\nProto: long-proto\t\n[cpp11 ] [<unordered_map>]
unordered_multiset(Key)Param: (Type of the elements.)\t\nDesc: Unordered Multiset (class template)\t\nProto: long-proto\t\n[cpp11 ] [<unordered_set>]
unordered_set(Key)Param: (Type of the elements.)\t\nDesc: Unordered Set (class template)\t\nProto: long-proto\t\n[cpp11 ] [<unordered_set>]
unique_lock(Mutex)Param: (A mutex-like type.)\t\nDesc: Unique lock (class template)\t\nProto: template <class Mutex> class unique_lock;\t\n[cpp11 ] [<mutex>]
unique_copy(first, last)Param: (Forward iterators to the initial and final positions in a sequence.)\t\nDesc: Copy range removing duplicates (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
upper_bound(first, last)Param: (Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.)\t\nDesc: Return iterator to upper bound (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [<algorithm>]
unary_negate(Predicate)Param: (A unary function object class, with member argument_type defined.)\t\nDesc: Negate unary function object class (class template)\t\nProto: template <class Predicate> class unary_negate;\t\n[cpp98 cpp11] [<functional>]
unique_ptr(T)Param: (The type of the managed object, aliased as member type element_type.)\t\nDesc: Unique pointer (class template)\t\nProto: non-specialized\t\ntemplate <class T, class D = default_delete<T>> class unique_ptr;array specialization\t\ntemplate <class T, class D> class unique_ptr<T[],D>;\t\n[cpp11 ] [<memory>]
uses_allocator(T)Param: (A type.)\t\nDesc: no-Description (other)\t\nProto: template <class T, class Alloc> struct uses_allocator;\t\n[cpp11] [<memory>]
uniform_int_distribution(IntType)Param: (An integer type.)\t\nDesc: Uniform discrete distribution (class template)\t\nProto: template <class IntType = int> class uniform_int_distribution;\t\n[cpp11 ] [<random>]
uniform_real_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Uniform real distribution (class template)\t\nProto: template <class RealType = double> class uniform_real_distribution;\t\n[cpp11 ] [<random>]
underflow_error()Param: ()\t\nDesc: Underflow error exception (class)\t\nProto: class underflow_error;\t\n[cpp98 cpp11] [<stdexcept>]
u16string()Param: ()\t\nDesc: String of 16-bit characters (class)\t\nProto: typedef basic_string<char16_t> u16string;\t\n[cpp11] [<string>]
u32string()Param: ()\t\nDesc: String of 32-bit characters (class)\t\nProto: typedef basic_string<char32_t> u32string;\t\n[cpp11] [<string>]
uninitialized_copy( InputIterator first, InputIterator last,    ForwardIterator result )Param: (Input iterators to the initial and final positions in a sequence to be copied.)\t\nDesc: Copy block of memory (function template)\t\nProto: template <class InputIterator, class ForwardIterator>\t\nForwardIterator uninitialized_copy ( InputIterator first, InputIterator last,    ForwardIterator result );\t\n[cpp98 cpp11] [<memory>]
uninitialized_copy_n( InputIterator first, Size n,ForwardIterator result )Param: (Forward iterator to the initial position in an uninitialized sequence of at least n elements.)\t\nDesc: Copy block of memory (function template)\t\nProto: template <class InputIterator, class Size, class ForwardIterator>\t\nForwardIterator uninitialized_copy_n ( InputIterator first, Size n,ForwardIterator result );\t\n[cpp11] [<memory>]
uncaught_exception( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return exception status (function)\t\nProto: bool uncaught_exception() throw();\t\n[cpp98 cpp11] [<exception>]
unexpected_handler( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Type of unexpected handler function (type)\t\nProto: typedef void (*unexpected_handler)();\t\n[cpp98 cpp11] [<exception>]
undeclare_no_pointers(char* p, size_t n)Param: (Pointer to the first byte of the range.)\t\nDesc: Undeclare memory block as containing no pointers (function)\t\nProto: void undeclare_no_pointers (char* p, size_t n);\t\n[cpp11] [<memory>]
use_facet(const locale& loc)Param: (locale object.)\t\nDesc: Access facet of locale (function template)\t\nProto: template <class Facet> const Facet& use_facet (const locale& loc);\t\n[cpp98 cpp11] [<locale>]
uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x)Param: (Forward iterators to the initial and final positions in an uninitialized sequence.)\t\nDesc: Fill block of memory (function template)\t\nProto: template <class ForwardIterator, class T>\t\nvoid uninitialized_fill (ForwardIterator first, ForwardIterator last, const T& x);\t\n[cpp98 cpp11] [<memory>]
uninitialized_fill_n(ForwardIterator first, Size n, const T& x)Param: (Forward iterator to the initial position in an uninitialized sequence of at least n elements.)\t\nDesc: Fill block of memory (function template)\t\nProto: template <class ForwardIterator, class Size, class T> void uninitialized_fill_n (ForwardIterator first, Size n, const T& x);\t\n[cpp98 cpp11] [<memory>]
undeclare_reachable(T* p)Param: (A pointer pointing to an object previously declared as reachable with declare_reachable.)\t\nDesc: Undeclare pointer as reachable (function template)\t\nProto: template <class T> T* undeclare_reachable (T* p);\t\n[cpp11] [<memory>]
vector(T)Param: (Type of the elements.)\t\nDesc: Vector (class template)\t\nProto: template < class T, class Alloc = allocator<T> > class vector;\t\n[cpp98 cpp11 ] [<vector>]
valarray(T)Param: (Type of the elements contained in the valarray.)\t\nDesc: Valarray class (class template)\t\nProto: template <class T> class valarray;\t\n[cpp98 cpp11 ] [<valarray>]
wfilebuf()Param: ()\t\nDesc: File stream buffer (wide) (class)\t\nProto: typedef basic_filebuf<wchar_t> wfilebuf;\t\n[cpp98 cpp11] [<fstream>]
wfstream()Param: ()\t\nDesc: File stream (wide) (class)\t\nProto: typedef basic_fstream<wchar_t> wfstream;\t\n[cpp98 cpp11] [<fstream>]
wifstream()Param: ()\t\nDesc: Input file stream (wide) (class)\t\nProto: typedef basic_ifstream<wchar_t> wifstream;\t\n[cpp98 cpp11] [<fstream>]
wofstream()Param: ()\t\nDesc: Output file stream (wide) (class)\t\nProto: typedef basic_ofstream<wchar_t> wofstream;\t\n[cpp98 cpp11] [<fstream>]
wios()Param: ()\t\nDesc: Base class for wide character streams (class)\t\nProto: typedef basic_ios<wchar_t> ios;\t\n[cpp98 cpp11] [<ios>]
wstreampos()Param: ()\t\nDesc: Wide stream position type (type)\t\nProto: typedef fpos<mbstate_t> wstreampos;\t\n[cpp98 cpp11] [<ios>]
wcerr()Param: ()\t\nDesc: Standard output stream for errors (wide-oriented) (object)\t\nProto: extern basic_ostream<wchar_t> wcerr;\t\n[cpp98 cpp11] [<iostream>]
wcin()Param: ()\t\nDesc: Standard input stream (wide) (object)\t\nProto: extern basic_istream<wchar_t> wcin;\t\n[cpp98 cpp11] [<iostream>]
wclog()Param: ()\t\nDesc: Standard output stream for logging (wide) (object)\t\nProto: extern basic_ostream<wchar_t> wclog;\t\n[cpp98 cpp11] [<iostream>]
wcout()Param: ()\t\nDesc: Standard output stream (wide) (object)\t\nProto: extern basic_ostream<wchar_t> wcout;\t\n[cpp98 cpp11] [<iostream>]
wiostream()Param: ()\t\nDesc: Input/output stream (wide) (class)\t\nProto: typedef basic_iostream<wchar_t> wiostream;\t\n[arm cpp98 cpp11] [<istream>]
wistream()Param: ()\t\nDesc: Input stream (wide) (class)\t\nProto: typedef basic_istream<wchar_t> wistream;\t\n[cpp98 cpp11] [<istream>]
wostream()Param: ()\t\nDesc: Output stream (wide) (class)\t\nProto: typedef basic_ostream<wchar_t> wostream;\t\n[arm cpp98 cpp11] [<ostream>]
wistringstream()Param: ()\t\nDesc: Input string stream (wide) (class)\t\nProto: typedef basic_istringstream<wchar_t> wistringstream;\t\n[cpp98 cpp11] [<sstream>]
wostringstream()Param: ()\t\nDesc: Output string stream (wide) (class)\t\nProto: typedef basic_ostringstream<wchar_t> wostringstream;\t\n[cpp98 cpp11] [<sstream>]
wstringbuf()Param: ()\t\nDesc: String stream buffer (wide) (class)\t\nProto: typedef basic_stringbuf<wchar_t> wstringbuf;\t\n[cpp98 cpp11] [<sstream>]
wstringstream()Param: ()\t\nDesc: Input/output string stream (wide) (class)\t\nProto: typedef basic_stringstream<wchar_t> wstringstream;\t\n[cpp98 cpp11] [<sstream>]
wstreambuf()Param: ()\t\nDesc: Base buffer class for streams (wide) (class)\t\nProto: typedef basic_streambuf<wchar_t> wstreambuf;\t\n[cpp98 cpp11] [<streambuf>]
wbuffer_convert(Codecvt)Param: (Type of the conversion object: This shall be a class with the same properties as the codecvt locale facet, such as one of the standard classes defined in header <codecvt>.)\t\nDesc: no-Description (other)\t\nProto: template < class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem> > class wbuffer_convert\t\n: public std::basic_streambuf<Elem,Tr>;\t\n[cpp11 ] [<locale>]
wstring_convert(Codecvt)Param: (Type of the conversion object: This shall be a class with the same properties as the codecvt locale facet, such as one of the standard classes defined in header <codecvt>.)\t\nDesc: no-Description (other)\t\nProto: template < class Codecvt, class Elem = wchar_t, class Wide_alloc = std::allocator<Elem>, class Byte_alloc = std::allocator<char> > class wstring_convert;\t\n[cpp11 ] [<locale>]
weibull_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Weibull distribution (class template)\t\nProto: template <class RealType = double> class weibull_distribution;\t\n[cpp11 ] [<random>]
wcmatch()Param: ()\t\nDesc: match_results for wide string literals (class)\t\nProto: typedef match_results<const wchar_t*> wcmatch;\t\n[cpp11] [<regex>]
wcsub_match()Param: ()\t\nDesc: sub_match for wide string literals (class)\t\nProto: typedef sub_match<const wchar_t*> csub_match;\t\n[cpp11] [<regex>]
wregex()Param: ()\t\nDesc: Regex for wchar_t (class)\t\nProto: typedef basic_regex<wchar_t> wregex;\t\n[cpp11] [<regex>]
wsmatch()Param: ()\t\nDesc: match_results for wide string objects (class)\t\nProto: typedef match_results<wstring::const_iterator> smatch;\t\n[cpp11] [<regex>]
wssub_match()Param: ()\t\nDesc: sub_match for wide strings (class)\t\nProto: typedef sub_match<wstring::const_iterator> ssub_match;\t\n[cpp11] [<regex>]
allocator_traits(Alloc)Param: (The allocator type, aliased as member type allocator_type.)\t\nDesc: Allocator traits (class template)\t\nProto: template <class Alloc> struct allocator_traits;\t\n[cpp11 ] [<memory>]
alignment_of(T)Param: (A complete object type, or an array thereof, or a reference to a complete object type.)\t\nDesc: Alignment of (class template)\t\nProto: template <class T> struct alignment_of;\t\n[cpp11] [<type_traits>]
add_const(T)Param: (A type.)\t\nDesc: Add const qualification (class template)\t\nProto: template <class T> struct add_const;\t\n[cpp11] [<type_traits>]
add_cv(T)Param: (A type.)\t\nDesc: Add const volatile qualification (class template)\t\nProto: template <class T> struct add_cv;\t\n[cpp11] [<type_traits>]
add_lvalue_reference(T)Param: (A type.)\t\nDesc: Add lvalue reference (class template)\t\nProto: template <class T> struct add_lvalue_reference;\t\n[cpp11] [<type_traits>]
add_pointer(T)Param: (A type.)\t\nDesc: Add pointer (class template)\t\nProto: template <class T> struct add_pointer;\t\n[cpp11] [<type_traits>]
add_rvalue_reference(T)Param: (A type.)\t\nDesc: Add rvalue reference (class template)\t\nProto: template <class T> struct add_rvalue_reference;\t\n[cpp11] [<type_traits>]
add_volatile(T)Param: (A type.)\t\nDesc: Add volatile qualification (class template)\t\nProto: template <class T> struct add_volatile;\t\n[cpp11] [<type_traits>]
aligned_storage(Len)Param: (The size of the storage object, in bytes.)\t\nDesc: Aligned storage (class template)\t\nProto: template <size_t Len, size_t Align = /* default alignment */>\t\nstruct aligned_storage;\t\n[cpp11] [<type_traits>]
aligned_union(Len)Param: (The minimum size of the storage object, in bytes.)\t\nDesc: Aligned union (class template)\t\nProto: template <size_t Len, class... Types> struct aligned_union;\t\n[cpp11] [<type_traits>]
basic_filebuf(charT)Param: (Character type.)\t\nDesc: File stream buffer (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_filebuf;\t\n[cpp98 cpp11 ] [<fstream>]
basic_fstream(charT)Param: (Character type.)\t\nDesc: File stream (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_fstream;\t\n[cpp98 cpp11 ] [<fstream>]
basic_ifstream(charT)Param: (Character type.)\t\nDesc: Input file stream (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_ifstream;\t\n[cpp98 cpp11 ] [<fstream>]
basic_ofstream(charT)Param: (Character type.)\t\nDesc: Output file stream (class template)\t\nProto: template < class charT, class traits = char_traits<charT> >\t\nclass basic_ofstream;\t\n[cpp98 cpp11 ] [<fstream>]
basic_ios(charT)Param: (Character type.)\t\nDesc: Base class for streams (type-dependent components) (class template)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_ios;\t\n[cpp98 cpp11 ] [<ios>]
basic_iostream(charT)Param: (Character type.)\t\nDesc: Input/output stream (class template)\t\nProto: template <class charT, class traits = char_traits<charT> > class basic_iostream;\t\n[cpp98 cpp11 ] [<istream>]
basic_istream(charT)Param: (Character type.)\t\nDesc: Input stream (class template)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_istream;\t\n[cpp98 cpp11 ] [<istream>]
basic_ostream(charT)Param: (Character type.)\t\nDesc: Output stream (class)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_ostream;\t\n[cpp98 cpp11 ] [<ostream>]
basic_streambuf(charT)Param: (Character type.)\t\nDesc: Base buffer class for streams (class template)\t\nProto: template <class charT, class traits = char_traits<charT> >\t\nclass basic_streambuf;\t\n[cpp98 cpp11 ] [<streambuf>]
basic_regex(charT)Param: (The character type.)\t\nDesc: Regular expression (class template)\t\nProto: template <class charT, class traits = regex_traits<charT> > class basic_regex;\t\n[cpp11 ] [<regex>]
char_traits(charT)Param: (Character type.)\t\nDesc: Character traits (class template)\t\nProto: template <class charT> struct char_traits;template <> struct char_traits<char>;template <> struct char_traits<wchar_t>;\t\n[cpp98 cpp11 ] [<string>]
conditional(Cond)Param: (A compile-time constant of type bool.)\t\nDesc: Conditional type (class template)\t\nProto: template <bool Cond, class T, class F> struct conditional;\t\n[cpp11] [<type_traits>]
count(InputIterator first, InputIterator last, const T& val)Param: (Input iterators to the initial and final positions of the sequence of elements.)\t\nDesc: Count appearances of value in range (function template)\t\nProto: template <class InputIterator, class T>\t\ntypename iterator_traits<InputIterator>::difference_type\t\n count (InputIterator first, InputIterator last, const T& val);\t\n[cpp98 cpp11] [<algorithm>]
count_if(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions of the sequence of elements.)\t\nDesc: Return number of elements in range satisfying condition (function template)\t\nProto: template <class InputIterator, class UnaryPredicate>\t\ntypename iterator_traits<InputIterator>::difference_type\t\n count_if (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp98 cpp11] [<algorithm>]
decay(T)Param: (A type.)\t\nDesc: Decay type (class template)\t\nProto: template <class T> struct decay;\t\n[cpp11] [<type_traits>]
distance(InputIterator first, InputIterator last)Param: (Iterator pointing to the initial element.)\t\nDesc: Return distance between iterators (function template)\t\nProto: template<class InputIterator>\t\ntypename iterator_traits<InputIterator>::difference_type\t\n distance (InputIterator first, InputIterator last);\t\n[cpp98 cpp11] [<iterator>]
extent(T)Param: (A type.)\t\nDesc: Array dimension extent (class template)\t\nProto: template <class T, unsigned I = 0> struct extent;\t\n[cpp11] [<type_traits>]
enable_if(Cond)Param: (A compile-time constant of type bool.)\t\nDesc: Enable type if condition is met (class template)\t\nProto: template <bool Cond, class T = void> struct enable_if;\t\n[cpp11] [<type_traits>]
false_type()Param: ()\t\nDesc: False type (class)\t\nProto: typedef integral_constant<bool,false> false_type;\t\n[cpp11] [<type_traits>]
has_virtual_destructor(T)Param: (A complete type, or )\t\nDesc: Has virtual destructor (class template)\t\nProto: template <class T> struct has_virtual_destructor;\t\n[cpp11] [<type_traits>]
integral_constant(T)Param: (Type of the integral constant.)\t\nDesc: Integral constant (class template)\t\nProto: template <class T, T v>struct integral_constant;\t\n[cpp11 ] [<type_traits>]
is_abstract(T)Param: (A complete type, or )\t\nDesc: Is abstract class (class template)\t\nProto: template <class T> struct is_abstract;\t\n[cpp11] [<type_traits>]
is_arithmetic(T)Param: (A type.)\t\nDesc: Is arithmetic type (class template)\t\nProto: template <class T> struct is_arithmetic;\t\n[cpp11] [<type_traits>]
is_array(T)Param: (A type.)\t\nDesc: Is array (class template)\t\nProto: template <class T> struct is_array;\t\n[cpp11] [<type_traits>]
is_assignable(T, U)Param: (Complete types, or )\t\nDesc: Is assignable (class template)\t\nProto: template <class T, class U> struct is_assignable;\t\n[cpp11] [<type_traits>]
is_base_of(Base)Param: (A type.)\t\nDesc: Is base class of (class template)\t\nProto: template <class Base, class Derived> struct is_base_of;\t\n[cpp11] [<type_traits>]
is_class(T)Param: (A type.)\t\nDesc: Is non-union class (class template)\t\nProto: template <class T> struct is_class;\t\n[cpp11] [<type_traits>]
is_compound(T)Param: (A type.)\t\nDesc: Is compound type (class template)\t\nProto: template <class T> struct is_compound;\t\n[cpp11] [<type_traits>]
is_const(T)Param: (A type.)\t\nDesc: Is const-qualified (class template)\t\nProto: template <class T> struct is_const;\t\n[cpp11] [<type_traits>]
is_constructible(T)Param: (A complete type, or )\t\nDesc: Is constructible (class template)\t\nProto: template <class T, class... Args> struct is_constructible;\t\n[cpp11] [<type_traits>]
is_convertible(From, To)Param: (Complete types, or )\t\nDesc: Is convertible (class template)\t\nProto: template <class From, class To> struct is_convertible;\t\n[cpp11] [<type_traits>]
is_copy_assignable(T)Param: (A complete type, or )\t\nDesc: Is copy assignable (class template)\t\nProto: template <class T> struct is_copy_assignable;\t\n[cpp11] [<type_traits>]
is_copy_constructible(T)Param: (A complete type, or )\t\nDesc: Is copy constructible (class template)\t\nProto: template <class T> struct is_copy_constructible;\t\n[cpp11] [<type_traits>]
is_default_constructible(T)Param: (A complete type, or )\t\nDesc: Is default constructible (class template)\t\nProto: template <class T> struct is_default_constructible;\t\n[cpp11] [<type_traits>]
is_destructible(T)Param: (A complete type, or )\t\nDesc: Is destructible (class template)\t\nProto: template <class T> struct is_destructible;\t\n[cpp11] [<type_traits>]
is_empty(T)Param: (\t\nC++11\t\n\t\nC++14\t\n\t\n\t\n\t\nA complete type, or )\t\nDesc: Is empty class (class template)\t\nProto: template <class T> struct is_empty;\t\n[cpp11] [<type_traits>]
is_enum(T)Param: (A type.)\t\nDesc: Is enum (class template)\t\nProto: template <class T> struct is_enum;\t\n[cpp11] [<type_traits>]
is_floating_point(T)Param: (A type.)\t\nDesc: Is floating point (class template)\t\nProto: template <class T> struct is_floating_point;\t\n[cpp11] [<type_traits>]
is_function(T)Param: (A type.)\t\nDesc: Is function (class template)\t\nProto: template <class T> struct is_function;\t\n[cpp11] [<type_traits>]
is_fundamental(T)Param: (A type.)\t\nDesc: Is fundamental type (class template)\t\nProto: template <class T> struct is_fundamental;\t\n[cpp11] [<type_traits>]
is_integral(T)Param: (A type.)\t\nDesc: Is integral (class template)\t\nProto: template <class T> struct is_integral;\t\n[cpp11] [<type_traits>]
is_literal_type(T)Param: (A complete type, or )\t\nDesc: Is literal type (class template)\t\nProto: template <class T> struct is_literal_type;\t\n[cpp11] [<type_traits>]
is_lvalue_reference(T)Param: (A type.)\t\nDesc: Is lvalue reference (class template)\t\nProto: template <class T> struct is_lvalue_reference;\t\n[cpp11] [<type_traits>]
is_member_function_pointer(T)Param: (A type.)\t\nDesc: Is member function pointer (class template)\t\nProto: template <class T> struct is_member_function_pointer;\t\n[cpp11] [<type_traits>]
is_member_object_pointer(T)Param: (A type.)\t\nDesc: Is member object pointer (class template)\t\nProto: template <class T> struct is_member_object_pointer;\t\n[cpp11] [<type_traits>]
is_member_pointer(T)Param: (A type.)\t\nDesc: Is member pointer type (class template)\t\nProto: template <class T> struct is_member_pointer;\t\n[cpp11] [<type_traits>]
is_move_assignable(T)Param: (A complete type, or )\t\nDesc: Is move assignable (class template)\t\nProto: template <class T> struct is_move_assignable;\t\n[cpp11] [<type_traits>]
is_move_constructible(T)Param: (A complete type, or )\t\nDesc: Is move constructible (class template)\t\nProto: template <class T> struct is_move_constructible;\t\n[cpp11] [<type_traits>]
is_nothrow_assignable(T, U)Param: (Complete types, or )\t\nDesc: Is assignable throwing no exceptions (class template)\t\nProto: template <class T, class U> struct is_nothrow_assignable;\t\n[cpp11] [<type_traits>]
is_nothrow_constructible(T)Param: (A complete type, or )\t\nDesc: Is constructible throwing no exceptions (class template)\t\nProto: template <class T, class... Args> struct is_nothrow_constructible;\t\n[cpp11] [<type_traits>]
is_nothrow_copy_assignable(T)Param: (A complete type, or )\t\nDesc: Is copy assignable throwing no exceptions (class template)\t\nProto: template <class T> struct is_nothrow_copy_assignable;\t\n[cpp11] [<type_traits>]
is_nothrow_copy_constructible(T)Param: (A complete type, or )\t\nDesc: Is copy constructible throwing no exceptions (class template)\t\nProto: template <class T> struct is_nothrow_copy_constructible;\t\n[cpp11] [<type_traits>]
is_nothrow_default_constructible(T)Param: (A complete type, or )\t\nDesc: Is default constructible throwing no exceptions (class template)\t\nProto: template <class T> struct is_nothrow_default_constructible;\t\n[cpp11] [<type_traits>]
is_nothrow_destructible(T)Param: (A complete type, or )\t\nDesc: Is nothrow destructible (class template)\t\nProto: template <class T> struct is_nothrow_destructible;\t\n[cpp11] [<type_traits>]
is_nothrow_move_assignable(T)Param: (A complete type, or )\t\nDesc: Is move assignable throwing no exception (class template)\t\nProto: template <class T> struct is_nothrow_move_assignable;\t\n[cpp11] [<type_traits>]
is_nothrow_move_constructible(T)Param: (A complete type, or )\t\nDesc: Is move constructible throwing no exceptions (class template)\t\nProto: template <class T> struct is_nothrow_move_constructible;\t\n[cpp11] [<type_traits>]
is_null_pointer(T)Param: (A type.)\t\nDesc: no-Description (other)\t\nProto: template <class T> struct is_null_pointer;\t\n[cpp14] [<type_traits>]
is_object(T)Param: (A type.)\t\nDesc: Is object type (class template)\t\nProto: template <class T> struct is_object;\t\n[cpp11] [<type_traits>]
is_pod(T)Param: (A complete type, or )\t\nDesc: Is POD type (class template)\t\nProto: template <class T> struct is_pod;\t\n[cpp11] [<type_traits>]
is_pointer(T)Param: (A type.)\t\nDesc: Is pointer (class template)\t\nProto: template <class T> struct is_pointer;\t\n[cpp11] [<type_traits>]
is_polymorphic(T)Param: (\t\nC++11\t\n\t\nC++14\t\n\t\n\t\n\t\nA complete type, or )\t\nDesc: Is polymorphic (class template)\t\nProto: template <class T> struct is_polymorphic;\t\n[cpp11] [<type_traits>]
is_reference(T)Param: (A type.)\t\nDesc: Is reference type (class template)\t\nProto: template <class T> struct is_reference;\t\n[cpp11] [<type_traits>]
is_rvalue_reference(T)Param: (A type.)\t\nDesc: Is rvalue reference (class template)\t\nProto: template <class T> struct is_rvalue_reference;\t\n[cpp11] [<type_traits>]
is_same(T, U)Param: (Types.)\t\nDesc: Is same type (class template)\t\nProto: template <class T, class U> struct is_same;\t\n[cpp11] [<type_traits>]
is_scalar(T)Param: (A type.)\t\nDesc: Is scalar type (class template)\t\nProto: template <class T> struct is_scalar;\t\n[cpp11] [<type_traits>]
is_signed(T)Param: (A type.)\t\nDesc: Is signed type (class template)\t\nProto: template <class T> struct is_signed;\t\n[cpp11] [<type_traits>]
is_standard_layout(T)Param: (A complete type, or )\t\nDesc: Is standard-layout type (class template)\t\nProto: template <class T> struct is_standard_layout;\t\n[cpp11] [<type_traits>]
is_trivial(T)Param: (A complete type, or )\t\nDesc: Is trivial type (class template)\t\nProto: template <class T> struct is_trivial;\t\n[cpp11] [<type_traits>]
is_trivially_assignable(T, U)Param: (Complete types, or )\t\nDesc: Is trivially assignable (class template)\t\nProto: template <class T, class U> struct is_trivially_assignable;\t\n[cpp11] [<type_traits>]
is_trivially_constructible(T)Param: (A complete type, or )\t\nDesc: Is trivially constructible (class template)\t\nProto: template <class T, class... Args> struct is_trivially_constructible;\t\n[cpp11] [<type_traits>]
is_trivially_copyable(T)Param: (A complete type, or )\t\nDesc: Is trivially copyable (class template)\t\nProto: template <class T> struct is_trivially_copyable;\t\n[cpp11] [<type_traits>]
is_trivially_copy_assignable(T)Param: (A complete type, or )\t\nDesc: Is trivially copy assignable (class template)\t\nProto: template <class T> struct is_trivially_copy_assignable;\t\n[cpp11] [<type_traits>]
is_trivially_copy_constructible(T)Param: (A complete type, or )\t\nDesc: Is trivially copy constructible (class template)\t\nProto: template <class T> struct is_trivially_copy_constructible;\t\n[cpp11] [<type_traits>]
is_trivially_default_constructible(T)Param: (A complete type, or )\t\nDesc: Is trivially default constructible (class template)\t\nProto: template <class T> struct is_trivially_default_constructible;\t\n[cpp11] [<type_traits>]
is_trivially_destructible(T)Param: (A complete type, or )\t\nDesc: Is trivially destructible (class template)\t\nProto: template <class T> struct is_trivially_destructible;\t\n[cpp11] [<type_traits>]
is_trivially_move_assignable(T)Param: (A complete type, or )\t\nDesc: Is trivially move assignable (class template)\t\nProto: template <class T> struct is_trivially_move_assignable;\t\n[cpp11] [<type_traits>]
is_trivially_move_constructible(T)Param: (A complete type, or )\t\nDesc: Is trivially move constructible (class template)\t\nProto: template <class T> struct is_trivially_move_constructible;\t\n[cpp11] [<type_traits>]
is_union(T)Param: (A type.)\t\nDesc: Is union (class template)\t\nProto: template <class T> struct is_union;\t\n[cpp11] [<type_traits>]
is_unsigned(T)Param: (A type.)\t\nDesc: Is unsigned type (class template)\t\nProto: template <class T> struct is_unsigned;\t\n[cpp11] [<type_traits>]
is_void(T)Param: (A type.)\t\nDesc: Is void (class template)\t\nProto: template <class T> struct is_void;\t\n[cpp11] [<type_traits>]
is_volatile(T)Param: (A type.)\t\nDesc: Is volatile-qualified (class template)\t\nProto: template <class T> struct is_volatile;\t\n[cpp11] [<type_traits>]
make_signed(T)Param: (An integer type (except bool), or an enumeration type.)\t\nDesc: Make signed (class template)\t\nProto: template <class T> struct make_signed;\t\n[cpp11] [<type_traits>]
make_unsigned(T)Param: (An integer type (except bool), or an enumeration type.)\t\nDesc: Make unsigned (class template)\t\nProto: template <class T> struct make_unsigned;\t\n[cpp11] [<type_traits>]
pointer_traits(Ptr)Param: (Pointer-like type.)\t\nDesc: Pointer traits (class template)\t\nProto: template <class Ptr> class pointer_traits; // template\t\ntemplate <class T> class pointer_traits<T*>; // template specialization\t\n[cpp11 ] [<memory>]
rank(T)Param: (A type.)\t\nDesc: Array rank (class template)\t\nProto: template <class T> struct rank;\t\n[cpp11] [<type_traits>]
remove_all_extents(T)Param: (A type.)\t\nDesc: Remove all array extents (class template)\t\nProto: template <class T> struct remove_all_extents;\t\n[cpp11] [<type_traits>]
remove_const(T)Param: (A type.)\t\nDesc: Remove const qualification (class template)\t\nProto: template <class T> struct remove_const;\t\n[cpp11] [<type_traits>]
remove_cv(T)Param: (A type.)\t\nDesc: Remove cv qualification (class template)\t\nProto: template <class T> struct remove_cv;\t\n[cpp11] [<type_traits>]
remove_extent(T)Param: (A type.)\t\nDesc: Remove array extent (class template)\t\nProto: template <class T> struct remove_extent;\t\n[cpp11] [<type_traits>]
remove_pointer(T)Param: (A type.)\t\nDesc: Remove pointer (class template)\t\nProto: template <class T> struct remove_pointer;\t\n[cpp11] [<type_traits>]
remove_reference(T)Param: (A type.)\t\nDesc: Remove reference (class template)\t\nProto: template <class T> struct remove_reference;\t\n[cpp11] [<type_traits>]
remove_volatile(T)Param: (A type.)\t\nDesc: Remove volatile qualification (class template)\t\nProto: template <class T> struct remove_volatile;\t\n[cpp11] [<type_traits>]
result_of(Fn)Param: (A callable type (i.)\t\nDesc: Result of call (class template)\t\nProto: template <class Fn, class... ArgTypes> struct result_of<Fn(ArgTypes...)>;\t\n[cpp11] [<type_traits>]
true_type()Param: ()\t\nDesc: True type (class)\t\nProto: typedef integral_constant<bool,true> true_type;\t\n[cpp11] [<type_traits>]
underlying_type(T)Param: (An enumeration type (enum).)\t\nDesc: Underlying type of enum (class template)\t\nProto: template <class T> struct underlying_type;\t\n[cpp11] [<type_traits>]



# Constants / special macros
FENV_ACCESS()Param: ()\t\nDesc: Access to Floating-point environment (pragma)\t\nProto:\t\n#pragma STDC FENV_ACCESS on\t\n#pragma STDC FENV_ACCESS off\t\n[c99 cpp11] [<cfenv> (fenv.h)]
FE_ALL_EXCEPT()Param: ()\t\nDesc: All exceptions (macro)\t\nProto: no-proto\t\n[c99 cpp11] [<cfenv> (fenv.h)]
FE_DFL_ENV()Param: ()\t\nDesc: Default environment (macro)\t\nProto: fenv_t*\t\n[c99 cpp11] [<cfenv> (fenv.h)]
FE_DIVBYZERO()Param: ()\t\nDesc: Pole error exception (macro)\t\nProto: no-proto\t\n[c99 cpp11] [<cfenv> (fenv.h)]
FE_DOWNWARD()Param: ()\t\nDesc: Downward rounding direction mode (macro)\t\nProto: no-proto\t\n[c99 cpp11] [<cfenv> (fenv.h)]
FE_INEXACT()Param: ()\t\nDesc: Inexact result exception (macro)\t\nProto: no-proto\t\n[c99 cpp11] [<cfenv> (fenv.h)]
FE_INVALID()Param: ()\t\nDesc: Invalid argument exception (macro)\t\nProto: no-proto\t\n[c99 cpp11] [<cfenv> (fenv.h)]
FE_OVERFLOW()Param: ()\t\nDesc: Overflow range error exception (macro)\t\nProto: no-proto\t\n[c99 cpp11] [<cfenv> (fenv.h)]
FE_TONEAREST()Param: ()\t\nDesc: To-nearest rounding direction mode (macro)\t\nProto: no-proto\t\n[c99 cpp11] [<cfenv> (fenv.h)]
FE_TOWARDZERO()Param: ()\t\nDesc: Toward-zero rounding direction mode (macro)\t\nProto: no-proto\t\n[c99 cpp11] [<cfenv> (fenv.h)]
FE_UNDERFLOW()Param: ()\t\nDesc: Underflow range error exception (macro)\t\nProto: no-proto\t\n[c99 cpp11] [<cfenv> (fenv.h)]
FE_UPWARD()Param: ()\t\nDesc: Upward rounding direction mode (macro)\t\nProto: no-proto\t\n[c99 cpp11] [<cfenv> (fenv.h)]
NULL()Param: ()\t\nDesc: no-Description (other)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<clocale> (locale.h)]
HUGE_VAL()Param: ()\t\nDesc: Huge value (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cmath> (math.h)]
HUGE_VALF()Param: ()\t\nDesc: Huge float value\t\nProto: no-proto\t\n[c99 cpp11] [<cmath> (math.h)]
HUGE_VALL()Param: ()\t\nDesc: Huge long double value (constant)\t\nProto: no-proto\t\n[c99 cpp11] [<cmath> (math.h)]
INFINITY()Param: ()\t\nDesc: Infinity (constant)\t\nProto: no-proto\t\n[c99 cpp11] [<cmath> (math.h)]
NAN()Param: ()\t\nDesc: Not-A-Number (constant)\t\nProto: float\t\n[cpp99 cpp11] [<cmath> (math.h)]
FILE()Param: ()\t\nDesc: Object containing information to control a stream (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
BUFSIZ()Param: ()\t\nDesc: Buffer size (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
EOF()Param: ()\t\nDesc: End-of-File (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
FILENAME_MAX()Param: ()\t\nDesc: Maximum length of file names (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
FOPEN_MAX()Param: ()\t\nDesc: Potential limit of simultaneous open streams (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
L_tmpnam()Param: ()\t\nDesc: Minimum length for temporary file name (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
TMP_MAX()Param: ()\t\nDesc: Number of temporary files (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdio> (stdio.h)]
EXIT_FAILURE()Param: ()\t\nDesc: Failure termination code (macro)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
EXIT_SUCCESS()Param: ()\t\nDesc: Success termination code (macro)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
MB_CUR_MAX()Param: ()\t\nDesc: Maximum size of multibyte characters (macro)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
RAND_MAX()Param: ()\t\nDesc: Maximum value returned by rand (macro)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cstdlib> (stdlib.h)]
CLOCKS_PER_SEC()Param: ()\t\nDesc: Clock ticks per second (macro)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<ctime> (time.h)]
WCHAR_MAX()Param: ()\t\nDesc: Maximum value of wchar_t (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
WCHAR_MIN()Param: ()\t\nDesc: Minimum value of wchar_t (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
WEOF()Param: ()\t\nDesc: Wide end-of-file (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [<cwchar> (wchar.h)]
ATOMIC_FLAG_INIT()Param: ()\t\nDesc: Initialization of atomic flag (macro)\t\nProto: ATOMIC_FLAG_INIT\t\n[cpp11] [<atomic>]
ATOMIC_VAR_INIT(val)Param: (Value to use for initialization.)\t\nDesc: Initialization of atomic variable (macro)\t\nProto: ATOMIC_VAR_INIT(val)\t\n[cpp11] [<atomic>]
std::

