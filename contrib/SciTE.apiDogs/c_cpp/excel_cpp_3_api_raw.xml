<?xml version="1.0"?>
<?mso-application progid="Excel.Sheet"?>
<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"
 xmlns:o="urn:schemas-microsoft-com:office:office"
 xmlns:x="urn:schemas-microsoft-com:office:excel"
 xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"
 xmlns:html="http://www.w3.org/TR/REC-html40">
 <DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">
  <Author>rosablasblau</Author>
  <LastAuthor>rosablasblau</LastAuthor>
  <Created>2016-03-19T22:43:52Z</Created>
  <LastSaved>2016-03-31T13:19:19Z</LastSaved>
  <Version>14.00</Version>
 </DocumentProperties>
 <OfficeDocumentSettings xmlns="urn:schemas-microsoft-com:office:office">
  <AllowPNG/>
 </OfficeDocumentSettings>
 <ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">
  <WindowHeight>7875</WindowHeight>
  <WindowWidth>19815</WindowWidth>
  <WindowTopX>270</WindowTopX>
  <WindowTopY>585</WindowTopY>
  <ProtectStructure>False</ProtectStructure>
  <ProtectWindows>False</ProtectWindows>
 </ExcelWorkbook>
 <Styles>
  <Style ss:ID="Default" ss:Name="Normal">
   <Alignment ss:Vertical="Bottom"/>
   <Borders/>
   <Font ss:FontName="Calibri" x:Family="Swiss" ss:Size="11" ss:Color="#000000"/>
   <Interior/>
   <NumberFormat/>
   <Protection/>
  </Style>
  <Style ss:ID="s62">
   <NumberFormat/>
  </Style>
  <Style ss:ID="s63">
   <Alignment ss:Vertical="Bottom" ss:WrapText="1"/>
   <NumberFormat ss:Format="[$-407]d/\ mmm/;@"/>
  </Style>
 </Styles>
 <Worksheet ss:Name="cpp_api">
  <Table ss:ExpandedColumnCount="14" ss:ExpandedRowCount="929" x:FullColumns="1"
   x:FullRows="1" ss:StyleID="s62" ss:DefaultColumnWidth="60"
   ss:DefaultRowHeight="15">
   <Column ss:StyleID="s63" ss:AutoFitWidth="0" ss:Width="329.25"/>
   <Column ss:StyleID="s62" ss:AutoFitWidth="0" ss:Width="527.25"/>
   <Column ss:StyleID="s62" ss:AutoFitWidth="0" ss:Width="486"/>
   <Column ss:StyleID="s62" ss:AutoFitWidth="0" ss:Width="225.75"/>
   <Column ss:StyleID="s62" ss:AutoFitWidth="0" ss:Width="378"/>
   <Column ss:StyleID="s62" ss:Width="206.25"/>
   <Column ss:StyleID="s62" ss:Width="905.25"/>
   <Column ss:StyleID="s62" ss:Width="1342.5"/>
   <Column ss:StyleID="s62" ss:Width="117.75"/>
   <Column ss:StyleID="s62" ss:Width="107.25"/>
   <Column ss:StyleID="s62" ss:Width="63"/>
   <Column ss:StyleID="s62" ss:Width="216.75"/>
   <Column ss:StyleID="s62" ss:Width="81.75"/>
   <Column ss:StyleID="s62" ss:Width="94.5"/>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">errno()Param: ()\t\nDesc: Last error number (macro)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cerrno&gt; (errno.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">errno</Data></Cell>
    <Cell><Data ss:Type="String">Last error number (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cerrno&gt; (errno.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Errors</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fenv_t()Param: ()\t\nDesc: Floating-point environment type (type)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">fenv_t</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fexcept_t()Param: ()\t\nDesc: Floating-point exceptions type (type)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">fexcept_t</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point exceptions type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FENV_ACCESS()Param: ()\t\nDesc: Access to Floating-point environment (pragma)\t\nProto: on (1)\t\n#pragma STDC FENV_ACCESS on\t\n\t\noff (2)\t\n#pragma STDC FENV_ACCESS off\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">on (1)\t\n#pragma STDC FENV_ACCESS on\t\n\t\noff (2)\t\n#pragma STDC FENV_ACCESS off</Data></Cell>
    <Cell><Data ss:Type="String">FENV_ACCESS</Data></Cell>
    <Cell><Data ss:Type="String">Access to Floating-point environment (pragma)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">pragma</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FE_ALL_EXCEPT()Param: ()\t\nDesc: All exceptions (macro)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FE_ALL_EXCEPT</Data></Cell>
    <Cell><Data ss:Type="String">All exceptions (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FE_DFL_ENV()Param: ()\t\nDesc: Default environment (macro)\t\nProto: fenv_t*\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">fenv_t*</Data></Cell>
    <Cell><Data ss:Type="String">FE_DFL_ENV</Data></Cell>
    <Cell><Data ss:Type="String">Default environment (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FE_DIVBYZERO()Param: ()\t\nDesc: Pole error exception (macro)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FE_DIVBYZERO</Data></Cell>
    <Cell><Data ss:Type="String">Pole error exception (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FE_DOWNWARD()Param: ()\t\nDesc: Downward rounding direction mode (macro)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FE_DOWNWARD</Data></Cell>
    <Cell><Data ss:Type="String">Downward rounding direction mode (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FE_INEXACT()Param: ()\t\nDesc: Inexact result exception (macro)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FE_INEXACT</Data></Cell>
    <Cell><Data ss:Type="String">Inexact result exception (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FE_INVALID()Param: ()\t\nDesc: Invalid argument exception (macro)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FE_INVALID</Data></Cell>
    <Cell><Data ss:Type="String">Invalid argument exception (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FE_OVERFLOW()Param: ()\t\nDesc: Overflow range error exception (macro)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FE_OVERFLOW</Data></Cell>
    <Cell><Data ss:Type="String">Overflow range error exception (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FE_TONEAREST()Param: ()\t\nDesc: To-nearest rounding direction mode (macro)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FE_TONEAREST</Data></Cell>
    <Cell><Data ss:Type="String">To-nearest rounding direction mode (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FE_TOWARDZERO()Param: ()\t\nDesc: Toward-zero rounding direction mode (macro)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FE_TOWARDZERO</Data></Cell>
    <Cell><Data ss:Type="String">Toward-zero rounding direction mode (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FE_UNDERFLOW()Param: ()\t\nDesc: Underflow range error exception (macro)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FE_UNDERFLOW</Data></Cell>
    <Cell><Data ss:Type="String">Underflow range error exception (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FE_UPWARD()Param: ()\t\nDesc: Upward rounding direction mode (macro)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FE_UPWARD</Data></Cell>
    <Cell><Data ss:Type="String">Upward rounding direction mode (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">NULL()Param: ()\t\nDesc: no-Description (other)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;clocale&gt; (locale.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">NULL</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;clocale&gt; (locale.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">struct lconv()Param: ()\t\nDesc: Formatting info for numeric values (type)\t\nProto: struct lconv;\t\n[c90 c99 arm cpp98 cpp11] [&lt;clocale&gt; (locale.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct lconv;</Data></Cell>
    <Cell><Data ss:Type="String">struct lconv</Data></Cell>
    <Cell><Data ss:Type="String">Formatting info for numeric values (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;clocale&gt; (locale.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fpclassify(x)Param: ()\t\nDesc: Classify floating-point value (macro/function)\t\nProto: fpclassify(x)\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">fpclassify(x)</Data></Cell>
    <Cell><Data ss:Type="String">fpclassify</Data></Cell>
    <Cell><Data ss:Type="String">Classify floating-point value (macro/function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro/function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isfinite(x)Param: (A floating-point value.)\t\nDesc: Is finite value (macro)\t\nProto: isfinite(x)\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">isfinite(x)</Data></Cell>
    <Cell><Data ss:Type="String">isfinite</Data></Cell>
    <Cell><Data ss:Type="String">Is finite value (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point value.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isgreater(x, y)Param: (Values to be compared.)\t\nDesc: Is greater (macro)\t\nProto: isgreater(x,y)\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">isgreater(x,y)</Data></Cell>
    <Cell><Data ss:Type="String">isgreater</Data></Cell>
    <Cell><Data ss:Type="String">Is greater (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(x, y)</Data></Cell>
    <Cell><Data ss:Type="String">Values to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isgreaterequal(x, y)Param: (Values to be compared.)\t\nDesc: Is greater or equal (macro)\t\nProto: isgreaterequal(x,y)\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">isgreaterequal(x,y)</Data></Cell>
    <Cell><Data ss:Type="String">isgreaterequal</Data></Cell>
    <Cell><Data ss:Type="String">Is greater or equal (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(x, y)</Data></Cell>
    <Cell><Data ss:Type="String">Values to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isinf(x)Param: (A floating-point value.)\t\nDesc: Is infinity (macro/function)\t\nProto: isinf(x)\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">isinf(x)</Data></Cell>
    <Cell><Data ss:Type="String">isinf</Data></Cell>
    <Cell><Data ss:Type="String">Is infinity (macro/function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point value.</Data></Cell>
    <Cell><Data ss:Type="String">macro/function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isless(x, y)Param: (Values to be compared.)\t\nDesc: Is less (macro)\t\nProto: isless(x,y)\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">isless(x,y)</Data></Cell>
    <Cell><Data ss:Type="String">isless</Data></Cell>
    <Cell><Data ss:Type="String">Is less (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(x, y)</Data></Cell>
    <Cell><Data ss:Type="String">Values to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">islessequal(x, y)Param: (Values to be compared.)\t\nDesc: Is less or equal (macro)\t\nProto: islessequal(x,y)\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">islessequal(x,y)</Data></Cell>
    <Cell><Data ss:Type="String">islessequal</Data></Cell>
    <Cell><Data ss:Type="String">Is less or equal (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(x, y)</Data></Cell>
    <Cell><Data ss:Type="String">Values to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">islessgreater(x, y)Param: (Values to be compared.)\t\nDesc: Is less or greater (macro)\t\nProto: islessgreater(x,y)\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">islessgreater(x,y)</Data></Cell>
    <Cell><Data ss:Type="String">islessgreater</Data></Cell>
    <Cell><Data ss:Type="String">Is less or greater (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(x, y)</Data></Cell>
    <Cell><Data ss:Type="String">Values to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isnan(x)Param: (A floating-point value.)\t\nDesc: Is Not-A-Number (macro/function)\t\nProto: isnan(x)\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">isnan(x)</Data></Cell>
    <Cell><Data ss:Type="String">isnan</Data></Cell>
    <Cell><Data ss:Type="String">Is Not-A-Number (macro/function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point value.</Data></Cell>
    <Cell><Data ss:Type="String">macro/function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isnormal(x)Param: (A floating-point value.)\t\nDesc: Is normal (macro/function)\t\nProto: isnormal(x)\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">isnormal(x)</Data></Cell>
    <Cell><Data ss:Type="String">isnormal</Data></Cell>
    <Cell><Data ss:Type="String">Is normal (macro/function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point value.</Data></Cell>
    <Cell><Data ss:Type="String">macro/function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isunordered(x, y)Param: (Values to check whether they are unordered.)\t\nDesc: Is unordered (macro)\t\nProto: isunordered(x,y)\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">isunordered(x,y)</Data></Cell>
    <Cell><Data ss:Type="String">isunordered</Data></Cell>
    <Cell><Data ss:Type="String">Is unordered (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(x, y)</Data></Cell>
    <Cell><Data ss:Type="String">Values to check whether they are unordered.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">signbit(x)Param: (A floating-point value.)\t\nDesc: Sign bit (macro/function)\t\nProto: signbit(x)\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">signbit(x)</Data></Cell>
    <Cell><Data ss:Type="String">signbit</Data></Cell>
    <Cell><Data ss:Type="String">Sign bit (macro/function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point value.</Data></Cell>
    <Cell><Data ss:Type="String">macro/function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">HUGE_VAL()Param: ()\t\nDesc: Huge value (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">HUGE_VAL</Data></Cell>
    <Cell><Data ss:Type="String">Huge value (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">HUGE_VALF()Param: ()\t\nDesc: Huge float value\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">HUGE_VALF</Data></Cell>
    <Cell><Data ss:Type="String">Huge float value</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">custom</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">HUGE_VALL()Param: ()\t\nDesc: Huge long double value (constant)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">HUGE_VALL</Data></Cell>
    <Cell><Data ss:Type="String">Huge long double value (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">INFINITY()Param: ()\t\nDesc: Infinity (constant)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">INFINITY</Data></Cell>
    <Cell><Data ss:Type="String">Infinity (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">math_errhandling()Param: ()\t\nDesc: Error handling (macro)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">math_errhandling</Data></Cell>
    <Cell><Data ss:Type="String">Error handling (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">NAN()Param: ()\t\nDesc: Not-A-Number (constant)\t\nProto: float\t\n[cpp99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">float</Data></Cell>
    <Cell><Data ss:Type="String">NAN</Data></Cell>
    <Cell><Data ss:Type="String">Not-A-Number (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">cpp99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">double_t()Param: ()\t\nDesc: Floating-point type (type)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">double_t</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">float_t()Param: ()\t\nDesc: Floating-point type (type)\t\nProto: no-proto\t\n[cpp99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">float_t</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">cpp99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">jmp_buf()Param: ()\t\nDesc: Type to hold information to restore calling environment (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;csetjmp&gt; (setjmp.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">jmp_buf</Data></Cell>
    <Cell><Data ss:Type="String">Type to hold information to restore calling environment (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;csetjmp&gt; (setjmp.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Non local jumps</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">sig_atomic_t()Param: ()\t\nDesc: Integral type (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;csignal&gt; (signal.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">sig_atomic_t</Data></Cell>
    <Cell><Data ss:Type="String">Integral type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;csignal&gt; (signal.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to handle signals</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">va_list()Param: ()\t\nDesc: Type to hold information about variable arguments (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdarg&gt; (stdarg.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">va_list</Data></Cell>
    <Cell><Data ss:Type="String">Type to hold information about variable arguments (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdarg&gt; (stdarg.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Variable arguments handling</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">max_align_t()Param: ()\t\nDesc: Type with widest scalar alignment (type)\t\nProto: no-proto\t\n[cpp11] [&lt;cstddef&gt; (stddef.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">max_align_t</Data></Cell>
    <Cell><Data ss:Type="String">Type with widest scalar alignment (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstddef&gt; (stddef.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ptrdiff_t()Param: ()\t\nDesc: Result of pointer subtraction (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstddef&gt; (stddef.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">ptrdiff_t</Data></Cell>
    <Cell><Data ss:Type="String">Result of pointer subtraction (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstddef&gt; (stddef.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">size_t()Param: ()\t\nDesc: Unsigned integral type (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstddef&gt; (stddef.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">size_t</Data></Cell>
    <Cell><Data ss:Type="String">Unsigned integral type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstddef&gt; (stddef.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">stderr()Param: ()\t\nDesc: no-Description (other)\t\nProto: FILE * stderr;\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">FILE * stderr;</Data></Cell>
    <Cell><Data ss:Type="String">stderr</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">stdin()Param: ()\t\nDesc: no-Description (other)\t\nProto: FILE * stdin;\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">FILE * stdin;</Data></Cell>
    <Cell><Data ss:Type="String">stdin</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">stdout()Param: ()\t\nDesc: no-Description (other)\t\nProto: FILE * stdout;\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">FILE * stdout;</Data></Cell>
    <Cell><Data ss:Type="String">stdout</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FILE()Param: ()\t\nDesc: Object containing information to control a stream (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FILE</Data></Cell>
    <Cell><Data ss:Type="String">Object containing information to control a stream (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fpos_t()Param: ()\t\nDesc: Object containing information to specify a position within a file (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">fpos_t</Data></Cell>
    <Cell><Data ss:Type="String">Object containing information to specify a position within a file (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">BUFSIZ()Param: ()\t\nDesc: Buffer size (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">BUFSIZ</Data></Cell>
    <Cell><Data ss:Type="String">Buffer size (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">EOF()Param: ()\t\nDesc: End-of-File (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">EOF</Data></Cell>
    <Cell><Data ss:Type="String">End-of-File (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FILENAME_MAX()Param: ()\t\nDesc: Maximum length of file names (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FILENAME_MAX</Data></Cell>
    <Cell><Data ss:Type="String">Maximum length of file names (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">FOPEN_MAX()Param: ()\t\nDesc: Potential limit of simultaneous open streams (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">FOPEN_MAX</Data></Cell>
    <Cell><Data ss:Type="String">Potential limit of simultaneous open streams (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">L_tmpnam()Param: ()\t\nDesc: Minimum length for temporary file name (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">L_tmpnam</Data></Cell>
    <Cell><Data ss:Type="String">Minimum length for temporary file name (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">TMP_MAX()Param: ()\t\nDesc: Number of temporary files (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">TMP_MAX</Data></Cell>
    <Cell><Data ss:Type="String">Number of temporary files (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">div_t(quot)Param: (Represents the quotient of the integral division operation performed by div, which is the integer of lesser magnitude that is nearest to the algebraic quotient.)\t\nDesc: Structure returned by div (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">div_t</Data></Cell>
    <Cell><Data ss:Type="String">Structure returned by div (type)</Data></Cell>
    <Cell><Data ss:Type="String">(quot)</Data></Cell>
    <Cell><Data ss:Type="String">Represents the quotient of the integral division operation performed by div, which is the integer of lesser magnitude that is nearest to the algebraic quotient.</Data></Cell>
    <Cell><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ldiv_t(quot)Param: (Represents the quotient of the integral division operation performed by ldiv, which is the integer of lesser magnitude that is nearest to the algebraic quotient.)\t\nDesc: Structure returned by ldiv (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">ldiv_t</Data></Cell>
    <Cell><Data ss:Type="String">Structure returned by ldiv (type)</Data></Cell>
    <Cell><Data ss:Type="String">(quot)</Data></Cell>
    <Cell><Data ss:Type="String">Represents the quotient of the integral division operation performed by ldiv, which is the integer of lesser magnitude that is nearest to the algebraic quotient.</Data></Cell>
    <Cell><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">lldiv_t(quot)Param: (Represents the quotient of the integral division operation performed by lldiv, which is the integer of lesser magnitude that is nearest to the algebraic quotient.)\t\nDesc: Structure returned by lldiv (type)\t\nProto: no-proto\t\n[c99 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">lldiv_t</Data></Cell>
    <Cell><Data ss:Type="String">Structure returned by lldiv (type)</Data></Cell>
    <Cell><Data ss:Type="String">(quot)</Data></Cell>
    <Cell><Data ss:Type="String">Represents the quotient of the integral division operation performed by lldiv, which is the integer of lesser magnitude that is nearest to the algebraic quotient.</Data></Cell>
    <Cell><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">EXIT_FAILURE()Param: ()\t\nDesc: Failure termination code (macro)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">EXIT_FAILURE</Data></Cell>
    <Cell><Data ss:Type="String">Failure termination code (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">EXIT_SUCCESS()Param: ()\t\nDesc: Success termination code (macro)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">EXIT_SUCCESS</Data></Cell>
    <Cell><Data ss:Type="String">Success termination code (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">MB_CUR_MAX()Param: ()\t\nDesc: Maximum size of multibyte characters (macro)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">MB_CUR_MAX</Data></Cell>
    <Cell><Data ss:Type="String">Maximum size of multibyte characters (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">RAND_MAX()Param: ()\t\nDesc: Maximum value returned by rand (macro)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">RAND_MAX</Data></Cell>
    <Cell><Data ss:Type="String">Maximum value returned by rand (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">CLOCKS_PER_SEC()Param: ()\t\nDesc: Clock ticks per second (macro)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;ctime&gt; (time.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">CLOCKS_PER_SEC</Data></Cell>
    <Cell><Data ss:Type="String">Clock ticks per second (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ctime&gt; (time.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Time Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">clock_t()Param: ()\t\nDesc: Clock type (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;ctime&gt; (time.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">clock_t</Data></Cell>
    <Cell><Data ss:Type="String">Clock type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ctime&gt; (time.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Time Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">time_t()Param: ()\t\nDesc: Time type (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;ctime&gt; (time.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">time_t</Data></Cell>
    <Cell><Data ss:Type="String">Time type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ctime&gt; (time.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Time Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">struct tm()Param: ()\t\nDesc: Time structure (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;ctime&gt; (time.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">struct tm</Data></Cell>
    <Cell><Data ss:Type="String">Time structure (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ctime&gt; (time.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Time Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mbstate_t()Param: ()\t\nDesc: Multibyte conversion state (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">mbstate_t</Data></Cell>
    <Cell><Data ss:Type="String">Multibyte conversion state (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wchar_t()Param: ()\t\nDesc: Wide character (type)\t\nProto: no-proto\t\n[c99] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">wchar_t</Data></Cell>
    <Cell><Data ss:Type="String">Wide character (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c99</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wint_t()Param: ()\t\nDesc: Wide int type (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">wint_t</Data></Cell>
    <Cell><Data ss:Type="String">Wide int type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">WCHAR_MAX()Param: ()\t\nDesc: Maximum value of wchar_t (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">WCHAR_MAX</Data></Cell>
    <Cell><Data ss:Type="String">Maximum value of wchar_t (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">WCHAR_MIN()Param: ()\t\nDesc: Minimum value of wchar_t (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">WCHAR_MIN</Data></Cell>
    <Cell><Data ss:Type="String">Minimum value of wchar_t (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">WEOF()Param: ()\t\nDesc: Wide end-of-file (constant)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">WEOF</Data></Cell>
    <Cell><Data ss:Type="String">Wide end-of-file (constant)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">constant</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wctrans_t()Param: ()\t\nDesc: Wide character transformation (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">wctrans_t</Data></Cell>
    <Cell><Data ss:Type="String">Wide character transformation (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wctype_t()Param: ()\t\nDesc: Wide character type (type)\t\nProto: no-proto\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">wctype_t</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">array(T)Param: (Type of the elements contained.)\t\nDesc: Array class (class template)\t\nProto: template &lt; class T, size_t N &gt; class array;\t\n[cpp11 ] [&lt;array&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class T, size_t N &gt; class array;</Data></Cell>
    <Cell><Data ss:Type="String">array</Data></Cell>
    <Cell><Data ss:Type="String">Array class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the elements contained.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;array&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Array header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">deque(T)Param: (Type of the elements.)\t\nDesc: Double ended queue (class template)\t\nProto: template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque;\t\n[cpp98 cpp11 ] [&lt;deque&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque;</Data></Cell>
    <Cell><Data ss:Type="String">deque</Data></Cell>
    <Cell><Data ss:Type="String">Double ended queue (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the elements.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;deque&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Deque header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">forward_list(T)Param: (Type of the elements.)\t\nDesc: Forward list (class template)\t\nProto: template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class forward_list;\t\n[cpp11 ] [&lt;forward_list&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class forward_list;</Data></Cell>
    <Cell><Data ss:Type="String">forward_list</Data></Cell>
    <Cell><Data ss:Type="String">Forward list (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the elements.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;forward_list&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Forward list</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">map(Key)Param: (Type of the keys.)\t\nDesc: Map (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [&lt;map&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">map</Data></Cell>
    <Cell><Data ss:Type="String">Map (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Key)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the keys.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;map&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Map header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">multimap(Key)Param: (Type of the keys.)\t\nDesc: Multiple-key map (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [&lt;map&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">multimap</Data></Cell>
    <Cell><Data ss:Type="String">Multiple-key map (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Key)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the keys.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;map&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Map header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">priority_queue(T)Param: (Type of the elements.)\t\nDesc: Priority queue (class template)\t\nProto: template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;\t\n[cpp98 cpp11 ] [&lt;queue&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;</Data></Cell>
    <Cell><Data ss:Type="String">priority_queue</Data></Cell>
    <Cell><Data ss:Type="String">Priority queue (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the elements.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;queue&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Queue header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">multiset(T)Param: (Type of the elements.)\t\nDesc: Multiple-key set (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [&lt;set&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">multiset</Data></Cell>
    <Cell><Data ss:Type="String">Multiple-key set (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the elements.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;set&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Set header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">stack(T)Param: (Type of the elements.)\t\nDesc: LIFO stack (class template)\t\nProto: template &lt;class T, class Container = deque&lt;T&gt; &gt; class stack;\t\n[cpp98 cpp11 ] [&lt;stack&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class Container = deque&lt;T&gt; &gt; class stack;</Data></Cell>
    <Cell><Data ss:Type="String">stack</Data></Cell>
    <Cell><Data ss:Type="String">LIFO stack (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the elements.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;stack&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Stack header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">unordered_map(Key)Param: (Type of the key values.)\t\nDesc: Unordered Map (class template)\t\nProto: long-proto\t\n[cpp11 ] [&lt;unordered_map&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">unordered_map</Data></Cell>
    <Cell><Data ss:Type="String">Unordered Map (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Key)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the key values.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;unordered_map&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Unordered map header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">unordered_multimap(Key)Param: (Type of the key values.)\t\nDesc: Unordered Multimap (class template)\t\nProto: long-proto\t\n[cpp11 ] [&lt;unordered_map&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">unordered_multimap</Data></Cell>
    <Cell><Data ss:Type="String">Unordered Multimap (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Key)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the key values.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;unordered_map&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Unordered map header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">unordered_multiset(Key)Param: (Type of the elements.)\t\nDesc: Unordered Multiset (class template)\t\nProto: long-proto\t\n[cpp11 ] [&lt;unordered_set&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">unordered_multiset</Data></Cell>
    <Cell><Data ss:Type="String">Unordered Multiset (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Key)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the elements.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;unordered_set&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Unordered set header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">unordered_set(Key)Param: (Type of the elements.)\t\nDesc: Unordered Set (class template)\t\nProto: long-proto\t\n[cpp11 ] [&lt;unordered_set&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">unordered_set</Data></Cell>
    <Cell><Data ss:Type="String">Unordered Set (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Key)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the elements.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;unordered_set&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Unordered set header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vector(T)Param: (Type of the elements.)\t\nDesc: Vector (class template)\t\nProto: template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector;\t\n[cpp98 cpp11 ] [&lt;vector&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector;</Data></Cell>
    <Cell><Data ss:Type="String">vector</Data></Cell>
    <Cell><Data ss:Type="String">Vector (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the elements.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;vector&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Vector header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_filebuf(charT)Param: (Character type.)\t\nDesc: File stream buffer (class template)\t\nProto: template &lt; class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_filebuf;\t\n[cpp98 cpp11 ] [&lt;fstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_filebuf;</Data></Cell>
    <Cell><Data ss:Type="String">basic_filebuf</Data></Cell>
    <Cell><Data ss:Type="String">File stream buffer (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;fstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">File streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_fstream(charT)Param: (Character type.)\t\nDesc: File stream (class template)\t\nProto: template &lt; class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_fstream;\t\n[cpp98 cpp11 ] [&lt;fstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_fstream;</Data></Cell>
    <Cell><Data ss:Type="String">basic_fstream</Data></Cell>
    <Cell><Data ss:Type="String">File stream (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;fstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">File streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_ifstream(charT)Param: (Character type.)\t\nDesc: Input file stream (class template)\t\nProto: template &lt; class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_ifstream;\t\n[cpp98 cpp11 ] [&lt;fstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_ifstream;</Data></Cell>
    <Cell><Data ss:Type="String">basic_ifstream</Data></Cell>
    <Cell><Data ss:Type="String">Input file stream (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;fstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">File streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_ofstream(charT)Param: (Character type.)\t\nDesc: Output file stream (class template)\t\nProto: template &lt; class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_ofstream;\t\n[cpp98 cpp11 ] [&lt;fstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_ofstream;</Data></Cell>
    <Cell><Data ss:Type="String">basic_ofstream</Data></Cell>
    <Cell><Data ss:Type="String">Output file stream (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;fstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">File streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wfilebuf()Param: ()\t\nDesc: File stream buffer (wide) (class)\t\nProto: typedef basic_filebuf&lt;wchar_t&gt; wfilebuf;\t\n[cpp98 cpp11] [&lt;fstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_filebuf&lt;wchar_t&gt; wfilebuf;</Data></Cell>
    <Cell><Data ss:Type="String">wfilebuf</Data></Cell>
    <Cell><Data ss:Type="String">File stream buffer (wide) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;fstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">File streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wfstream()Param: ()\t\nDesc: File stream (wide) (class)\t\nProto: typedef basic_fstream&lt;wchar_t&gt; wfstream;\t\n[cpp98 cpp11] [&lt;fstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_fstream&lt;wchar_t&gt; wfstream;</Data></Cell>
    <Cell><Data ss:Type="String">wfstream</Data></Cell>
    <Cell><Data ss:Type="String">File stream (wide) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;fstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">File streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wifstream()Param: ()\t\nDesc: Input file stream (wide) (class)\t\nProto: typedef basic_ifstream&lt;wchar_t&gt; wifstream;\t\n[cpp98 cpp11] [&lt;fstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_ifstream&lt;wchar_t&gt; wifstream;</Data></Cell>
    <Cell><Data ss:Type="String">wifstream</Data></Cell>
    <Cell><Data ss:Type="String">Input file stream (wide) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;fstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">File streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wofstream()Param: ()\t\nDesc: Output file stream (wide) (class)\t\nProto: typedef basic_ofstream&lt;wchar_t&gt; wofstream;\t\n[cpp98 cpp11] [&lt;fstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_ofstream&lt;wchar_t&gt; wofstream;</Data></Cell>
    <Cell><Data ss:Type="String">wofstream</Data></Cell>
    <Cell><Data ss:Type="String">Output file stream (wide) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;fstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">File streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_ios(charT)Param: (Character type.)\t\nDesc: Base class for streams (type-dependent components) (class template)\t\nProto: template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_ios;\t\n[cpp98 cpp11 ] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_ios;</Data></Cell>
    <Cell><Data ss:Type="String">basic_ios</Data></Cell>
    <Cell><Data ss:Type="String">Base class for streams (type-dependent components) (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ios_base()Param: ()\t\nDesc: Base class for streams (class)\t\nProto: class ios_base;\t\n[arm cpp98 cpp11 ] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class ios_base;</Data></Cell>
    <Cell><Data ss:Type="String">ios_base</Data></Cell>
    <Cell><Data ss:Type="String">Base class for streams (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">io_errc()Param: ()\t\nDesc: Input/output error conditions (enum class)\t\nProto: enum class io_errc;\t\n[cpp11 ] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">enum class io_errc;</Data></Cell>
    <Cell><Data ss:Type="String">io_errc</Data></Cell>
    <Cell><Data ss:Type="String">Input/output error conditions (enum class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">enum class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">streamoff()Param: ()\t\nDesc: Stream offset type (type)\t\nProto: no-proto\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">streamoff</Data></Cell>
    <Cell><Data ss:Type="String">Stream offset type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">streampos()Param: ()\t\nDesc: Stream position type (type)\t\nProto: typedef fpos&lt;mbstate_t&gt; streampos;\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef fpos&lt;mbstate_t&gt; streampos;</Data></Cell>
    <Cell><Data ss:Type="String">streampos</Data></Cell>
    <Cell><Data ss:Type="String">Stream position type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">streamsize()Param: ()\t\nDesc: Stream size type (type)\t\nProto: no-proto\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">streamsize</Data></Cell>
    <Cell><Data ss:Type="String">Stream size type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wios()Param: ()\t\nDesc: Base class for wide character streams (class)\t\nProto: typedef basic_ios&lt;wchar_t&gt; ios;\t\n[cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_ios&lt;wchar_t&gt; ios;</Data></Cell>
    <Cell><Data ss:Type="String">wios</Data></Cell>
    <Cell><Data ss:Type="String">Base class for wide character streams (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wstreampos()Param: ()\t\nDesc: Wide stream position type (type)\t\nProto: typedef fpos&lt;mbstate_t&gt; wstreampos;\t\n[cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef fpos&lt;mbstate_t&gt; wstreampos;</Data></Cell>
    <Cell><Data ss:Type="String">wstreampos</Data></Cell>
    <Cell><Data ss:Type="String">Wide stream position type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">cerr()Param: ()\t\nDesc: Standard output stream for errors (object)\t\nProto: extern ostream cerr;\t\n[arm cpp98 cpp11] [&lt;iostream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">extern ostream cerr;</Data></Cell>
    <Cell><Data ss:Type="String">cerr</Data></Cell>
    <Cell><Data ss:Type="String">Standard output stream for errors (object)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">object</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iostream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard Input / Output Streams Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">cin()Param: ()\t\nDesc: Standard input stream (object)\t\nProto: extern istream cin;\t\n[arm cpp98 cpp11] [&lt;iostream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">extern istream cin;</Data></Cell>
    <Cell><Data ss:Type="String">cin</Data></Cell>
    <Cell><Data ss:Type="String">Standard input stream (object)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">object</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iostream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard Input / Output Streams Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">clog()Param: ()\t\nDesc: Standard output stream for logging (object)\t\nProto: extern ostream clog;\t\n[arm cpp98 cpp11] [&lt;iostream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">extern ostream clog;</Data></Cell>
    <Cell><Data ss:Type="String">clog</Data></Cell>
    <Cell><Data ss:Type="String">Standard output stream for logging (object)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">object</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iostream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard Input / Output Streams Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">cout()Param: ()\t\nDesc: Standard output stream (object)\t\nProto: extern ostream cout;\t\n[arm cpp98 cpp11] [&lt;iostream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">extern ostream cout;</Data></Cell>
    <Cell><Data ss:Type="String">cout</Data></Cell>
    <Cell><Data ss:Type="String">Standard output stream (object)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">object</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iostream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard Input / Output Streams Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcerr()Param: ()\t\nDesc: Standard output stream for errors (wide-oriented) (object)\t\nProto: extern basic_ostream&lt;wchar_t&gt; wcerr;\t\n[cpp98 cpp11] [&lt;iostream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">extern basic_ostream&lt;wchar_t&gt; wcerr;</Data></Cell>
    <Cell><Data ss:Type="String">wcerr</Data></Cell>
    <Cell><Data ss:Type="String">Standard output stream for errors (wide-oriented) (object)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">object</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iostream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard Input / Output Streams Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcin()Param: ()\t\nDesc: Standard input stream (wide) (object)\t\nProto: extern basic_istream&lt;wchar_t&gt; wcin;\t\n[cpp98 cpp11] [&lt;iostream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">extern basic_istream&lt;wchar_t&gt; wcin;</Data></Cell>
    <Cell><Data ss:Type="String">wcin</Data></Cell>
    <Cell><Data ss:Type="String">Standard input stream (wide) (object)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">object</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iostream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard Input / Output Streams Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wclog()Param: ()\t\nDesc: Standard output stream for logging (wide) (object)\t\nProto: extern basic_ostream&lt;wchar_t&gt; wclog;\t\n[cpp98 cpp11] [&lt;iostream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">extern basic_ostream&lt;wchar_t&gt; wclog;</Data></Cell>
    <Cell><Data ss:Type="String">wclog</Data></Cell>
    <Cell><Data ss:Type="String">Standard output stream for logging (wide) (object)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">object</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iostream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard Input / Output Streams Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcout()Param: ()\t\nDesc: Standard output stream (wide) (object)\t\nProto: extern basic_ostream&lt;wchar_t&gt; wcout;\t\n[cpp98 cpp11] [&lt;iostream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">extern basic_ostream&lt;wchar_t&gt; wcout;</Data></Cell>
    <Cell><Data ss:Type="String">wcout</Data></Cell>
    <Cell><Data ss:Type="String">Standard output stream (wide) (object)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">object</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iostream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard Input / Output Streams Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_iostream(charT)Param: (Character type.)\t\nDesc: Input/output stream (class template)\t\nProto: template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt; class basic_iostream;\t\n[cpp98 cpp11 ] [&lt;istream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt; class basic_iostream;</Data></Cell>
    <Cell><Data ss:Type="String">basic_iostream</Data></Cell>
    <Cell><Data ss:Type="String">Input/output stream (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;istream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input stream</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_istream(charT)Param: (Character type.)\t\nDesc: Input stream (class template)\t\nProto: template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_istream;\t\n[cpp98 cpp11 ] [&lt;istream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_istream;</Data></Cell>
    <Cell><Data ss:Type="String">basic_istream</Data></Cell>
    <Cell><Data ss:Type="String">Input stream (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;istream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input stream</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wiostream()Param: ()\t\nDesc: Input/output stream (wide) (class)\t\nProto: typedef basic_iostream&lt;wchar_t&gt; wiostream;\t\n[arm cpp98 cpp11] [&lt;istream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_iostream&lt;wchar_t&gt; wiostream;</Data></Cell>
    <Cell><Data ss:Type="String">wiostream</Data></Cell>
    <Cell><Data ss:Type="String">Input/output stream (wide) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;istream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input stream</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wistream()Param: ()\t\nDesc: Input stream (wide) (class)\t\nProto: typedef basic_istream&lt;wchar_t&gt; wistream;\t\n[cpp98 cpp11] [&lt;istream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_istream&lt;wchar_t&gt; wistream;</Data></Cell>
    <Cell><Data ss:Type="String">wistream</Data></Cell>
    <Cell><Data ss:Type="String">Input stream (wide) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;istream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input stream</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_ostream(charT)Param: (Character type.)\t\nDesc: Output stream (class)\t\nProto: template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_ostream;\t\n[cpp98 cpp11 ] [&lt;ostream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_ostream;</Data></Cell>
    <Cell><Data ss:Type="String">basic_ostream</Data></Cell>
    <Cell><Data ss:Type="String">Output stream (class)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;ostream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Output stream</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wostream()Param: ()\t\nDesc: Output stream (wide) (class)\t\nProto: typedef basic_ostream&lt;wchar_t&gt; wostream;\t\n[arm cpp98 cpp11] [&lt;ostream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_ostream&lt;wchar_t&gt; wostream;</Data></Cell>
    <Cell><Data ss:Type="String">wostream</Data></Cell>
    <Cell><Data ss:Type="String">Output stream (wide) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ostream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Output stream</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_istringstream(charT)Param: (Character type used by both the stream and the basic_string objects it accepts or generates.)\t\nDesc: Input string stream (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [&lt;sstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">basic_istringstream</Data></Cell>
    <Cell><Data ss:Type="String">Input string stream (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type used by both the stream and the basic_string objects it accepts or generates.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;sstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">String streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_ostringstream(charT)Param: (Character type used by both the stream and the basic_string objects it accepts or generates.)\t\nDesc: Output string stream (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [&lt;sstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">basic_ostringstream</Data></Cell>
    <Cell><Data ss:Type="String">Output string stream (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type used by both the stream and the basic_string objects it accepts or generates.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;sstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">String streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_stringbuf(charT)Param: (Character type used by both the stream buffer and the basic_string objects it accepts or generates.)\t\nDesc: String stream buffer (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [&lt;sstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">basic_stringbuf</Data></Cell>
    <Cell><Data ss:Type="String">String stream buffer (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type used by both the stream buffer and the basic_string objects it accepts or generates.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;sstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">String streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_stringstream(charT)Param: (Character type used by both the stream and the basic_string objects it accepts or generates.)\t\nDesc: String stream (class template)\t\nProto: long-proto\t\n[cpp98 cpp11 ] [&lt;sstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">basic_stringstream</Data></Cell>
    <Cell><Data ss:Type="String">String stream (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type used by both the stream and the basic_string objects it accepts or generates.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;sstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">String streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wistringstream()Param: ()\t\nDesc: Input string stream (wide) (class)\t\nProto: typedef basic_istringstream&lt;wchar_t&gt; wistringstream;\t\n[cpp98 cpp11] [&lt;sstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_istringstream&lt;wchar_t&gt; wistringstream;</Data></Cell>
    <Cell><Data ss:Type="String">wistringstream</Data></Cell>
    <Cell><Data ss:Type="String">Input string stream (wide) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;sstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">String streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wostringstream()Param: ()\t\nDesc: Output string stream (wide) (class)\t\nProto: typedef basic_ostringstream&lt;wchar_t&gt; wostringstream;\t\n[cpp98 cpp11] [&lt;sstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_ostringstream&lt;wchar_t&gt; wostringstream;</Data></Cell>
    <Cell><Data ss:Type="String">wostringstream</Data></Cell>
    <Cell><Data ss:Type="String">Output string stream (wide) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;sstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">String streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wstringbuf()Param: ()\t\nDesc: String stream buffer (wide) (class)\t\nProto: typedef basic_stringbuf&lt;wchar_t&gt; wstringbuf;\t\n[cpp98 cpp11] [&lt;sstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_stringbuf&lt;wchar_t&gt; wstringbuf;</Data></Cell>
    <Cell><Data ss:Type="String">wstringbuf</Data></Cell>
    <Cell><Data ss:Type="String">String stream buffer (wide) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;sstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">String streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wstringstream()Param: ()\t\nDesc: Input/output string stream (wide) (class)\t\nProto: typedef basic_stringstream&lt;wchar_t&gt; wstringstream;\t\n[cpp98 cpp11] [&lt;sstream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_stringstream&lt;wchar_t&gt; wstringstream;</Data></Cell>
    <Cell><Data ss:Type="String">wstringstream</Data></Cell>
    <Cell><Data ss:Type="String">Input/output string stream (wide) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;sstream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">String streams</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_streambuf(charT)Param: (Character type.)\t\nDesc: Base buffer class for streams (class template)\t\nProto: template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_streambuf;\t\n[cpp98 cpp11 ] [&lt;streambuf&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;\t\nclass basic_streambuf;</Data></Cell>
    <Cell><Data ss:Type="String">basic_streambuf</Data></Cell>
    <Cell><Data ss:Type="String">Base buffer class for streams (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;streambuf&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Stream buffer</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wstreambuf()Param: ()\t\nDesc: Base buffer class for streams (wide) (class)\t\nProto: typedef basic_streambuf&lt;wchar_t&gt; wstreambuf;\t\n[cpp98 cpp11] [&lt;streambuf&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_streambuf&lt;wchar_t&gt; wstreambuf;</Data></Cell>
    <Cell><Data ss:Type="String">wstreambuf</Data></Cell>
    <Cell><Data ss:Type="String">Base buffer class for streams (wide) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;streambuf&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Stream buffer</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_flag()Param: ()\t\nDesc: Atomic flag (class)\t\nProto: struct atomic_flag;\t\n[cpp11 ] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct atomic_flag;</Data></Cell>
    <Cell><Data ss:Type="String">atomic_flag</Data></Cell>
    <Cell><Data ss:Type="String">Atomic flag (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">memory_order()Param: ()\t\nDesc: Memory order (enum)\t\nProto: enum memory_order;\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">enum memory_order;</Data></Cell>
    <Cell><Data ss:Type="String">memory_order</Data></Cell>
    <Cell><Data ss:Type="String">Memory order (enum)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">enum</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ATOMIC_FLAG_INIT()Param: ()\t\nDesc: Initialization of atomic flag (macro)\t\nProto: ATOMIC_FLAG_INIT\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">ATOMIC_FLAG_INIT</Data></Cell>
    <Cell><Data ss:Type="String">ATOMIC_FLAG_INIT</Data></Cell>
    <Cell><Data ss:Type="String">Initialization of atomic flag (macro)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ATOMIC_VAR_INIT(val)Param: (Value to use for initialization.)\t\nDesc: Initialization of atomic variable (macro)\t\nProto: ATOMIC_VAR_INIT(val)\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">ATOMIC_VAR_INIT(val)</Data></Cell>
    <Cell><Data ss:Type="String">ATOMIC_VAR_INIT</Data></Cell>
    <Cell><Data ss:Type="String">Initialization of atomic variable (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(val)</Data></Cell>
    <Cell><Data ss:Type="String">Value to use for initialization.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_compare_exchange_strong(obj)Param: (Pointer to an atomic object.)\t\nDesc: Compare and exchange contained value (strong) (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_compare_exchange_strong</Data></Cell>
    <Cell><Data ss:Type="String">Compare and exchange contained value (strong) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_compare_exchange_strong_explicit(obj)Param: (Pointer to an atomic object.)\t\nDesc: Compare and exchange contained value (strong, explicit) (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_compare_exchange_strong_explicit</Data></Cell>
    <Cell><Data ss:Type="String">Compare and exchange contained value (strong, explicit) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_compare_exchange_weak(obj)Param: (Pointer to an atomic object.)\t\nDesc: Compare and exchange contained value (weak) (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_compare_exchange_weak</Data></Cell>
    <Cell><Data ss:Type="String">Compare and exchange contained value (weak) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_compare_exchange_weak_explicit(obj)Param: (Pointer to an atomic object.)\t\nDesc: Compare and exchange contained value (weak, explicit) (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_compare_exchange_weak_explicit</Data></Cell>
    <Cell><Data ss:Type="String">Compare and exchange contained value (weak, explicit) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_exchange(obj)Param: (Pointer to an atomic object.)\t\nDesc: Read and modify contained value (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_exchange</Data></Cell>
    <Cell><Data ss:Type="String">Read and modify contained value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_exchange_explicit(obj)Param: (Pointer to an atomic object.)\t\nDesc: Read and modify contained value (explicit memory order) (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_exchange_explicit</Data></Cell>
    <Cell><Data ss:Type="String">Read and modify contained value (explicit memory order) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_fetch_add(obj)Param: (Pointer to an atomic object that contains either an integral or a pointer value.)\t\nDesc: Add to contained value (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_fetch_add</Data></Cell>
    <Cell><Data ss:Type="String">Add to contained value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object that contains either an integral or a pointer value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_fetch_add_explicit(obj)Param: (Pointer to an atomic object that contains either an integral or a pointer value.)\t\nDesc: Add to contained value (explicit memory order) (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_fetch_add_explicit</Data></Cell>
    <Cell><Data ss:Type="String">Add to contained value (explicit memory order) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object that contains either an integral or a pointer value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_fetch_and(obj)Param: (Pointer to an atomic object that contains an integral value.)\t\nDesc: Apply bitwise AND to contained value (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_fetch_and</Data></Cell>
    <Cell><Data ss:Type="String">Apply bitwise AND to contained value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object that contains an integral value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_fetch_and_explicit(obj)Param: (Pointer to an atomic object that contains an integral value.)\t\nDesc: Apply bitwise AND to contained value (explicit memory order) (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_fetch_and_explicit</Data></Cell>
    <Cell><Data ss:Type="String">Apply bitwise AND to contained value (explicit memory order) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object that contains an integral value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_fetch_or(obj)Param: (Pointer to an atomic object that contains an integral value.)\t\nDesc: Apply bitwise OR to contained value (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_fetch_or</Data></Cell>
    <Cell><Data ss:Type="String">Apply bitwise OR to contained value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object that contains an integral value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_fetch_or_explicit(obj)Param: (Pointer to an atomic object that contains an integral value.)\t\nDesc: Apply bitwise OR to contained value (explicit memory order) (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_fetch_or_explicit</Data></Cell>
    <Cell><Data ss:Type="String">Apply bitwise OR to contained value (explicit memory order) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object that contains an integral value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_fetch_sub(obj)Param: (Pointer to an atomic object that contains either an integral or a pointer value.)\t\nDesc: Subtract from contained value (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_fetch_sub</Data></Cell>
    <Cell><Data ss:Type="String">Subtract from contained value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object that contains either an integral or a pointer value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_fetch_sub_explicit(obj)Param: (Pointer to an atomic object that contains either an integral or a pointer value.)\t\nDesc: Subtract from contained value (explicit memory order) (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_fetch_sub_explicit</Data></Cell>
    <Cell><Data ss:Type="String">Subtract from contained value (explicit memory order) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object that contains either an integral or a pointer value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_fetch_xor(obj)Param: (Pointer to an atomic object that contains an integral value.)\t\nDesc: Apply bitwise XOR to contained value (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_fetch_xor</Data></Cell>
    <Cell><Data ss:Type="String">Apply bitwise XOR to contained value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object that contains an integral value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_fetch_xor_explicit(obj)Param: (Pointer to an atomic object that contains an integral value.)\t\nDesc: Apply bitwise XOR to contained value (explicit memory order) (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_fetch_xor_explicit</Data></Cell>
    <Cell><Data ss:Type="String">Apply bitwise XOR to contained value (explicit memory order) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object that contains an integral value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_init(obj)Param: (Pointer to an atomic object.)\t\nDesc: Initialize atomic object (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_init</Data></Cell>
    <Cell><Data ss:Type="String">Initialize atomic object (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_is_lock_free(obj)Param: (Pointer to an atomic object.)\t\nDesc: Is lock-free (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_is_lock_free</Data></Cell>
    <Cell><Data ss:Type="String">Is lock-free (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_load(obj)Param: (Pointer to an atomic object.)\t\nDesc: Read contained value (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_load</Data></Cell>
    <Cell><Data ss:Type="String">Read contained value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_load_explicit(obj)Param: (Pointer to an atomic object.)\t\nDesc: Read contained value (explicit memory order) (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_load_explicit</Data></Cell>
    <Cell><Data ss:Type="String">Read contained value (explicit memory order) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_store(obj)Param: (Pointer to an atomic object.)\t\nDesc: Modify contained value (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_store</Data></Cell>
    <Cell><Data ss:Type="String">Modify contained value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_store_explicit(obj)Param: (Pointer to an atomic object.)\t\nDesc: Modify contained value (explicit memory order) (function)\t\nProto: long-proto\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">atomic_store_explicit</Data></Cell>
    <Cell><Data ss:Type="String">Modify contained value (explicit memory order) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an atomic object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">condition_variable()Param: ()\t\nDesc: Condition variable (class)\t\nProto: class condition_variable;\t\n[cpp11 ] [&lt;condition_variable&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class condition_variable;</Data></Cell>
    <Cell><Data ss:Type="String">condition_variable</Data></Cell>
    <Cell><Data ss:Type="String">Condition variable (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;condition_variable&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Condition variable</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">condition_variable_any()Param: ()\t\nDesc: Condition variable (any lock) (class)\t\nProto: class condition_variable_any;\t\n[cpp11 ] [&lt;condition_variable&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class condition_variable_any;</Data></Cell>
    <Cell><Data ss:Type="String">condition_variable_any</Data></Cell>
    <Cell><Data ss:Type="String">Condition variable (any lock) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;condition_variable&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Condition variable</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">cv_status()Param: ()\t\nDesc: Condition variable status (enum class)\t\nProto: enum class cv_status;\t\n[cpp11] [&lt;condition_variable&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">enum class cv_status;</Data></Cell>
    <Cell><Data ss:Type="String">cv_status</Data></Cell>
    <Cell><Data ss:Type="String">Condition variable status (enum class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">enum class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;condition_variable&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Condition variable</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">future()Param: ()\t\nDesc: Future (class template)\t\nProto: template &lt;class T&gt; future;template &lt;class R&amp;&gt; future&lt;R&amp;&gt;; \t\n[cpp11 ] [&lt;future&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; future;template &lt;class R&amp;&gt; future&lt;R&amp;&gt;; </Data></Cell>
    <Cell><Data ss:Type="String">future</Data></Cell>
    <Cell><Data ss:Type="String">Future (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;future&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Future</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">future_error()Param: ()\t\nDesc: Future error exception (class)\t\nProto: class future_error : public logic_error;\t\n[cpp11 ] [&lt;future&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class future_error : public logic_error;</Data></Cell>
    <Cell><Data ss:Type="String">future_error</Data></Cell>
    <Cell><Data ss:Type="String">Future error exception (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;future&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Future</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">packaged_task()Param: ()\t\nDesc: Packaged task (class template)\t\nProto: template &lt;class T&gt; packaged_task;\t\n[cpp11 ] [&lt;future&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; packaged_task;</Data></Cell>
    <Cell><Data ss:Type="String">packaged_task</Data></Cell>
    <Cell><Data ss:Type="String">Packaged task (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;future&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Future</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">promise()Param: ()\t\nDesc: Promise (class template)\t\nProto: template &lt;class T&gt; promise;template &lt;class R&amp;&gt; promise&lt;R&amp;&gt;; \t\n[cpp11 ] [&lt;future&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; promise;template &lt;class R&amp;&gt; promise&lt;R&amp;&gt;; </Data></Cell>
    <Cell><Data ss:Type="String">promise</Data></Cell>
    <Cell><Data ss:Type="String">Promise (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;future&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Future</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">shared_future()Param: ()\t\nDesc: Shared future (class template)\t\nProto: template &lt;class T&gt; shared_future;template &lt;class R&amp;&gt; shared_future&lt;R&amp;&gt;; \t\n[cpp11 ] [&lt;future&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; shared_future;template &lt;class R&amp;&gt; shared_future&lt;R&amp;&gt;; </Data></Cell>
    <Cell><Data ss:Type="String">shared_future</Data></Cell>
    <Cell><Data ss:Type="String">Shared future (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;future&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Future</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">future_errc()Param: ()\t\nDesc: Error conditions for future objects (enum class)\t\nProto: enum class future_errc;\t\n[cpp11 ] [&lt;future&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">enum class future_errc;</Data></Cell>
    <Cell><Data ss:Type="String">future_errc</Data></Cell>
    <Cell><Data ss:Type="String">Error conditions for future objects (enum class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">enum class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;future&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Future</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">future_status()Param: ()\t\nDesc: Return value for timed future operations (enum class)\t\nProto: enum class future_status;\t\n[cpp11] [&lt;future&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">enum class future_status;</Data></Cell>
    <Cell><Data ss:Type="String">future_status</Data></Cell>
    <Cell><Data ss:Type="String">Return value for timed future operations (enum class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">enum class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;future&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Future</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">launch()Param: ()\t\nDesc: Launching policy for async (enum class)\t\nProto: enum class launch;\t\n[cpp11] [&lt;future&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">enum class launch;</Data></Cell>
    <Cell><Data ss:Type="String">launch</Data></Cell>
    <Cell><Data ss:Type="String">Launching policy for async (enum class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">enum class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;future&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Future</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">async(policy)Param: ()\t\nDesc: Call function asynchronously (function template)\t\nProto: long-proto\t\n[] [&lt;future&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">async</Data></Cell>
    <Cell><Data ss:Type="String">Call function asynchronously (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(policy)</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">enum class</Data></Cell>
    <Cell ss:Index="10"><Data ss:Type="String">&lt;future&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Future</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">adopt_lock_t()Param: ()\t\nDesc: Type of adopt_lock (class)\t\nProto: struct adopt_lock_t {};\t\n[cpp11] [&lt;mutex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct adopt_lock_t {};</Data></Cell>
    <Cell><Data ss:Type="String">adopt_lock_t</Data></Cell>
    <Cell><Data ss:Type="String">Type of adopt_lock (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;mutex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Mutex</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">defer_lock_t()Param: ()\t\nDesc: Type of defer_lock (class)\t\nProto: struct defer_lock_t {};\t\n[cpp11] [&lt;mutex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct defer_lock_t {};</Data></Cell>
    <Cell><Data ss:Type="String">defer_lock_t</Data></Cell>
    <Cell><Data ss:Type="String">Type of defer_lock (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;mutex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Mutex</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">lock_guard(Mutex)Param: (A mutex-like type.)\t\nDesc: Lock guard (class template)\t\nProto: template &lt;class Mutex&gt; class lock_guard;\t\n[cpp11 ] [&lt;mutex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Mutex&gt; class lock_guard;</Data></Cell>
    <Cell><Data ss:Type="String">lock_guard</Data></Cell>
    <Cell><Data ss:Type="String">Lock guard (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Mutex)</Data></Cell>
    <Cell><Data ss:Type="String">A mutex-like type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;mutex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Mutex</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mutex()Param: ()\t\nDesc: Mutex class (class)\t\nProto: class mutex;\t\n[cpp11 ] [&lt;mutex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class mutex;</Data></Cell>
    <Cell><Data ss:Type="String">mutex</Data></Cell>
    <Cell><Data ss:Type="String">Mutex class (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;mutex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Mutex</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">once_flag()Param: ()\t\nDesc: Flag argument type for call_once (class)\t\nProto: struct once_flag;\t\n[cpp11] [&lt;mutex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct once_flag;</Data></Cell>
    <Cell><Data ss:Type="String">once_flag</Data></Cell>
    <Cell><Data ss:Type="String">Flag argument type for call_once (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;mutex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Mutex</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">recursive_mutex()Param: ()\t\nDesc: Recursive mutex class (class)\t\nProto: class recursive_mutex;\t\n[cpp11 ] [&lt;mutex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class recursive_mutex;</Data></Cell>
    <Cell><Data ss:Type="String">recursive_mutex</Data></Cell>
    <Cell><Data ss:Type="String">Recursive mutex class (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;mutex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Mutex</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">recursive_timed_mutex()Param: ()\t\nDesc: Recursive timed mutex (class)\t\nProto: class recursive_timed_mutex;\t\n[cpp11 ] [&lt;mutex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class recursive_timed_mutex;</Data></Cell>
    <Cell><Data ss:Type="String">recursive_timed_mutex</Data></Cell>
    <Cell><Data ss:Type="String">Recursive timed mutex (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;mutex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Mutex</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">try_to_lock_t()Param: ()\t\nDesc: Type of try_to_lock (class)\t\nProto: struct try_to_lock_t {};\t\n[cpp11] [&lt;mutex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct try_to_lock_t {};</Data></Cell>
    <Cell><Data ss:Type="String">try_to_lock_t</Data></Cell>
    <Cell><Data ss:Type="String">Type of try_to_lock (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;mutex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Mutex</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">unique_lock(Mutex)Param: (A mutex-like type.)\t\nDesc: Unique lock (class template)\t\nProto: template &lt;class Mutex&gt; class unique_lock;\t\n[cpp11 ] [&lt;mutex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Mutex&gt; class unique_lock;</Data></Cell>
    <Cell><Data ss:Type="String">unique_lock</Data></Cell>
    <Cell><Data ss:Type="String">Unique lock (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Mutex)</Data></Cell>
    <Cell><Data ss:Type="String">A mutex-like type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;mutex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Mutex</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">this_thread()Param: ()\t\nDesc: This thread (namespace)\t\nProto: no-proto\t\n[cpp11 ] [&lt;thread&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">this_thread</Data></Cell>
    <Cell><Data ss:Type="String">This thread (namespace)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">namespace</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;thread&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Thread</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">adjacent_find(first, last)Param: (Forward iterators to the initial and final positions of the searched sequence.)\t\nDesc: Find equal adjacent elements in range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">adjacent_find</Data></Cell>
    <Cell><Data ss:Type="String">Find equal adjacent elements in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of the searched sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">binary_search(first, last)Param: (Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.)\t\nDesc: Test if value exists in sorted sequence (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">binary_search</Data></Cell>
    <Cell><Data ss:Type="String">Test if value exists in sorted sequence (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">copy_backward(first, last)Param: (Bidirectional iterators to the initial and final positions in a sequence to be copied.)\t\nDesc: Copy range of elements backward (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">copy_backward</Data></Cell>
    <Cell><Data ss:Type="String">Copy range of elements backward (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Bidirectional iterators to the initial and final positions in a sequence to be copied.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">equal_range(first, last)Param: (Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.)\t\nDesc: Get subrange of equal elements (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">equal_range</Data></Cell>
    <Cell><Data ss:Type="String">Get subrange of equal elements (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">includes(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence (which is tested on whether it contains the second sequence).)\t\nDesc: Test whether sorted range includes another sorted range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">includes</Data></Cell>
    <Cell><Data ss:Type="String">Test whether sorted range includes another sorted range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the first sorted sequence (which is tested on whether it contains the second sequence).</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">inplace_merge(first)Param: (Bidirectional iterator to the initial position in the first sorted sequence to merge.)\t\nDesc: Merge consecutive sorted ranges (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">inplace_merge</Data></Cell>
    <Cell><Data ss:Type="String">Merge consecutive sorted ranges (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first)</Data></Cell>
    <Cell><Data ss:Type="String">Bidirectional iterator to the initial position in the first sorted sequence to merge.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_heap(first, last)Param: (RandomAccess iterators to the initial and final positions of the sequence.)\t\nDesc: Test if range is heap (function template)\t\nProto: long-proto\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">is_heap</Data></Cell>
    <Cell><Data ss:Type="String">Test if range is heap (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">RandomAccess iterators to the initial and final positions of the sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_heap_until(first, last)Param: (Random-access iterators to the initial and final positions in a sequence.)\t\nDesc: Find first element not in heap order (function template)\t\nProto: long-proto\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">is_heap_until</Data></Cell>
    <Cell><Data ss:Type="String">Find first element not in heap order (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Random-access iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_permutation(first1, last1)Param: (Input iterators to the initial and final positions of the first sequence.)\t\nDesc: Test whether range is permutation of another (function template)\t\nProto: long-proto\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">is_permutation</Data></Cell>
    <Cell><Data ss:Type="String">Test whether range is permutation of another (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the first sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_sorted(first, last)Param: (Forward iterators to the initial and final positions of the sequence.)\t\nDesc: Check whether range is sorted (function template)\t\nProto: long-proto\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">is_sorted</Data></Cell>
    <Cell><Data ss:Type="String">Check whether range is sorted (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of the sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_sorted_until(first, last)Param: (Forward iterators to the initial and final positions in a sequence.)\t\nDesc: Find first unsorted element in range (function template)\t\nProto: long-proto\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">is_sorted_until</Data></Cell>
    <Cell><Data ss:Type="String">Find first unsorted element in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">lexicographical_compare(first1, last1)Param: (Input iterators to the initial and final positions of the first sequence.)\t\nDesc: Lexicographical less-than comparison (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">lexicographical_compare</Data></Cell>
    <Cell><Data ss:Type="String">Lexicographical less-than comparison (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the first sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">lower_bound(first, last)Param: (Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.)\t\nDesc: Return iterator to lower bound (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">lower_bound</Data></Cell>
    <Cell><Data ss:Type="String">Return iterator to lower bound (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">make_heap(first, last)Param: (Random-access iterators to the initial and final positions of the sequence to be transformed into a heap.)\t\nDesc: Make heap from range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">make_heap</Data></Cell>
    <Cell><Data ss:Type="String">Make heap from range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Random-access iterators to the initial and final positions of the sequence to be transformed into a heap.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">max_element(first, last)Param: (Input iterators to the initial and final positions of the sequence to compare.)\t\nDesc: Return largest element in range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">max_element</Data></Cell>
    <Cell><Data ss:Type="String">Return largest element in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the sequence to compare.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">minmax_element(first, last)Param: (Input iterators to the initial and final positions of the sequence to compare.)\t\nDesc: Return smallest and largest elements in range (function template)\t\nProto: long-proto\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">minmax_element</Data></Cell>
    <Cell><Data ss:Type="String">Return smallest and largest elements in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the sequence to compare.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">min_element(first, last)Param: (Input iterators to the initial and final positions of the sequence to compare.)\t\nDesc: Return smallest element in range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">min_element</Data></Cell>
    <Cell><Data ss:Type="String">Return smallest element in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the sequence to compare.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mismatch(first1, last1)Param: (Input iterators to the initial and final positions of the first sequence.)\t\nDesc: Return first position where two ranges differ (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">mismatch</Data></Cell>
    <Cell><Data ss:Type="String">Return first position where two ranges differ (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the first sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">move_backward(first, last)Param: (Bidirectional iterators to the initial and final positions in a sequence to be moved.)\t\nDesc: Move range of elements backward (function template)\t\nProto: long-proto\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">move_backward</Data></Cell>
    <Cell><Data ss:Type="String">Move range of elements backward (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Bidirectional iterators to the initial and final positions in a sequence to be moved.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">next_permutation(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence.)\t\nDesc: Transform range to next permutation (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">next_permutation</Data></Cell>
    <Cell><Data ss:Type="String">Transform range to next permutation (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Bidirectional iterators to the initial and final positions of the sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">partial_sort(first, last)Param: (Random-access iterators to the initial and final positions of the sequence to be partially sorted.)\t\nDesc: Partially sort elements in range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">partial_sort</Data></Cell>
    <Cell><Data ss:Type="String">Partially sort elements in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Random-access iterators to the initial and final positions of the sequence to be partially sorted.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">partial_sort_copy(first, last)Param: (Input iterators to the initial and final positions of the sequence to copy from.)\t\nDesc: Copy and partially sort range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">partial_sort_copy</Data></Cell>
    <Cell><Data ss:Type="String">Copy and partially sort range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the sequence to copy from.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">partition_copy(first, last)Param: (Input iterators to the initial and final positions of the range to be copy-partitioned.)\t\nDesc: Partition range into two (function template)\t\nProto: long-proto\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">partition_copy</Data></Cell>
    <Cell><Data ss:Type="String">Partition range into two (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the range to be copy-partitioned.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">pop_heap(first, last)Param: (Random-access iterators to the initial and final positions of the heap to be shrank by one.)\t\nDesc: Pop element from heap range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">pop_heap</Data></Cell>
    <Cell><Data ss:Type="String">Pop element from heap range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Random-access iterators to the initial and final positions of the heap to be shrank by one.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">prev_permutation(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence.)\t\nDesc: Transform range to previous permutation (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">prev_permutation</Data></Cell>
    <Cell><Data ss:Type="String">Transform range to previous permutation (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Bidirectional iterators to the initial and final positions of the sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">push_heap(first, last)Param: (Random-access iterators to the initial and final positions of the new heap range, including the pushed element.)\t\nDesc: Push element into heap range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">push_heap</Data></Cell>
    <Cell><Data ss:Type="String">Push element into heap range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Random-access iterators to the initial and final positions of the new heap range, including the pushed element.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">replace_copy(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Copy range replacing value (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">replace_copy</Data></Cell>
    <Cell><Data ss:Type="String">Copy range replacing value (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">replace_copy_if(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Copy range replacing value (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">replace_copy_if</Data></Cell>
    <Cell><Data ss:Type="String">Copy range replacing value (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">search_n(first, last)Param: (Forward iterators to the initial and final positions of the searched sequence.)\t\nDesc: Search range for elements (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">search_n</Data></Cell>
    <Cell><Data ss:Type="String">Search range for elements (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of the searched sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">set_difference(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence.)\t\nDesc: Difference of two sorted ranges (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">set_difference</Data></Cell>
    <Cell><Data ss:Type="String">Difference of two sorted ranges (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the first sorted sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">set_intersection(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence.)\t\nDesc: Intersection of two sorted ranges (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">set_intersection</Data></Cell>
    <Cell><Data ss:Type="String">Intersection of two sorted ranges (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the first sorted sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">set_symmetric_difference(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence.)\t\nDesc: Symmetric difference of two sorted ranges (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">set_symmetric_difference</Data></Cell>
    <Cell><Data ss:Type="String">Symmetric difference of two sorted ranges (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the first sorted sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">set_union(first1, last1)Param: (Input iterators to the initial and final positions of the first sorted sequence.)\t\nDesc: Union of two sorted ranges (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">set_union</Data></Cell>
    <Cell><Data ss:Type="String">Union of two sorted ranges (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the first sorted sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">sort_heap(first, last)Param: (Random-access iterators to the initial and final positions of the heap range to be sorted.)\t\nDesc: Sort elements of heap (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">sort_heap</Data></Cell>
    <Cell><Data ss:Type="String">Sort elements of heap (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Random-access iterators to the initial and final positions of the heap range to be sorted.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">stable_partition(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence to partition.)\t\nDesc: Partition range in two - stable ordering (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">stable_partition</Data></Cell>
    <Cell><Data ss:Type="String">Partition range in two - stable ordering (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Bidirectional iterators to the initial and final positions of the sequence to partition.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">stable_sort(first, last)Param: (Random-access iterators to the initial and final positions of the sequence to be sorted.)\t\nDesc: Sort elements preserving order of equivalents (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">stable_sort</Data></Cell>
    <Cell><Data ss:Type="String">Sort elements preserving order of equivalents (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Random-access iterators to the initial and final positions of the sequence to be sorted.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">transform(first1, last1)Param: (Input iterators to the initial and final positions of the first sequence.)\t\nDesc: Transform range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">transform</Data></Cell>
    <Cell><Data ss:Type="String">Transform range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the first sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">unique_copy(first, last)Param: (Forward iterators to the initial and final positions in a sequence.)\t\nDesc: Copy range removing duplicates (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">unique_copy</Data></Cell>
    <Cell><Data ss:Type="String">Copy range removing duplicates (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">upper_bound(first, last)Param: (Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.)\t\nDesc: Return iterator to upper bound (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">upper_bound</Data></Cell>
    <Cell><Data ss:Type="String">Return iterator to upper bound (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bitset(N)Param: (Size of the bitset, in terms of number of bits.)\t\nDesc: Bitset (class template)\t\nProto: template &lt;size_t N&gt; class bitset;\t\n[cpp98 cpp11 ] [&lt;bitset&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;size_t N&gt; class bitset;</Data></Cell>
    <Cell><Data ss:Type="String">bitset</Data></Cell>
    <Cell><Data ss:Type="String">Bitset (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(N)</Data></Cell>
    <Cell><Data ss:Type="String">Size of the bitset, in terms of number of bits.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;bitset&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Bitset header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">common_type (duration)(Rep1, Rep2)Param: (Count representation types.)\t\nDesc: Specialization of common_type for duration (class template)\t\nProto: template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;\t\nclass common_type&lt;chrono::duration&lt;Rep1,Period1&gt;,chrono::duration&lt;Rep2,Period2&gt;&gt;;\t\n[cpp11] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;\t\nclass common_type&lt;chrono::duration&lt;Rep1,Period1&gt;,chrono::duration&lt;Rep2,Period2&gt;&gt;;</Data></Cell>
    <Cell><Data ss:Type="String">common_type (duration)</Data></Cell>
    <Cell><Data ss:Type="String">Specialization of common_type for duration (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Rep1, Rep2)</Data></Cell>
    <Cell><Data ss:Type="String">Count representation types.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">common_type (time_point)(Clock)Param: (The clock used by both time_point types.)\t\nDesc: no-Description (other)\t\nProto: template &lt;class Clock, class Duration1, class Duration2&gt;\t\nclass common_type&lt;chrono::time_point&lt;Clock, Duration1&gt;, chrono::time_point&lt;Clock, Duration2&gt;&gt;;\t\n[cpp11] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Clock, class Duration1, class Duration2&gt;\t\nclass common_type&lt;chrono::time_point&lt;Clock, Duration1&gt;, chrono::time_point&lt;Clock, Duration2&gt;&gt;;</Data></Cell>
    <Cell><Data ss:Type="String">common_type (time_point)</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">(Clock)</Data></Cell>
    <Cell><Data ss:Type="String">The clock used by both time_point types.</Data></Cell>
    <Cell><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">duration_values(Rep)Param: (Count representation type.)\t\nDesc: Duration values (class template)\t\nProto: template &lt;class Rep&gt; class duration_values;\t\n[cpp11 ] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Rep&gt; class duration_values;</Data></Cell>
    <Cell><Data ss:Type="String">duration_values</Data></Cell>
    <Cell><Data ss:Type="String">Duration values (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Rep)</Data></Cell>
    <Cell><Data ss:Type="String">Count representation type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">high_resolution_clock()Param: ()\t\nDesc: High resolution clock (class)\t\nProto: class high_resolution_clock;\t\n[cpp11 ] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class high_resolution_clock;</Data></Cell>
    <Cell><Data ss:Type="String">high_resolution_clock</Data></Cell>
    <Cell><Data ss:Type="String">High resolution clock (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">steady_clock()Param: ()\t\nDesc: Steady clock (class)\t\nProto: class steady_clock;\t\n[cpp11 ] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class steady_clock;</Data></Cell>
    <Cell><Data ss:Type="String">steady_clock</Data></Cell>
    <Cell><Data ss:Type="String">Steady clock (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">system_clock()Param: ()\t\nDesc: System clock (class)\t\nProto: class system_clock;\t\n[cpp11 ] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class system_clock;</Data></Cell>
    <Cell><Data ss:Type="String">system_clock</Data></Cell>
    <Cell><Data ss:Type="String">System clock (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">treat_as_floating_point(Rep)Param: (Count representation type.)\t\nDesc: Treat as floating point (class template)\t\nProto: template &lt;class Rep&gt; struct treat_as_floating_point : is_floating_point&lt;Rep&gt; {};\t\n[cpp11] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Rep&gt; struct treat_as_floating_point : is_floating_point&lt;Rep&gt; {};</Data></Cell>
    <Cell><Data ss:Type="String">treat_as_floating_point</Data></Cell>
    <Cell><Data ss:Type="String">Treat as floating point (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Rep)</Data></Cell>
    <Cell><Data ss:Type="String">Count representation type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">hours()Param: ()\t\nDesc: Duration in hours (class)\t\nProto: typedef duration &lt; /*see rep below*/, ratio&lt;3600,1&gt; &gt; hours;\t\n[cpp11] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef duration &lt; /*see rep below*/, ratio&lt;3600,1&gt; &gt; hours;</Data></Cell>
    <Cell><Data ss:Type="String">hours</Data></Cell>
    <Cell><Data ss:Type="String">Duration in hours (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">microseconds()Param: ()\t\nDesc: Duration in microseconds (class)\t\nProto: typedef duration &lt; /* see rep below */, micro &gt; microseconds;\t\n[cpp11] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef duration &lt; /* see rep below */, micro &gt; microseconds;</Data></Cell>
    <Cell><Data ss:Type="String">microseconds</Data></Cell>
    <Cell><Data ss:Type="String">Duration in microseconds (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">milliseconds()Param: ()\t\nDesc: Duration in milliseconds (class)\t\nProto: typedef duration &lt; /* see rep below */, milli &gt; milliseconds;\t\n[cpp11] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef duration &lt; /* see rep below */, milli &gt; milliseconds;</Data></Cell>
    <Cell><Data ss:Type="String">milliseconds</Data></Cell>
    <Cell><Data ss:Type="String">Duration in milliseconds (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">minutes()Param: ()\t\nDesc: Duration in minutes (class)\t\nProto: typedef duration &lt; /*see rep below*/, ratio&lt;60,1&gt; &gt; minutes;\t\n[cpp11] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef duration &lt; /*see rep below*/, ratio&lt;60,1&gt; &gt; minutes;</Data></Cell>
    <Cell><Data ss:Type="String">minutes</Data></Cell>
    <Cell><Data ss:Type="String">Duration in minutes (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">nanoseconds()Param: ()\t\nDesc: Duration in nanoseconds (class)\t\nProto: typedef duration &lt; /* see rep below */, nano &gt; nanoseconds;\t\n[cpp11] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef duration &lt; /* see rep below */, nano &gt; nanoseconds;</Data></Cell>
    <Cell><Data ss:Type="String">nanoseconds</Data></Cell>
    <Cell><Data ss:Type="String">Duration in nanoseconds (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">codecvt_utf16(Elem)Param: (The internal character type, aliased as member intern_type.)\t\nDesc: Convert UTF-16 (class template)\t\nProto: template &lt; class Elem, unsigned long MaxCode = 0x10ffffUL, codecvt_mode Mode = (codecvt_mode)0 &gt;\t\nclass codecvt_utf16 : public codecvt &lt;Elem, char, mbstate_t&gt;\t\n[cpp11] [&lt;codecvt&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class Elem, unsigned long MaxCode = 0x10ffffUL, codecvt_mode Mode = (codecvt_mode)0 &gt;\t\nclass codecvt_utf16 : public codecvt &lt;Elem, char, mbstate_t&gt;</Data></Cell>
    <Cell><Data ss:Type="String">codecvt_utf16</Data></Cell>
    <Cell><Data ss:Type="String">Convert UTF-16 (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Elem)</Data></Cell>
    <Cell><Data ss:Type="String">The internal character type, aliased as member intern_type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;codecvt&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Unicode conversion facets</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">codecvt_utf8(Elem)Param: (The internal character type, aliased as member intern_type.)\t\nDesc: Convert UTF-8 (class template)\t\nProto: template &lt; class Elem, unsigned long MaxCode = 0x10ffffUL, codecvt_mode Mode = (codecvt_mode)0 &gt;\t\nclass codecvt_utf8 : public codecvt &lt;Elem, char, mbstate_t&gt;\t\n[cpp11] [&lt;codecvt&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class Elem, unsigned long MaxCode = 0x10ffffUL, codecvt_mode Mode = (codecvt_mode)0 &gt;\t\nclass codecvt_utf8 : public codecvt &lt;Elem, char, mbstate_t&gt;</Data></Cell>
    <Cell><Data ss:Type="String">codecvt_utf8</Data></Cell>
    <Cell><Data ss:Type="String">Convert UTF-8 (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Elem)</Data></Cell>
    <Cell><Data ss:Type="String">The internal character type, aliased as member intern_type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;codecvt&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Unicode conversion facets</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">codecvt_utf8_utf16(Elem)Param: (The internal character type, aliased as member intern_type.)\t\nDesc: Convert between UTF-8 and UTF-16 (class template)\t\nProto: template &lt; class Elem, unsigned long MaxCode = 0x10ffffUL, codecvt_mode Mode = (codecvt_mode)0 &gt;\t\nclass codecvt_utf8_utf16 : public codecvt &lt;Elem, char, mbstate_t&gt;\t\n[cpp11] [&lt;codecvt&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class Elem, unsigned long MaxCode = 0x10ffffUL, codecvt_mode Mode = (codecvt_mode)0 &gt;\t\nclass codecvt_utf8_utf16 : public codecvt &lt;Elem, char, mbstate_t&gt;</Data></Cell>
    <Cell><Data ss:Type="String">codecvt_utf8_utf16</Data></Cell>
    <Cell><Data ss:Type="String">Convert between UTF-8 and UTF-16 (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Elem)</Data></Cell>
    <Cell><Data ss:Type="String">The internal character type, aliased as member intern_type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;codecvt&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Unicode conversion facets</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">codecvt_mode()Param: ()\t\nDesc: Codecvt mode (enum)\t\nProto: enum codecvt_mode {\t\nconsume_header = 4,\t\ngenerate_header = 2,\t\nlittle_endian = 1\t\n};\t\n[cpp11] [&lt;codecvt&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">enum codecvt_mode {\t\nconsume_header = 4,\t\ngenerate_header = 2,\t\nlittle_endian = 1\t\n};</Data></Cell>
    <Cell><Data ss:Type="String">codecvt_mode</Data></Cell>
    <Cell><Data ss:Type="String">Codecvt mode (enum)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">enum</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;codecvt&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Unicode conversion facets</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">complex(T)Param: (Type of both the real and imaginary components of the complex number.)\t\nDesc: Complex number class (class template)\t\nProto: template &lt;class T&gt; class complex;\t\n[cpp98 cpp11 ] [&lt;complex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; class complex;</Data></Cell>
    <Cell><Data ss:Type="String">complex</Data></Cell>
    <Cell><Data ss:Type="String">Complex number class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of both the real and imaginary components of the complex number.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;complex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Complex numbers library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bad_exception()Param: ()\t\nDesc: Exception thrown by unexpected handler (class)\t\nProto: class bad_exception;\t\n[cpp98 cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class bad_exception;</Data></Cell>
    <Cell><Data ss:Type="String">bad_exception</Data></Cell>
    <Cell><Data ss:Type="String">Exception thrown by unexpected handler (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">nested_exception()Param: ()\t\nDesc: Nested exception class (class)\t\nProto: class nested_exception;\t\n[cpp11 ] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class nested_exception;</Data></Cell>
    <Cell><Data ss:Type="String">nested_exception</Data></Cell>
    <Cell><Data ss:Type="String">Nested exception class (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bind(fn)Param: (A function object, pointer to function or pointer to member.)\t\nDesc: Bind function arguments (function template)\t\nProto: long-proto\t\n[cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">bind</Data></Cell>
    <Cell><Data ss:Type="String">Bind function arguments (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(fn)</Data></Cell>
    <Cell><Data ss:Type="String">A function object, pointer to function or pointer to member.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">cref(elem)Param: (An lvalue reference, whose const reference is stored in the object.)\t\nDesc: Construct reference_wrapper to const (function template)\t\nProto: long-proto\t\n[cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">cref</Data></Cell>
    <Cell><Data ss:Type="String">Construct reference_wrapper to const (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(elem)</Data></Cell>
    <Cell><Data ss:Type="String">An lvalue reference, whose const reference is stored in the object.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">binary_negate(Predicate)Param: (A binary function object class, with members first_argument_type and second_argument_type defined.)\t\nDesc: Negate binary function object class (class template)\t\nProto: template &lt;class Predicate&gt; class binary_negate;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Predicate&gt; class binary_negate;</Data></Cell>
    <Cell><Data ss:Type="String">binary_negate</Data></Cell>
    <Cell><Data ss:Type="String">Negate binary function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Predicate)</Data></Cell>
    <Cell><Data ss:Type="String">A binary function object class, with members first_argument_type and second_argument_type defined.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">function(T)Param: (A type.)\t\nDesc: Function wrapper (class template)\t\nProto: template &lt;class T&gt; function; \t\n[cpp11 ] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; function; </Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">Function wrapper (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">reference_wrapper(T)Param: (Type of the referred element.)\t\nDesc: Reference wrapper (class template)\t\nProto: template &lt;class T&gt; class reference_wrapper;\t\n[cpp11 ] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; class reference_wrapper;</Data></Cell>
    <Cell><Data ss:Type="String">reference_wrapper</Data></Cell>
    <Cell><Data ss:Type="String">Reference wrapper (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the referred element.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">unary_negate(Predicate)Param: (A unary function object class, with member argument_type defined.)\t\nDesc: Negate unary function object class (class template)\t\nProto: template &lt;class Predicate&gt; class unary_negate;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Predicate&gt; class unary_negate;</Data></Cell>
    <Cell><Data ss:Type="String">unary_negate</Data></Cell>
    <Cell><Data ss:Type="String">Negate unary function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Predicate)</Data></Cell>
    <Cell><Data ss:Type="String">A unary function object class, with member argument_type defined.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bit_and(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Bitwise AND function object class (class template)\t\nProto: template &lt;class T&gt; struct bit_and;\t\n[cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct bit_and;</Data></Cell>
    <Cell><Data ss:Type="String">bit_and</Data></Cell>
    <Cell><Data ss:Type="String">Bitwise AND function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments and return type of the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bit_or(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Bitwise OR function object class (class template)\t\nProto: template &lt;class T&gt; struct bit_or;\t\n[class template] [cpp11]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct bit_or;</Data></Cell>
    <Cell><Data ss:Type="String">bit_or</Data></Cell>
    <Cell><Data ss:Type="String">Bitwise OR function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments and return type of the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">).</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bit_xor(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Bitwise XOR function object class (class template)\t\nProto: template &lt;class T&gt; struct bit_xor;\t\n[cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct bit_xor;</Data></Cell>
    <Cell><Data ss:Type="String">bit_xor</Data></Cell>
    <Cell><Data ss:Type="String">Bitwise XOR function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments and return type of the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">divides(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Division function object class (class template)\t\nProto: template &lt;class T&gt; struct divides;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct divides;</Data></Cell>
    <Cell><Data ss:Type="String">divides</Data></Cell>
    <Cell><Data ss:Type="String">Division function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments and return type of the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">equal_to(T)Param: (Type of the arguments to compare by the functional call.)\t\nDesc: Function object class for equality comparison (class template)\t\nProto: template &lt;class T&gt; struct equal_to;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct equal_to;</Data></Cell>
    <Cell><Data ss:Type="String">equal_to</Data></Cell>
    <Cell><Data ss:Type="String">Function object class for equality comparison (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments to compare by the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">greater_equal(T)Param: (Type of the arguments to compare by the functional call.)\t\nDesc: Function object class for greater-than-or-equal-to comparison (class template)\t\nProto: template &lt;class T&gt; struct greater_equal;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct greater_equal;</Data></Cell>
    <Cell><Data ss:Type="String">greater_equal</Data></Cell>
    <Cell><Data ss:Type="String">Function object class for greater-than-or-equal-to comparison (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments to compare by the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">less_equal(T)Param: (Type of the arguments to compare by the functional call.)\t\nDesc: Function object class for less-than-or-equal-to comparison (class template)\t\nProto: template &lt;class T&gt; struct less_equal;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct less_equal;</Data></Cell>
    <Cell><Data ss:Type="String">less_equal</Data></Cell>
    <Cell><Data ss:Type="String">Function object class for less-than-or-equal-to comparison (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments to compare by the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">logical_and(T)Param: (Type of the arguments passed to the functional call.)\t\nDesc: Logical AND function object class (class template)\t\nProto: template &lt;class T&gt; struct logical_and;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct logical_and;</Data></Cell>
    <Cell><Data ss:Type="String">logical_and</Data></Cell>
    <Cell><Data ss:Type="String">Logical AND function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments passed to the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">logical_not(T)Param: (Type of the argument passed to the functional call.)\t\nDesc: Logical NOT function object class (class template)\t\nProto: template &lt;class T&gt; struct logical_not;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct logical_not;</Data></Cell>
    <Cell><Data ss:Type="String">logical_not</Data></Cell>
    <Cell><Data ss:Type="String">Logical NOT function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the argument passed to the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">logical_or(T)Param: (Type of the arguments passed to the functional call.)\t\nDesc: Logical OR function object class (class template)\t\nProto: template &lt;class T&gt; struct logical_or;\t\n[).] [class template]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct logical_or;</Data></Cell>
    <Cell><Data ss:Type="String">logical_or</Data></Cell>
    <Cell><Data ss:Type="String">Logical OR function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments passed to the functional call.</Data></Cell>
    <Cell ss:Index="9"><Data ss:Type="String">).</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">minus(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Subtraction function object class (class template)\t\nProto: template &lt;class T&gt; struct minus;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct minus;</Data></Cell>
    <Cell><Data ss:Type="String">minus</Data></Cell>
    <Cell><Data ss:Type="String">Subtraction function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments and return type of the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">modulus(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Modulus function object class (class template)\t\nProto: template &lt;class T&gt; struct modulus;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct modulus;</Data></Cell>
    <Cell><Data ss:Type="String">modulus</Data></Cell>
    <Cell><Data ss:Type="String">Modulus function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments and return type of the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">multiplies(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Multiplication function object class (class template)\t\nProto: template &lt;class T&gt; struct multiplies;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct multiplies;</Data></Cell>
    <Cell><Data ss:Type="String">multiplies</Data></Cell>
    <Cell><Data ss:Type="String">Multiplication function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments and return type of the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">not_equal_to(T)Param: (Type of the arguments to compare by the functional call.)\t\nDesc: Function object class for non-equality comparison (class template)\t\nProto: template &lt;class T&gt; struct not_equal_to;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct not_equal_to;</Data></Cell>
    <Cell><Data ss:Type="String">not_equal_to</Data></Cell>
    <Cell><Data ss:Type="String">Function object class for non-equality comparison (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments to compare by the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">plus(T)Param: (Type of the arguments and return type of the functional call.)\t\nDesc: Addition function object class (class template)\t\nProto: template &lt;class T&gt; struct plus;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct plus;</Data></Cell>
    <Cell><Data ss:Type="String">plus</Data></Cell>
    <Cell><Data ss:Type="String">Addition function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the arguments and return type of the functional call.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bad_function_call()Param: ()\t\nDesc: Exception thrown on bad call (class)\t\nProto: class bad_function_call;\t\n[cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class bad_function_call;</Data></Cell>
    <Cell><Data ss:Type="String">bad_function_call</Data></Cell>
    <Cell><Data ss:Type="String">Exception thrown on bad call (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">hash()Param: ()\t\nDesc: Default hash function object class (class template)\t\nProto: template &lt;class T&gt; struct hash;\t\n[cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct hash;</Data></Cell>
    <Cell><Data ss:Type="String">hash</Data></Cell>
    <Cell><Data ss:Type="String">Default hash function object class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_bind_expression(T)Param: (A type.)\t\nDesc: Is bind expression (class template)\t\nProto: template &lt;class T&gt; struct is_bind_expression;\t\n[cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_bind_expression;</Data></Cell>
    <Cell><Data ss:Type="String">is_bind_expression</Data></Cell>
    <Cell><Data ss:Type="String">Is bind expression (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_placeholder(T)Param: (A type.)\t\nDesc: Is placeholder (class template)\t\nProto: template &lt;class T&gt; struct is_placeholder;\t\n[cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_placeholder;</Data></Cell>
    <Cell><Data ss:Type="String">is_placeholder</Data></Cell>
    <Cell><Data ss:Type="String">Is placeholder (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">placeholders()Param: ()\t\nDesc: Bind argument placeholders (namespace)\t\nProto: namespace placeholders {\t\nextern /* unspecified */ _1;extern /* unspecified */ _2;extern /* unspecified */ _3;// ...\t\n}\t\n[cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">namespace placeholders {\t\nextern /* unspecified */ _1;extern /* unspecified */ _2;extern /* unspecified */ _3;// ...\t\n}</Data></Cell>
    <Cell><Data ss:Type="String">placeholders</Data></Cell>
    <Cell><Data ss:Type="String">Bind argument placeholders (namespace)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">namespace</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">binary_function()Param: ()\t\nDesc: Binary function object base class (class template)\t\nProto: template &lt;class Arg1, class Arg2, class Result&gt; struct binary_function;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Arg1, class Arg2, class Result&gt; struct binary_function;</Data></Cell>
    <Cell><Data ss:Type="String">binary_function</Data></Cell>
    <Cell><Data ss:Type="String">Binary function object base class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">binder1st()Param: ()\t\nDesc: Generate function object class with 1st parameter bound (class template)\t\nProto: template &lt;class Operation&gt; class binder1st;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Operation&gt; class binder1st;</Data></Cell>
    <Cell><Data ss:Type="String">binder1st</Data></Cell>
    <Cell><Data ss:Type="String">Generate function object class with 1st parameter bound (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">binder2nd()Param: ()\t\nDesc: Generate function object class with 2nd parameter bound (class template)\t\nProto: template &lt;class Operation&gt; class binder2nd;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Operation&gt; class binder2nd;</Data></Cell>
    <Cell><Data ss:Type="String">binder2nd</Data></Cell>
    <Cell><Data ss:Type="String">Generate function object class with 2nd parameter bound (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">const_mem_fun1_ref_t()Param: ()\t\nDesc: Generate function object class from single-parameter const member (reference version) (class template)\t\nProto: template &lt;class S, class T, class A&gt; class const_mem_fun1_ref_t;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class S, class T, class A&gt; class const_mem_fun1_ref_t;</Data></Cell>
    <Cell><Data ss:Type="String">const_mem_fun1_ref_t</Data></Cell>
    <Cell><Data ss:Type="String">Generate function object class from single-parameter const member (reference version) (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">const_mem_fun1_t()Param: ()\t\nDesc: Generate function object class from single-parameter const member (pointer version) (class template)\t\nProto: template &lt;class S, class T, class A&gt; class const_mem_fun1_t;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class S, class T, class A&gt; class const_mem_fun1_t;</Data></Cell>
    <Cell><Data ss:Type="String">const_mem_fun1_t</Data></Cell>
    <Cell><Data ss:Type="String">Generate function object class from single-parameter const member (pointer version) (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">const_mem_fun_ref_t()Param: ()\t\nDesc: Generate function object class from const parameterless member (reference version) (class template)\t\nProto: template &lt;class S, class T&gt; class const_mem_fun_ref_t;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class S, class T&gt; class const_mem_fun_ref_t;</Data></Cell>
    <Cell><Data ss:Type="String">const_mem_fun_ref_t</Data></Cell>
    <Cell><Data ss:Type="String">Generate function object class from const parameterless member (reference version) (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">const_mem_fun_t()Param: ()\t\nDesc: Generate function object class from const parameterless member (pointer version) (class template)\t\nProto: template &lt;class S, class T&gt; class const_mem_fun_t;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class S, class T&gt; class const_mem_fun_t;</Data></Cell>
    <Cell><Data ss:Type="String">const_mem_fun_t</Data></Cell>
    <Cell><Data ss:Type="String">Generate function object class from const parameterless member (pointer version) (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">pointer_to_binary_function()Param: ()\t\nDesc: Generate binary function object class from pointer (class template)\t\nProto: template &lt;class Arg1, class Arg2, class Result&gt; class pointer_to_binary_function;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Arg1, class Arg2, class Result&gt; class pointer_to_binary_function;</Data></Cell>
    <Cell><Data ss:Type="String">pointer_to_binary_function</Data></Cell>
    <Cell><Data ss:Type="String">Generate binary function object class from pointer (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">pointer_to_unary_function()Param: ()\t\nDesc: Generate unary function object class from pointer (class template)\t\nProto: template &lt;class Arg, class Result&gt; class pointer_to_unary_function;\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Arg, class Result&gt; class pointer_to_unary_function;</Data></Cell>
    <Cell><Data ss:Type="String">pointer_to_unary_function</Data></Cell>
    <Cell><Data ss:Type="String">Generate unary function object class from pointer (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ptr_fun()Param: ()\t\nDesc: Convert function pointer to function object (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">ptr_fun</Data></Cell>
    <Cell><Data ss:Type="String">Convert function pointer to function object (function template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">initializer_list(T)Param: (Type of the elements.)\t\nDesc: Initializer list (class template)\t\nProto: template&lt;class T&gt; class initializer_list;\t\n[cpp11 ] [&lt;initializer_list&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template&lt;class T&gt; class initializer_list;</Data></Cell>
    <Cell><Data ss:Type="String">initializer_list</Data></Cell>
    <Cell><Data ss:Type="String">Initializer list (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the elements.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;initializer_list&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Initializer list</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iterator(Category)Param: (Category to which the iterator belongs to.)\t\nDesc: Iterator base class (class template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">iterator</Data></Cell>
    <Cell><Data ss:Type="String">Iterator base class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Category)</Data></Cell>
    <Cell><Data ss:Type="String">Category to which the iterator belongs to.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iterator_traits()Param: ()\t\nDesc: Iterator traits (class template)\t\nProto: template &lt;class Iterator&gt; class iterator_traits;template &lt;class T&gt; class iterator_traits&lt;T*&gt;;template &lt;class T&gt; class iterator_traits&lt;const T*&gt;;\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Iterator&gt; class iterator_traits;template &lt;class T&gt; class iterator_traits&lt;T*&gt;;template &lt;class T&gt; class iterator_traits&lt;const T*&gt;;</Data></Cell>
    <Cell><Data ss:Type="String">iterator_traits</Data></Cell>
    <Cell><Data ss:Type="String">Iterator traits (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bidirectional_iterator_tag()Param: ()\t\nDesc: Bidirectional iterator category (class)\t\nProto: struct bidirectional_iterator_tag {}\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct bidirectional_iterator_tag {}</Data></Cell>
    <Cell><Data ss:Type="String">bidirectional_iterator_tag</Data></Cell>
    <Cell><Data ss:Type="String">Bidirectional iterator category (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">forward_iterator_tag()Param: ()\t\nDesc: Forward iterator category (class)\t\nProto: struct forward_iterator_tag {};\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct forward_iterator_tag {};</Data></Cell>
    <Cell><Data ss:Type="String">forward_iterator_tag</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterator category (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">input_iterator_tag()Param: ()\t\nDesc: Input iterator category (class)\t\nProto: struct input_iterator_tag {};\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct input_iterator_tag {};</Data></Cell>
    <Cell><Data ss:Type="String">input_iterator_tag</Data></Cell>
    <Cell><Data ss:Type="String">Input iterator category (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">output_iterator_tag()Param: ()\t\nDesc: Output iterator category (class)\t\nProto: struct output_iterator_tag {};\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct output_iterator_tag {};</Data></Cell>
    <Cell><Data ss:Type="String">output_iterator_tag</Data></Cell>
    <Cell><Data ss:Type="String">Output iterator category (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">random_access_iterator_tag()Param: ()\t\nDesc: Random-access iterator category (class)\t\nProto: struct random_access_iterator_tag {};\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct random_access_iterator_tag {};</Data></Cell>
    <Cell><Data ss:Type="String">random_access_iterator_tag</Data></Cell>
    <Cell><Data ss:Type="String">Random-access iterator category (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">back_insert_iterator(Container)Param: (A container class with member push_back defined (such as the standard containers vector, deque and list).)\t\nDesc: Back insert iterator (class template)\t\nProto: template &lt;class Container&gt; class back_insert_iterator;\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Container&gt; class back_insert_iterator;</Data></Cell>
    <Cell><Data ss:Type="String">back_insert_iterator</Data></Cell>
    <Cell><Data ss:Type="String">Back insert iterator (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Container)</Data></Cell>
    <Cell><Data ss:Type="String">A container class with member push_back defined (such as the standard containers vector, deque and list).</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">front_insert_iterator(Container)Param: (A container class with member push_front defined (such as the standard containers deque and list).)\t\nDesc: Front insert iterator (class template)\t\nProto: template &lt;class Container&gt; class front_insert_iterator;\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Container&gt; class front_insert_iterator;</Data></Cell>
    <Cell><Data ss:Type="String">front_insert_iterator</Data></Cell>
    <Cell><Data ss:Type="String">Front insert iterator (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Container)</Data></Cell>
    <Cell><Data ss:Type="String">A container class with member push_front defined (such as the standard containers deque and list).</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">istreambuf_iterator(charT)Param: (Character type.)\t\nDesc: Input stream buffer iterator (class template)\t\nProto: template &lt;class charT, class traits=char_traits&lt;charT&gt; &gt; class istreambuf_iterator;\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class traits=char_traits&lt;charT&gt; &gt; class istreambuf_iterator;</Data></Cell>
    <Cell><Data ss:Type="String">istreambuf_iterator</Data></Cell>
    <Cell><Data ss:Type="String">Input stream buffer iterator (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">istream_iterator(T)Param: (Element type for the iterator: The type of elements extracted from the stream.)\t\nDesc: Istream iterator (class template)\t\nProto: template &lt;class T, class charT=char, class traits=char_traits&lt;charT&gt;, \t\n class Distance = ptrdiff_t&gt;\t\nclass istream_iterator;\t\n[cpp98 cpp11 ] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class charT=char, class traits=char_traits&lt;charT&gt;, \t\n class Distance = ptrdiff_t&gt;\t\nclass istream_iterator;</Data></Cell>
    <Cell><Data ss:Type="String">istream_iterator</Data></Cell>
    <Cell><Data ss:Type="String">Istream iterator (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Element type for the iterator: The type of elements extracted from the stream.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ostreambuf_iterator(charT)Param: (Character type.)\t\nDesc: Output stream buffer iterator (class template)\t\nProto: template &lt;class charT, class traits=char_traits&lt;charT&gt; &gt;\t\nclass ostreambuf_iterator;\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class traits=char_traits&lt;charT&gt; &gt;\t\nclass ostreambuf_iterator;</Data></Cell>
    <Cell><Data ss:Type="String">ostreambuf_iterator</Data></Cell>
    <Cell><Data ss:Type="String">Output stream buffer iterator (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ostream_iterator(T)Param: ()\t\nDesc: Ostream iterator (class template)\t\nProto: template &lt;class T, class charT=char, class traits=char_traits&lt;charT&gt; &gt;\t\nclass ostream_iterator;\t\n[cpp98 cpp11 ] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class charT=char, class traits=char_traits&lt;charT&gt; &gt;\t\nclass ostream_iterator;</Data></Cell>
    <Cell><Data ss:Type="String">ostream_iterator</Data></Cell>
    <Cell><Data ss:Type="String">Ostream iterator (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">reverse_iterator(Iterator)Param: (A bidirectional iterator type.)\t\nDesc: Reverse iterator (class template)\t\nProto: template &lt;class Iterator&gt; class reverse_iterator;\t\n[cpp98 cpp11 ] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Iterator&gt; class reverse_iterator;</Data></Cell>
    <Cell><Data ss:Type="String">reverse_iterator</Data></Cell>
    <Cell><Data ss:Type="String">Reverse iterator (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Iterator)</Data></Cell>
    <Cell><Data ss:Type="String">A bidirectional iterator type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">float_denorm_style()Param: ()\t\nDesc: Enum type for float denormalization style (type)\t\nProto: enum float_denorm_style;\t\n[cpp98 cpp11] [&lt;limits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">enum float_denorm_style;</Data></Cell>
    <Cell><Data ss:Type="String">float_denorm_style</Data></Cell>
    <Cell><Data ss:Type="String">Enum type for float denormalization style (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;limits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Numeric limits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">float_round_style()Param: ()\t\nDesc: Enum type for float rounding style (type)\t\nProto: enum float_round_style;\t\n[cpp98 cpp11] [&lt;limits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">enum float_round_style;</Data></Cell>
    <Cell><Data ss:Type="String">float_round_style</Data></Cell>
    <Cell><Data ss:Type="String">Enum type for float rounding style (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;limits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Numeric limits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">numeric_limits(T)Param: (A type.)\t\nDesc: Numeric limits type (class template)\t\nProto: template &lt;class T&gt; numeric_limits;\t\n[cpp98 cpp11] [&lt;limits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; numeric_limits;</Data></Cell>
    <Cell><Data ss:Type="String">numeric_limits</Data></Cell>
    <Cell><Data ss:Type="String">Numeric limits type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;limits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Numeric limits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wbuffer_convert(Codecvt)Param: (Type of the conversion object: This shall be a class with the same properties as the codecvt locale facet, such as one of the standard classes defined in header &lt;codecvt&gt;.)\t\nDesc: no-Description (other)\t\nProto: template &lt; class Codecvt, class Elem = wchar_t, class Tr = char_traits&lt;Elem&gt; &gt; class wbuffer_convert\t\n: public std::basic_streambuf&lt;Elem,Tr&gt;;\t\n[cpp11 ] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class Codecvt, class Elem = wchar_t, class Tr = char_traits&lt;Elem&gt; &gt; class wbuffer_convert\t\n: public std::basic_streambuf&lt;Elem,Tr&gt;;</Data></Cell>
    <Cell><Data ss:Type="String">wbuffer_convert</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">(Codecvt)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the conversion object: This shall be a class with the same properties as the codecvt locale facet, such as one of the standard classes defined in header &lt;codecvt&gt;.</Data></Cell>
    <Cell><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wstring_convert(Codecvt)Param: (Type of the conversion object: This shall be a class with the same properties as the codecvt locale facet, such as one of the standard classes defined in header &lt;codecvt&gt;.)\t\nDesc: no-Description (other)\t\nProto: template &lt; class Codecvt, class Elem = wchar_t, class Wide_alloc = std::allocator&lt;Elem&gt;, class Byte_alloc = std::allocator&lt;char&gt; &gt; class wstring_convert;\t\n[cpp11 ] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class Codecvt, class Elem = wchar_t, class Wide_alloc = std::allocator&lt;Elem&gt;, class Byte_alloc = std::allocator&lt;char&gt; &gt; class wstring_convert;</Data></Cell>
    <Cell><Data ss:Type="String">wstring_convert</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">(Codecvt)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the conversion object: This shall be a class with the same properties as the codecvt locale facet, such as one of the standard classes defined in header &lt;codecvt&gt;.</Data></Cell>
    <Cell><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">codecvt_base()Param: ()\t\nDesc: Base class for codecvt (class)\t\nProto: class codecvt_base;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class codecvt_base;</Data></Cell>
    <Cell><Data ss:Type="String">codecvt_base</Data></Cell>
    <Cell><Data ss:Type="String">Base class for codecvt (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">codecvt_byname()Param: ()\t\nDesc: Convert codeset facet (class template)\t\nProto: template &lt;class internT, class externT, class stateT&gt; class codecvt_byname;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class internT, class externT, class stateT&gt; class codecvt_byname;</Data></Cell>
    <Cell><Data ss:Type="String">codecvt_byname</Data></Cell>
    <Cell><Data ss:Type="String">Convert codeset facet (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">collate(charT)Param: (Character type.)\t\nDesc: Facet to compare and hash strings (class template)\t\nProto: template &lt;class charT&gt; class collate;\t\n[cpp98 cpp11 ] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT&gt; class collate;</Data></Cell>
    <Cell><Data ss:Type="String">collate</Data></Cell>
    <Cell><Data ss:Type="String">Facet to compare and hash strings (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">collate_byname()Param: ()\t\nDesc: Facet to compare and hash strings (class template)\t\nProto: template &lt;class charT&gt; class collate_byname;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT&gt; class collate_byname;</Data></Cell>
    <Cell><Data ss:Type="String">collate_byname</Data></Cell>
    <Cell><Data ss:Type="String">Facet to compare and hash strings (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ctype_base()Param: ()\t\nDesc: Base class for ctype (class)\t\nProto: class ctype_base;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class ctype_base;</Data></Cell>
    <Cell><Data ss:Type="String">ctype_base</Data></Cell>
    <Cell><Data ss:Type="String">Base class for ctype (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ctype_byname()Param: ()\t\nDesc: Character type facet (class template)\t\nProto: template &lt;class charT&gt; class ctype_byname;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT&gt; class ctype_byname;</Data></Cell>
    <Cell><Data ss:Type="String">ctype_byname</Data></Cell>
    <Cell><Data ss:Type="String">Character type facet (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">messages(charT)Param: (Character type.)\t\nDesc: Facet to access message catalogs (class template)\t\nProto: template &lt;class charT&gt; class messages;\t\n[cpp98 cpp11 ] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT&gt; class messages;</Data></Cell>
    <Cell><Data ss:Type="String">messages</Data></Cell>
    <Cell><Data ss:Type="String">Facet to access message catalogs (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">messages_base()Param: ()\t\nDesc: no-Description (other)\t\nProto: class messages_base;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class messages_base;</Data></Cell>
    <Cell><Data ss:Type="String">messages_base</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">messages_byname()Param: ()\t\nDesc: Facet to access message catalogs (class template)\t\nProto: template &lt;class charT&gt; class messages_byname;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT&gt; class messages_byname;</Data></Cell>
    <Cell><Data ss:Type="String">messages_byname</Data></Cell>
    <Cell><Data ss:Type="String">Facet to access message catalogs (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">moneypunct(charT)Param: (Character type.)\t\nDesc: Monetary punctuation facet (class template)\t\nProto: template &lt;class charT, bool International = false&gt; class moneypunct;\t\n[cpp98 cpp11 ] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, bool International = false&gt; class moneypunct;</Data></Cell>
    <Cell><Data ss:Type="String">moneypunct</Data></Cell>
    <Cell><Data ss:Type="String">Monetary punctuation facet (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">moneypunct_byname()Param: ()\t\nDesc: Monetary punctuation facet (class template)\t\nProto: template &lt;class charT, bool International = false&gt; class numpunct_byname;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, bool International = false&gt; class numpunct_byname;</Data></Cell>
    <Cell><Data ss:Type="String">moneypunct_byname</Data></Cell>
    <Cell><Data ss:Type="String">Monetary punctuation facet (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">money_base()Param: ()\t\nDesc: Base class for moneypunct (class)\t\nProto: class money_base;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class money_base;</Data></Cell>
    <Cell><Data ss:Type="String">money_base</Data></Cell>
    <Cell><Data ss:Type="String">Base class for moneypunct (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">money_get(charT)Param: (Character type: the type of the characters in the sequence to interpret.)\t\nDesc: Facet to parse monetary expressions (class template)\t\nProto: template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt; &gt;\t\nclass money_get;\t\n[cpp98 cpp11 ] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt; &gt;\t\nclass money_get;</Data></Cell>
    <Cell><Data ss:Type="String">money_get</Data></Cell>
    <Cell><Data ss:Type="String">Facet to parse monetary expressions (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type: the type of the characters in the sequence to interpret.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">money_put(charT)Param: (Character type: the type of the characters in the sequence to write.)\t\nDesc: Facet to format monetary expressions (class template)\t\nProto: template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt; class money_put;\t\n[cpp98 cpp11 ] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt; class money_put;</Data></Cell>
    <Cell><Data ss:Type="String">money_put</Data></Cell>
    <Cell><Data ss:Type="String">Facet to format monetary expressions (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type: the type of the characters in the sequence to write.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">numpunct(charT)Param: (Character type.)\t\nDesc: Numeric punctuation facet (class template)\t\nProto: template &lt;class charT&gt; class numpunct;\t\n[cpp98 cpp11 ] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT&gt; class numpunct;</Data></Cell>
    <Cell><Data ss:Type="String">numpunct</Data></Cell>
    <Cell><Data ss:Type="String">Numeric punctuation facet (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">numpunct_byname()Param: ()\t\nDesc: Numeric puntuation facet (class template)\t\nProto: template &lt;class charT&gt; class numpunct_byname;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT&gt; class numpunct_byname;</Data></Cell>
    <Cell><Data ss:Type="String">numpunct_byname</Data></Cell>
    <Cell><Data ss:Type="String">Numeric puntuation facet (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">num_get(charT)Param: (Character type: the type of the characters in the sequence to interpret.)\t\nDesc: Facet to parse numeric values (class template)\t\nProto: template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt; &gt; class num_get;\t\n[cpp98 cpp11 ] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt; &gt; class num_get;</Data></Cell>
    <Cell><Data ss:Type="String">num_get</Data></Cell>
    <Cell><Data ss:Type="String">Facet to parse numeric values (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type: the type of the characters in the sequence to interpret.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">num_put(charT)Param: (Character type: the type of the characters in the sequence to write.)\t\nDesc: Facet to format numeric values (class template)\t\nProto: template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt; class num_put;\t\n[cpp98 cpp11 ] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt; class num_put;</Data></Cell>
    <Cell><Data ss:Type="String">num_put</Data></Cell>
    <Cell><Data ss:Type="String">Facet to format numeric values (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type: the type of the characters in the sequence to write.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">time_base()Param: ()\t\nDesc: Base class for time_get (class)\t\nProto: class time_base;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class time_base;</Data></Cell>
    <Cell><Data ss:Type="String">time_base</Data></Cell>
    <Cell><Data ss:Type="String">Base class for time_get (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">time_get(charT)Param: (Character type: the type of the characters in the sequence to interpret.)\t\nDesc: Facet to parse dates and times (class template)\t\nProto: template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt; &gt;\t\nclass time_get;\t\n[cpp98 cpp11 ] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt; &gt;\t\nclass time_get;</Data></Cell>
    <Cell><Data ss:Type="String">time_get</Data></Cell>
    <Cell><Data ss:Type="String">Facet to parse dates and times (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type: the type of the characters in the sequence to interpret.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">time_get_byname()Param: ()\t\nDesc: Facet to parse dates and times (class template)\t\nProto: template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt; &gt; class time_get_byname;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class InputIterator = istreambuf_iterator&lt;charT&gt; &gt; class time_get_byname;</Data></Cell>
    <Cell><Data ss:Type="String">time_get_byname</Data></Cell>
    <Cell><Data ss:Type="String">Facet to parse dates and times (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">time_put(charT)Param: (Character type: the type of the characters in the sequence to write.)\t\nDesc: Facet to format dates and times (class template)\t\nProto: template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt;\t\nclass time_put;\t\n[cpp98 cpp11 ] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt;\t\nclass time_put;</Data></Cell>
    <Cell><Data ss:Type="String">time_put</Data></Cell>
    <Cell><Data ss:Type="String">Facet to format dates and times (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type: the type of the characters in the sequence to write.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">time_put_byname()Param: ()\t\nDesc: Facet to format dates and times (class template)\t\nProto: template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt; class time_put_byname;\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class OutputIterator = ostreambuf_iterator&lt;charT&gt; &gt; class time_put_byname;</Data></Cell>
    <Cell><Data ss:Type="String">time_put_byname</Data></Cell>
    <Cell><Data ss:Type="String">Facet to format dates and times (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">allocator(T)Param: (Type of the elements allocated by the object (aliased as member type value_type).)\t\nDesc: Default allocator (class template)\t\nProto: template &lt;class T&gt; class allocator;\t\n[cpp98 cpp11 ] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; class allocator;</Data></Cell>
    <Cell><Data ss:Type="String">allocator</Data></Cell>
    <Cell><Data ss:Type="String">Default allocator (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the elements allocated by the object (aliased as member type value_type).</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">allocator_arg_t()Param: ()\t\nDesc: Allocator arg type (class)\t\nProto: struct allocator_arg_t {};\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct allocator_arg_t {};</Data></Cell>
    <Cell><Data ss:Type="String">allocator_arg_t</Data></Cell>
    <Cell><Data ss:Type="String">Allocator arg type (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">allocator_traits(Alloc)Param: (The allocator type, aliased as member type allocator_type.)\t\nDesc: Allocator traits (class template)\t\nProto: template &lt;class Alloc&gt; struct allocator_traits;\t\n[cpp11 ] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Alloc&gt; struct allocator_traits;</Data></Cell>
    <Cell><Data ss:Type="String">allocator_traits</Data></Cell>
    <Cell><Data ss:Type="String">Allocator traits (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Alloc)</Data></Cell>
    <Cell><Data ss:Type="String">The allocator type, aliased as member type allocator_type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">auto_ptr(X)Param: (The type of the managed object, aliased as member type element_type.)\t\nDesc: Automatic Pointer [deprecated] (class template)\t\nProto: template &lt;class X&gt; class auto_ptr;\t\n[cpp98 cpp11 ] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class X&gt; class auto_ptr;</Data></Cell>
    <Cell><Data ss:Type="String">auto_ptr</Data></Cell>
    <Cell><Data ss:Type="String">Automatic Pointer [deprecated] (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(X)</Data></Cell>
    <Cell><Data ss:Type="String">The type of the managed object, aliased as member type element_type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">auto_ptr_ref()Param: ()\t\nDesc: Reference to automatic pointer (class template)\t\nProto: template &lt;class Y&gt; struct auto_ptr_ref;\t\n[cpp98 cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Y&gt; struct auto_ptr_ref;</Data></Cell>
    <Cell><Data ss:Type="String">auto_ptr_ref</Data></Cell>
    <Cell><Data ss:Type="String">Reference to automatic pointer (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bad_weak_ptr()Param: ()\t\nDesc: no-Description (other)\t\nProto: class bad_weak_ptr: public exception;\t\n[cpp11 ] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class bad_weak_ptr: public exception;</Data></Cell>
    <Cell><Data ss:Type="String">bad_weak_ptr</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">default_delete(T)Param: (The type of object to be deleted.)\t\nDesc: Default deleter (class template)\t\nProto: non-specialized\t\ntemplate &lt;class T&gt; class default_delete;array specialization\t\ntemplate &lt;class T&gt; class default_delete&lt;T[]&gt;;\t\n[cpp11 ] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">non-specialized\t\ntemplate &lt;class T&gt; class default_delete;array specialization\t\ntemplate &lt;class T&gt; class default_delete&lt;T[]&gt;;</Data></Cell>
    <Cell><Data ss:Type="String">default_delete</Data></Cell>
    <Cell><Data ss:Type="String">Default deleter (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">The type of object to be deleted.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">enable_shared_from_this(T)Param: (Full type of the pointed class (generally the final class inheriting from this).)\t\nDesc: Enable shared_from_this (class template)\t\nProto: template &lt;class T&gt; class enable_shared_from_this;\t\n[cpp11 ] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; class enable_shared_from_this;</Data></Cell>
    <Cell><Data ss:Type="String">enable_shared_from_this</Data></Cell>
    <Cell><Data ss:Type="String">Enable shared_from_this (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Full type of the pointed class (generally the final class inheriting from this).</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">owner_less(Ptr)Param: (The type of the managed pointers to be ordered according to owned resource, aliased as member types first_argument_type and second_argument_type.)\t\nDesc: Owner-based less-than operation (class template)\t\nProto: template &lt;class Ptr&gt; struct owner_less;template &lt;class T&gt; struct owner_less&lt;shared_ptr&lt;T&gt;&gt;;template &lt;class T&gt; struct owner_less&lt;weak_ptr&lt;T&gt;&gt;;\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Ptr&gt; struct owner_less;template &lt;class T&gt; struct owner_less&lt;shared_ptr&lt;T&gt;&gt;;template &lt;class T&gt; struct owner_less&lt;weak_ptr&lt;T&gt;&gt;;</Data></Cell>
    <Cell><Data ss:Type="String">owner_less</Data></Cell>
    <Cell><Data ss:Type="String">Owner-based less-than operation (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Ptr)</Data></Cell>
    <Cell><Data ss:Type="String">The type of the managed pointers to be ordered according to owned resource, aliased as member types first_argument_type and second_argument_type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">pointer_traits(Ptr)Param: (Pointer-like type.)\t\nDesc: Pointer traits (class template)\t\nProto: template &lt;class Ptr&gt; class pointer_traits; // template\t\ntemplate &lt;class T&gt; class pointer_traits&lt;T*&gt;; // template specialization\t\n[cpp11 ] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Ptr&gt; class pointer_traits; // template\t\ntemplate &lt;class T&gt; class pointer_traits&lt;T*&gt;; // template specialization</Data></Cell>
    <Cell><Data ss:Type="String">pointer_traits</Data></Cell>
    <Cell><Data ss:Type="String">Pointer traits (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Ptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer-like type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">raw_storage_iterator(OutputIterator)Param: (Underlying iterator type.)\t\nDesc: Raw storage iterator (class template)\t\nProto: template &lt;class OutputIterator, class T&gt;\t\nclass raw_storage_iterator;\t\n[cpp98 cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class OutputIterator, class T&gt;\t\nclass raw_storage_iterator;</Data></Cell>
    <Cell><Data ss:Type="String">raw_storage_iterator</Data></Cell>
    <Cell><Data ss:Type="String">Raw storage iterator (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(OutputIterator)</Data></Cell>
    <Cell><Data ss:Type="String">Underlying iterator type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">shared_ptr(T)Param: (The type of the managed object, aliased as member type element_type.)\t\nDesc: Shared pointer (class template)\t\nProto: template &lt;class T&gt; class shared_ptr;\t\n[cpp11 ] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; class shared_ptr;</Data></Cell>
    <Cell><Data ss:Type="String">shared_ptr</Data></Cell>
    <Cell><Data ss:Type="String">Shared pointer (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">The type of the managed object, aliased as member type element_type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">unique_ptr(T)Param: (The type of the managed object, aliased as member type element_type.)\t\nDesc: Unique pointer (class template)\t\nProto: non-specialized\t\ntemplate &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr;array specialization\t\ntemplate &lt;class T, class D&gt; class unique_ptr&lt;T[],D&gt;;\t\n[cpp11 ] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">non-specialized\t\ntemplate &lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr;array specialization\t\ntemplate &lt;class T, class D&gt; class unique_ptr&lt;T[],D&gt;;</Data></Cell>
    <Cell><Data ss:Type="String">unique_ptr</Data></Cell>
    <Cell><Data ss:Type="String">Unique pointer (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">The type of the managed object, aliased as member type element_type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">uses_allocator(T)Param: (A type.)\t\nDesc: no-Description (other)\t\nProto: template &lt;class T, class Alloc&gt; struct uses_allocator;\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class Alloc&gt; struct uses_allocator;</Data></Cell>
    <Cell><Data ss:Type="String">uses_allocator</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">pointer_safety()Param: ()\t\nDesc: Pointer safety enum (enum class)\t\nProto: enum class pointer_safety { relaxed, preferred, strict };\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">enum class pointer_safety { relaxed, preferred, strict };</Data></Cell>
    <Cell><Data ss:Type="String">pointer_safety</Data></Cell>
    <Cell><Data ss:Type="String">Pointer safety enum (enum class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">enum class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bad_alloc()Param: ()\t\nDesc: Exception thrown on failure allocating memory (class)\t\nProto: class bad_alloc;\t\n[cpp98 cpp11] [&lt;new&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class bad_alloc;</Data></Cell>
    <Cell><Data ss:Type="String">bad_alloc</Data></Cell>
    <Cell><Data ss:Type="String">Exception thrown on failure allocating memory (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;new&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Dynamic memory</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bad_array_new_length()Param: ()\t\nDesc: Exception on bad array length (class)\t\nProto: class bad_array_new_length;\t\n[cpp11] [&lt;new&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class bad_array_new_length;</Data></Cell>
    <Cell><Data ss:Type="String">bad_array_new_length</Data></Cell>
    <Cell><Data ss:Type="String">Exception on bad array length (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;new&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Dynamic memory</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">nothrow_t()Param: ()\t\nDesc: Nothrow type (type)\t\nProto: struct nothrow_t {};\t\n[cpp98 cpp11] [&lt;new&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct nothrow_t {};</Data></Cell>
    <Cell><Data ss:Type="String">nothrow_t</Data></Cell>
    <Cell><Data ss:Type="String">Nothrow type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;new&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Dynamic memory</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">accumulate(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Accumulate values in range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;numeric&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">accumulate</Data></Cell>
    <Cell><Data ss:Type="String">Accumulate values in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;numeric&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Generalized numeric operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">adjacent_difference(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Compute adjacent difference of range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;numeric&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">adjacent_difference</Data></Cell>
    <Cell><Data ss:Type="String">Compute adjacent difference of range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;numeric&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Generalized numeric operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">inner_product(first1, last1)Param: (Input iterators to the initial and final positions in the first sequence.)\t\nDesc: Compute cumulative inner product of range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;numeric&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">inner_product</Data></Cell>
    <Cell><Data ss:Type="String">Compute cumulative inner product of range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in the first sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;numeric&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Generalized numeric operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">partial_sum(first, last)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Compute partial sums of range (function template)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;numeric&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">partial_sum</Data></Cell>
    <Cell><Data ss:Type="String">Compute partial sums of range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;numeric&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Generalized numeric operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bernoulli_distribution()Param: ()\t\nDesc: Bernoulli distribution (class)\t\nProto: class bernoulli_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class bernoulli_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">bernoulli_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Bernoulli distribution (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">binomial_distribution(IntType)Param: (An integer type.)\t\nDesc: Binomial distribution (class template)\t\nProto: template &lt;class IntType = int&gt; class binomial_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class IntType = int&gt; class binomial_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">binomial_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Binomial distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(IntType)</Data></Cell>
    <Cell><Data ss:Type="String">An integer type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">cauchy_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Cauchy distribution (class template)\t\nProto: template &lt;class RealType = double&gt; class cauchy_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType = double&gt; class cauchy_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">cauchy_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Cauchy distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">chi_squared_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Chi-squared distribution (class template)\t\nProto: template &lt;class RealType = double&gt; class chi_squared_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType = double&gt; class chi_squared_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">chi_squared_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Chi-squared distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">discrete_distribution(IntType)Param: (An integer type.)\t\nDesc: Discrete distribution (class template)\t\nProto: template &lt;class IntType = int&gt; class discrete_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class IntType = int&gt; class discrete_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">discrete_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Discrete distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(IntType)</Data></Cell>
    <Cell><Data ss:Type="String">An integer type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">exponential_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Exponential distribution (class template)\t\nProto: template &lt;class RealType = double&gt; class exponential_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType = double&gt; class exponential_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">exponential_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Exponential distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">extreme_value_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Extreme Value distribution (class template)\t\nProto: template &lt;class RealType = double&gt; class extreme_value_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType = double&gt; class extreme_value_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">extreme_value_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Extreme Value distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fisher_f_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Fisher F-distribution (class template)\t\nProto: template &lt;class RealType = double&gt; class fisher_f_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType = double&gt; class fisher_f_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">fisher_f_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Fisher F-distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">gamma_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Gamma distribution (class template)\t\nProto: template &lt;class RealType = double&gt; class gamma_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType = double&gt; class gamma_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">gamma_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Gamma distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">geometric_distribution(IntType)Param: (An integer type.)\t\nDesc: Geometric distribution (class template)\t\nProto: template &lt;class IntType = int&gt; class geometric_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class IntType = int&gt; class geometric_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">geometric_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Geometric distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(IntType)</Data></Cell>
    <Cell><Data ss:Type="String">An integer type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">lognormal_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Lognormal distribution (class template)\t\nProto: template &lt;class RealType = double&gt; class lognormal_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType = double&gt; class lognormal_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">lognormal_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Lognormal distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">negative_binomial_distribution(IntType)Param: (An integer type.)\t\nDesc: Negative binomial distribution (class template)\t\nProto: template &lt;class IntType = int&gt; class negative_binomial_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class IntType = int&gt; class negative_binomial_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">negative_binomial_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Negative binomial distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(IntType)</Data></Cell>
    <Cell><Data ss:Type="String">An integer type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">piecewise_constant_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Piecewise constant distribution (class template)\t\nProto: template &lt;class RealType = double&gt; class piecewise_constant_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType = double&gt; class piecewise_constant_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">piecewise_constant_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Piecewise constant distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">piecewise_linear_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Piecewise linear distribution (class template)\t\nProto: template &lt;class RealType = double&gt; class piecewise_linear_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType = double&gt; class piecewise_linear_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">piecewise_linear_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Piecewise linear distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">poisson_distribution(IntType)Param: (An integer type.)\t\nDesc: Poisson distribution (class template)\t\nProto: template &lt;class IntType = int&gt; class poisson_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class IntType = int&gt; class poisson_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">poisson_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Poisson distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(IntType)</Data></Cell>
    <Cell><Data ss:Type="String">An integer type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">student_t_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Student T-Distribution (class template)\t\nProto: template &lt;class RealType = double&gt; class student_t_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType = double&gt; class student_t_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">student_t_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Student T-Distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">uniform_int_distribution(IntType)Param: (An integer type.)\t\nDesc: Uniform discrete distribution (class template)\t\nProto: template &lt;class IntType = int&gt; class uniform_int_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class IntType = int&gt; class uniform_int_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">uniform_int_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Uniform discrete distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(IntType)</Data></Cell>
    <Cell><Data ss:Type="String">An integer type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">uniform_real_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Uniform real distribution (class template)\t\nProto: template &lt;class RealType = double&gt; class uniform_real_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType = double&gt; class uniform_real_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">uniform_real_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Uniform real distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">weibull_distribution(RealType)Param: (A floating-point type.)\t\nDesc: Weibull distribution (class template)\t\nProto: template &lt;class RealType = double&gt; class weibull_distribution;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType = double&gt; class weibull_distribution;</Data></Cell>
    <Cell><Data ss:Type="String">weibull_distribution</Data></Cell>
    <Cell><Data ss:Type="String">Weibull distribution (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">default_random_engine()Param: ()\t\nDesc: Default random engine (class)\t\nProto: no-proto\t\n[cpp11] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">default_random_engine</Data></Cell>
    <Cell><Data ss:Type="String">Default random engine (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">discard_block_engine(Engine)Param: (A random number engine type.)\t\nDesc: Discard-block random number engine adaptor (class template)\t\nProto: template &lt;class Engine, size_t p, size_t r&gt;\t\nclass discard_block_engine;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Engine, size_t p, size_t r&gt;\t\nclass discard_block_engine;</Data></Cell>
    <Cell><Data ss:Type="String">discard_block_engine</Data></Cell>
    <Cell><Data ss:Type="String">Discard-block random number engine adaptor (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Engine)</Data></Cell>
    <Cell><Data ss:Type="String">A random number engine type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">independent_bits_engine(Engine)Param: (A random number engine type.)\t\nDesc: Independent-bits random number engine adaptor (class template)\t\nProto: template &lt;class Engine, size_t w, class UIntType&gt;\t\nclass independent_bits_engine;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Engine, size_t w, class UIntType&gt;\t\nclass independent_bits_engine;</Data></Cell>
    <Cell><Data ss:Type="String">independent_bits_engine</Data></Cell>
    <Cell><Data ss:Type="String">Independent-bits random number engine adaptor (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Engine)</Data></Cell>
    <Cell><Data ss:Type="String">A random number engine type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">knuth_b()Param: ()\t\nDesc: Knuth-B generator (class)\t\nProto: typedef shuffle_order_engine &lt;minstd_rand0,256&gt; knuth_b;\t\n[cpp11] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef shuffle_order_engine &lt;minstd_rand0,256&gt; knuth_b;</Data></Cell>
    <Cell><Data ss:Type="String">knuth_b</Data></Cell>
    <Cell><Data ss:Type="String">Knuth-B generator (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">linear_congruential_engine(UIntType)Param: (An unsigned integer type.)\t\nDesc: Linear congruential random number engine (class template)\t\nProto: template &lt;class UIntType, UIntType a, UIntType c, UIntType m&gt;\t\nclass linear_congruential_engine;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class UIntType, UIntType a, UIntType c, UIntType m&gt;\t\nclass linear_congruential_engine;</Data></Cell>
    <Cell><Data ss:Type="String">linear_congruential_engine</Data></Cell>
    <Cell><Data ss:Type="String">Linear congruential random number engine (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(UIntType)</Data></Cell>
    <Cell><Data ss:Type="String">An unsigned integer type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mersenne_twister_engine(UIntType)Param: (An unsigned integer type.)\t\nDesc: Mersenne twister random number engine (class template)\t\nProto: template &lt;class UIntType, size_t w, size_t n, size_t m, size_t r,UIntType a, size_t u, UIntType d, size_t s,UIntType b, size_t t,UIntType c, size_t l, UIntType f&gt;\t\nclass mersenne_twister_engine;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class UIntType, size_t w, size_t n, size_t m, size_t r,UIntType a, size_t u, UIntType d, size_t s,UIntType b, size_t t,UIntType c, size_t l, UIntType f&gt;\t\nclass mersenne_twister_engine;</Data></Cell>
    <Cell><Data ss:Type="String">mersenne_twister_engine</Data></Cell>
    <Cell><Data ss:Type="String">Mersenne twister random number engine (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(UIntType)</Data></Cell>
    <Cell><Data ss:Type="String">An unsigned integer type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">minstd_rand()Param: ()\t\nDesc: Minimal Standard minstd_rand generator (class)\t\nProto: typedef linear_congruential_engine&lt;uint_fast32_t, 48271, 0, 2147483647&gt; minstd_rand;\t\n[cpp11] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef linear_congruential_engine&lt;uint_fast32_t, 48271, 0, 2147483647&gt; minstd_rand;</Data></Cell>
    <Cell><Data ss:Type="String">minstd_rand</Data></Cell>
    <Cell><Data ss:Type="String">Minimal Standard minstd_rand generator (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">minstd_rand0()Param: ()\t\nDesc: Minimal Standard minstd_rand0 generator (class)\t\nProto: typedef linear_congruential_engine&lt;uint_fast32_t, 16807, 0, 2147483647&gt; minstd_rand0;\t\n[cpp11] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef linear_congruential_engine&lt;uint_fast32_t, 16807, 0, 2147483647&gt; minstd_rand0;</Data></Cell>
    <Cell><Data ss:Type="String">minstd_rand0</Data></Cell>
    <Cell><Data ss:Type="String">Minimal Standard minstd_rand0 generator (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mt19937()Param: ()\t\nDesc: Mersenne Twister 19937 generator (class)\t\nProto: typedef mersenne_twister_engine&lt;uint_fast32_t,\t\n32,624,397,31,0x9908b0df,11,0xffffffff,7,0x9d2c5680,15,0xefc60000,18,1812433253&gt;\t\nmt19937;\t\n[cpp11] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef mersenne_twister_engine&lt;uint_fast32_t,\t\n32,624,397,31,0x9908b0df,11,0xffffffff,7,0x9d2c5680,15,0xefc60000,18,1812433253&gt;\t\nmt19937;</Data></Cell>
    <Cell><Data ss:Type="String">mt19937</Data></Cell>
    <Cell><Data ss:Type="String">Mersenne Twister 19937 generator (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mt19937_64()Param: ()\t\nDesc: Mersene Twister 19937 generator (64 bit) (class)\t\nProto: typedef mersenne_twister_engine&lt;uint_fast64_t,\t\n64,312,156,31,0xb5026f5aa96619e9,\t\n29,0x5555555555555555,\t\n17,0x71d67fffeda60000,\t\n37,0xfff7eee000000000,\t\n43,6364136223846793005&gt; mt19937_64;\t\n[cpp11] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef mersenne_twister_engine&lt;uint_fast64_t,\t\n64,312,156,31,0xb5026f5aa96619e9,\t\n29,0x5555555555555555,\t\n17,0x71d67fffeda60000,\t\n37,0xfff7eee000000000,\t\n43,6364136223846793005&gt; mt19937_64;</Data></Cell>
    <Cell><Data ss:Type="String">mt19937_64</Data></Cell>
    <Cell><Data ss:Type="String">Mersene Twister 19937 generator (64 bit) (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">random_device()Param: ()\t\nDesc: True random number generator (class)\t\nProto: class random_device;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class random_device;</Data></Cell>
    <Cell><Data ss:Type="String">random_device</Data></Cell>
    <Cell><Data ss:Type="String">True random number generator (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ranlux24()Param: ()\t\nDesc: Ranlux 24 generator (class)\t\nProto: typedef discard_block_engine &lt;ranlux24_base, 223, 23&gt; ranlux24;\t\n[cpp11] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef discard_block_engine &lt;ranlux24_base, 223, 23&gt; ranlux24;</Data></Cell>
    <Cell><Data ss:Type="String">ranlux24</Data></Cell>
    <Cell><Data ss:Type="String">Ranlux 24 generator (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ranlux24_base()Param: ()\t\nDesc: Ranlux 24 base generator (class)\t\nProto: typedef subtract_with_carry_engine &lt;uint_fast32_t, 24, 10, 24&gt; ranlux24_base;\t\n[cpp11] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef subtract_with_carry_engine &lt;uint_fast32_t, 24, 10, 24&gt; ranlux24_base;</Data></Cell>
    <Cell><Data ss:Type="String">ranlux24_base</Data></Cell>
    <Cell><Data ss:Type="String">Ranlux 24 base generator (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ranlux48()Param: ()\t\nDesc: Ranlux 48 generator (class)\t\nProto: typedef discard_block_engine &lt;ranlux48_base, 389, 11&gt; ranlux48;\t\n[cpp11] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef discard_block_engine &lt;ranlux48_base, 389, 11&gt; ranlux48;</Data></Cell>
    <Cell><Data ss:Type="String">ranlux48</Data></Cell>
    <Cell><Data ss:Type="String">Ranlux 48 generator (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ranlux48_base()Param: ()\t\nDesc: Ranlux 48 base generator (class)\t\nProto: typedef subtract_with_carry_engine &lt;uint_fast64_t, 48, 5, 12&gt; ranlux48_base;\t\n[cpp11] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef subtract_with_carry_engine &lt;uint_fast64_t, 48, 5, 12&gt; ranlux48_base;</Data></Cell>
    <Cell><Data ss:Type="String">ranlux48_base</Data></Cell>
    <Cell><Data ss:Type="String">Ranlux 48 base generator (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">shuffle_order_engine(Engine)Param: (A random number engine type.)\t\nDesc: Shuffle-order random number engine adaptor (class template)\t\nProto: template &lt;class Engine, size_t k&gt; class shuffle_order_engine;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Engine, size_t k&gt; class shuffle_order_engine;</Data></Cell>
    <Cell><Data ss:Type="String">shuffle_order_engine</Data></Cell>
    <Cell><Data ss:Type="String">Shuffle-order random number engine adaptor (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Engine)</Data></Cell>
    <Cell><Data ss:Type="String">A random number engine type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">subtract_with_carry_engine(UIntType)Param: (An unsigned integer type.)\t\nDesc: Subtract-with-carry random number engine (class template)\t\nProto: template &lt;class UIntType, size_t w, size_t s, size_t r&gt;\t\nclass subtract_with_carry_engine;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class UIntType, size_t w, size_t s, size_t r&gt;\t\nclass subtract_with_carry_engine;</Data></Cell>
    <Cell><Data ss:Type="String">subtract_with_carry_engine</Data></Cell>
    <Cell><Data ss:Type="String">Subtract-with-carry random number engine (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(UIntType)</Data></Cell>
    <Cell><Data ss:Type="String">An unsigned integer type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">seed_seq()Param: ()\t\nDesc: Seed sequence (class)\t\nProto: class seed_seq;\t\n[cpp11 ] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class seed_seq;</Data></Cell>
    <Cell><Data ss:Type="String">seed_seq</Data></Cell>
    <Cell><Data ss:Type="String">Seed sequence (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ratio_add(R1,R2)Param: (ratio types to be added.)\t\nDesc: Add two ratios (class template)\t\nProto: template &lt;class R1, class R2&gt; ratio_add;\t\n[cpp11] [&lt;ratio&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class R1, class R2&gt; ratio_add;</Data></Cell>
    <Cell><Data ss:Type="String">ratio_add</Data></Cell>
    <Cell><Data ss:Type="String">Add two ratios (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(R1,R2)</Data></Cell>
    <Cell><Data ss:Type="String">ratio types to be added.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ratio&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Ratio header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ratio_divide(R1,R2)Param: (ratio types to be divided.)\t\nDesc: Divide ratios (class template)\t\nProto: template &lt;class R1, class R2&gt; ratio_divide;\t\n[cpp11] [&lt;ratio&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class R1, class R2&gt; ratio_divide;</Data></Cell>
    <Cell><Data ss:Type="String">ratio_divide</Data></Cell>
    <Cell><Data ss:Type="String">Divide ratios (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(R1,R2)</Data></Cell>
    <Cell><Data ss:Type="String">ratio types to be divided.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ratio&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Ratio header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ratio_equal(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios (class template)\t\nProto: template &lt;class R1, class R2&gt; ratio_equal;\t\n[cpp11] [&lt;ratio&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class R1, class R2&gt; ratio_equal;</Data></Cell>
    <Cell><Data ss:Type="String">ratio_equal</Data></Cell>
    <Cell><Data ss:Type="String">Compare ratios (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(R1,R2)</Data></Cell>
    <Cell><Data ss:Type="String">ratio types to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ratio&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Ratio header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ratio_greater(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for greater than inequality (class template)\t\nProto: template &lt;class R1, class R2&gt; ratio_greater;\t\n[cpp11] [&lt;ratio&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class R1, class R2&gt; ratio_greater;</Data></Cell>
    <Cell><Data ss:Type="String">ratio_greater</Data></Cell>
    <Cell><Data ss:Type="String">Compare ratios for greater than inequality (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(R1,R2)</Data></Cell>
    <Cell><Data ss:Type="String">ratio types to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ratio&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Ratio header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ratio_greater_equal(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for equality or greater-than inequality (class template)\t\nProto: template &lt;class R1, class R2&gt; ratio_greater_equal;\t\n[cpp11] [&lt;ratio&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class R1, class R2&gt; ratio_greater_equal;</Data></Cell>
    <Cell><Data ss:Type="String">ratio_greater_equal</Data></Cell>
    <Cell><Data ss:Type="String">Compare ratios for equality or greater-than inequality (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(R1,R2)</Data></Cell>
    <Cell><Data ss:Type="String">ratio types to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ratio&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Ratio header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ratio_less(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for less-than inequality (class template)\t\nProto: template &lt;class R1, class R2&gt; ratio_less;\t\n[cpp11] [&lt;ratio&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class R1, class R2&gt; ratio_less;</Data></Cell>
    <Cell><Data ss:Type="String">ratio_less</Data></Cell>
    <Cell><Data ss:Type="String">Compare ratios for less-than inequality (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(R1,R2)</Data></Cell>
    <Cell><Data ss:Type="String">ratio types to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ratio&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Ratio header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ratio_less_equal(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for equality or less-than inequality (class template)\t\nProto: template &lt;class R1, class R2&gt; ratio_less_equal;\t\n[cpp11] [&lt;ratio&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class R1, class R2&gt; ratio_less_equal;</Data></Cell>
    <Cell><Data ss:Type="String">ratio_less_equal</Data></Cell>
    <Cell><Data ss:Type="String">Compare ratios for equality or less-than inequality (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(R1,R2)</Data></Cell>
    <Cell><Data ss:Type="String">ratio types to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ratio&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Ratio header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ratio_multiply(R1,R2)Param: (ratio types to be multiplied.)\t\nDesc: Multiply two ratios (class template)\t\nProto: template &lt;class R1, class R2&gt; ratio_multiply;\t\n[cpp11] [&lt;ratio&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class R1, class R2&gt; ratio_multiply;</Data></Cell>
    <Cell><Data ss:Type="String">ratio_multiply</Data></Cell>
    <Cell><Data ss:Type="String">Multiply two ratios (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(R1,R2)</Data></Cell>
    <Cell><Data ss:Type="String">ratio types to be multiplied.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ratio&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Ratio header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ratio_not_equal(R1,R2)Param: (ratio types to be compared.)\t\nDesc: Compare ratios for inequality (class template)\t\nProto: template &lt;class R1, class R2&gt; ratio_not_equal;\t\n[cpp11] [&lt;ratio&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class R1, class R2&gt; ratio_not_equal;</Data></Cell>
    <Cell><Data ss:Type="String">ratio_not_equal</Data></Cell>
    <Cell><Data ss:Type="String">Compare ratios for inequality (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(R1,R2)</Data></Cell>
    <Cell><Data ss:Type="String">ratio types to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ratio&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Ratio header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ratio_subtract(R1,R2)Param: (ratio types to be subtracted.)\t\nDesc: Subtract ratios (class template)\t\nProto: template &lt;class R1, class R2&gt; ratio_subtract;\t\n[cpp11] [&lt;ratio&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class R1, class R2&gt; ratio_subtract;</Data></Cell>
    <Cell><Data ss:Type="String">ratio_subtract</Data></Cell>
    <Cell><Data ss:Type="String">Subtract ratios (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(R1,R2)</Data></Cell>
    <Cell><Data ss:Type="String">ratio types to be subtracted.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ratio&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Ratio header</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ECMAScript syntax()Param: ()\t\nDesc: ECMAScript regular expressions pattern syntax (syntax specifications)\t\nProto: no-proto\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">ECMAScript syntax</Data></Cell>
    <Cell><Data ss:Type="String">ECMAScript regular expressions pattern syntax (syntax specifications)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">syntax specifications</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">regex_constants()Param: ()\t\nDesc: regex constants (namespace)\t\nProto: no-proto\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">no-proto</Data></Cell>
    <Cell><Data ss:Type="String">regex_constants</Data></Cell>
    <Cell><Data ss:Type="String">regex constants (namespace)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">namespace</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">basic_regex(charT)Param: (The character type.)\t\nDesc: Regular expression (class template)\t\nProto: template &lt;class charT, class traits = regex_traits&lt;charT&gt; &gt; class basic_regex;\t\n[cpp11 ] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class traits = regex_traits&lt;charT&gt; &gt; class basic_regex;</Data></Cell>
    <Cell><Data ss:Type="String">basic_regex</Data></Cell>
    <Cell><Data ss:Type="String">Regular expression (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">The character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">match_results(BidirectionalIterator)Param: (A bidirectional iterator type that iterates on the target sequence of characters.)\t\nDesc: Match results (class template)\t\nProto: template &lt; class BidirectionalIterator, class Alloc = allocator&lt; sub_match&lt;BidirectionalIterator&gt; &gt; &gt; class match_results;\t\n[cpp11 ] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt; class BidirectionalIterator, class Alloc = allocator&lt; sub_match&lt;BidirectionalIterator&gt; &gt; &gt; class match_results;</Data></Cell>
    <Cell><Data ss:Type="String">match_results</Data></Cell>
    <Cell><Data ss:Type="String">Match results (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(BidirectionalIterator)</Data></Cell>
    <Cell><Data ss:Type="String">A bidirectional iterator type that iterates on the target sequence of characters.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">regex_error()Param: ()\t\nDesc: Regex exception (class)\t\nProto: class regex_error : public runtime_error { /* ... */ };\t\n[cpp11 ] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class regex_error : public runtime_error { /* ... */ };</Data></Cell>
    <Cell><Data ss:Type="String">regex_error</Data></Cell>
    <Cell><Data ss:Type="String">Regex exception (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">regex_iterator(BidirectionalIterator)Param: (A bidirectional iterator type that iterates on the target sequence of characters.)\t\nDesc: Regex iterator (class template)\t\nProto: template &lt;class BidirectionalIterator,class charT=typename iterator_traits&lt;BidirectionalIterator&gt;::value_type,class traits=regex_traits&lt;charT&gt; &gt; class regex_iterator;\t\n[cpp11 ] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class BidirectionalIterator,class charT=typename iterator_traits&lt;BidirectionalIterator&gt;::value_type,class traits=regex_traits&lt;charT&gt; &gt; class regex_iterator;</Data></Cell>
    <Cell><Data ss:Type="String">regex_iterator</Data></Cell>
    <Cell><Data ss:Type="String">Regex iterator (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(BidirectionalIterator)</Data></Cell>
    <Cell><Data ss:Type="String">A bidirectional iterator type that iterates on the target sequence of characters.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">regex_token_iterator(BidirectionalIterator)Param: (A bidirectional iterator type that iterates on the target sequence of characters.)\t\nDesc: Regex token iterator (class template)\t\nProto: template &lt;class BidirectionalIterator,class charT=typename iterator_traits&lt;BidirectionalIterator&gt;::value_type,class traits=regex_traits&lt;charT&gt; &gt; class regex_token_iterator;\t\n[cpp11 ] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class BidirectionalIterator,class charT=typename iterator_traits&lt;BidirectionalIterator&gt;::value_type,class traits=regex_traits&lt;charT&gt; &gt; class regex_token_iterator;</Data></Cell>
    <Cell><Data ss:Type="String">regex_token_iterator</Data></Cell>
    <Cell><Data ss:Type="String">Regex token iterator (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(BidirectionalIterator)</Data></Cell>
    <Cell><Data ss:Type="String">A bidirectional iterator type that iterates on the target sequence of characters.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">regex_traits(charT)Param: (The character type.)\t\nDesc: Regex traits (class template)\t\nProto: template &lt;class charT&gt; class regex_traits;\t\n[cpp11 ] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT&gt; class regex_traits;</Data></Cell>
    <Cell><Data ss:Type="String">regex_traits</Data></Cell>
    <Cell><Data ss:Type="String">Regex traits (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">The character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">sub_match(BidirectionalIterator)Param: (A bidirectional iterator type that iterates on a sequence of characters.)\t\nDesc: Sub-expression match (class template)\t\nProto: template &lt;class BidirectionalIterator&gt;\t\nclass sub_match : public pair &lt;BidirectionalIterator, BidirectionalIterator&gt;;\t\n[cpp11 ] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class BidirectionalIterator&gt;\t\nclass sub_match : public pair &lt;BidirectionalIterator, BidirectionalIterator&gt;;</Data></Cell>
    <Cell><Data ss:Type="String">sub_match</Data></Cell>
    <Cell><Data ss:Type="String">Sub-expression match (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(BidirectionalIterator)</Data></Cell>
    <Cell><Data ss:Type="String">A bidirectional iterator type that iterates on a sequence of characters.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">cmatch()Param: ()\t\nDesc: match_results for string literals (class)\t\nProto: typedef match_results&lt;const char*&gt; cmatch;\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef match_results&lt;const char*&gt; cmatch;</Data></Cell>
    <Cell><Data ss:Type="String">cmatch</Data></Cell>
    <Cell><Data ss:Type="String">match_results for string literals (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">csub_match()Param: ()\t\nDesc: sub_match for string literals (class)\t\nProto: typedef sub_match&lt;const char*&gt; csub_match;\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef sub_match&lt;const char*&gt; csub_match;</Data></Cell>
    <Cell><Data ss:Type="String">csub_match</Data></Cell>
    <Cell><Data ss:Type="String">sub_match for string literals (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ssub_match()Param: ()\t\nDesc: sub_match for strings (class)\t\nProto: typedef sub_match&lt;string::const_iterator&gt; ssub_match;\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef sub_match&lt;string::const_iterator&gt; ssub_match;</Data></Cell>
    <Cell><Data ss:Type="String">ssub_match</Data></Cell>
    <Cell><Data ss:Type="String">sub_match for strings (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcmatch()Param: ()\t\nDesc: match_results for wide string literals (class)\t\nProto: typedef match_results&lt;const wchar_t*&gt; wcmatch;\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef match_results&lt;const wchar_t*&gt; wcmatch;</Data></Cell>
    <Cell><Data ss:Type="String">wcmatch</Data></Cell>
    <Cell><Data ss:Type="String">match_results for wide string literals (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcsub_match()Param: ()\t\nDesc: sub_match for wide string literals (class)\t\nProto: typedef sub_match&lt;const wchar_t*&gt; csub_match;\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef sub_match&lt;const wchar_t*&gt; csub_match;</Data></Cell>
    <Cell><Data ss:Type="String">wcsub_match</Data></Cell>
    <Cell><Data ss:Type="String">sub_match for wide string literals (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wregex()Param: ()\t\nDesc: Regex for wchar_t (class)\t\nProto: typedef basic_regex&lt;wchar_t&gt; wregex;\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_regex&lt;wchar_t&gt; wregex;</Data></Cell>
    <Cell><Data ss:Type="String">wregex</Data></Cell>
    <Cell><Data ss:Type="String">Regex for wchar_t (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wsmatch()Param: ()\t\nDesc: match_results for wide string objects (class)\t\nProto: typedef match_results&lt;wstring::const_iterator&gt; smatch;\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef match_results&lt;wstring::const_iterator&gt; smatch;</Data></Cell>
    <Cell><Data ss:Type="String">wsmatch</Data></Cell>
    <Cell><Data ss:Type="String">match_results for wide string objects (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wssub_match()Param: ()\t\nDesc: sub_match for wide strings (class)\t\nProto: typedef sub_match&lt;wstring::const_iterator&gt; ssub_match;\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef sub_match&lt;wstring::const_iterator&gt; ssub_match;</Data></Cell>
    <Cell><Data ss:Type="String">wssub_match</Data></Cell>
    <Cell><Data ss:Type="String">sub_match for wide strings (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">regex_replace(s)Param: (A string with the target sequence (the subject).)\t\nDesc: Replace matched sequence (function template)\t\nProto: long-proto\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">regex_replace</Data></Cell>
    <Cell><Data ss:Type="String">Replace matched sequence (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(s)</Data></Cell>
    <Cell><Data ss:Type="String">A string with the target sequence (the subject).</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">domain_error()Param: ()\t\nDesc: Domain error exception (class)\t\nProto: class domain_error;\t\n[cpp98 cpp11] [&lt;stdexcept&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class domain_error;</Data></Cell>
    <Cell><Data ss:Type="String">domain_error</Data></Cell>
    <Cell><Data ss:Type="String">Domain error exception (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;stdexcept&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Exception classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">invalid_argument()Param: ()\t\nDesc: Invalid argument exception (class)\t\nProto: class invalid_argument;\t\n[cpp98 cpp11] [&lt;stdexcept&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class invalid_argument;</Data></Cell>
    <Cell><Data ss:Type="String">invalid_argument</Data></Cell>
    <Cell><Data ss:Type="String">Invalid argument exception (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;stdexcept&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Exception classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">length_error()Param: ()\t\nDesc: Length error exception (class)\t\nProto: class length_error;\t\n[cpp98 cpp11] [&lt;stdexcept&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class length_error;</Data></Cell>
    <Cell><Data ss:Type="String">length_error</Data></Cell>
    <Cell><Data ss:Type="String">Length error exception (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;stdexcept&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Exception classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">logic_error()Param: ()\t\nDesc: Logic error exception (class)\t\nProto: class logic_error;\t\n[cpp98 cpp11] [&lt;stdexcept&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class logic_error;</Data></Cell>
    <Cell><Data ss:Type="String">logic_error</Data></Cell>
    <Cell><Data ss:Type="String">Logic error exception (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;stdexcept&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Exception classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">out_of_range()Param: ()\t\nDesc: Out-of-range exception (class)\t\nProto: class out_of_range;\t\n[cpp98 cpp11] [&lt;stdexcept&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class out_of_range;</Data></Cell>
    <Cell><Data ss:Type="String">out_of_range</Data></Cell>
    <Cell><Data ss:Type="String">Out-of-range exception (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;stdexcept&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Exception classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">overflow_error()Param: ()\t\nDesc: Overflow error exception (class)\t\nProto: class overflow_error;\t\n[cpp98 cpp11] [&lt;stdexcept&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class overflow_error;</Data></Cell>
    <Cell><Data ss:Type="String">overflow_error</Data></Cell>
    <Cell><Data ss:Type="String">Overflow error exception (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;stdexcept&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Exception classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">range_error()Param: ()\t\nDesc: Range error exception (class)\t\nProto: class range_error;\t\n[cpp98 cpp11] [&lt;stdexcept&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class range_error;</Data></Cell>
    <Cell><Data ss:Type="String">range_error</Data></Cell>
    <Cell><Data ss:Type="String">Range error exception (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;stdexcept&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Exception classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">runtime_error()Param: ()\t\nDesc: Runtime error exception (class)\t\nProto: class runtime_error;\t\n[cpp98 cpp11] [&lt;stdexcept&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class runtime_error;</Data></Cell>
    <Cell><Data ss:Type="String">runtime_error</Data></Cell>
    <Cell><Data ss:Type="String">Runtime error exception (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;stdexcept&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Exception classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">underflow_error()Param: ()\t\nDesc: Underflow error exception (class)\t\nProto: class underflow_error;\t\n[cpp98 cpp11] [&lt;stdexcept&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class underflow_error;</Data></Cell>
    <Cell><Data ss:Type="String">underflow_error</Data></Cell>
    <Cell><Data ss:Type="String">Underflow error exception (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;stdexcept&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Exception classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">char_traits(charT)Param: (Character type.)\t\nDesc: Character traits (class template)\t\nProto: template &lt;class charT&gt; struct char_traits;template &lt;&gt; struct char_traits&lt;char&gt;;template &lt;&gt; struct char_traits&lt;wchar_t&gt;;\t\n[cpp98 cpp11 ] [&lt;string&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT&gt; struct char_traits;template &lt;&gt; struct char_traits&lt;char&gt;;template &lt;&gt; struct char_traits&lt;wchar_t&gt;;</Data></Cell>
    <Cell><Data ss:Type="String">char_traits</Data></Cell>
    <Cell><Data ss:Type="String">Character traits (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(charT)</Data></Cell>
    <Cell><Data ss:Type="String">Character type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;string&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">u16string()Param: ()\t\nDesc: String of 16-bit characters (class)\t\nProto: typedef basic_string&lt;char16_t&gt; u16string;\t\n[cpp11] [&lt;string&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_string&lt;char16_t&gt; u16string;</Data></Cell>
    <Cell><Data ss:Type="String">u16string</Data></Cell>
    <Cell><Data ss:Type="String">String of 16-bit characters (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;string&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">u32string()Param: ()\t\nDesc: String of 32-bit characters (class)\t\nProto: typedef basic_string&lt;char32_t&gt; u32string;\t\n[cpp11] [&lt;string&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef basic_string&lt;char32_t&gt; u32string;</Data></Cell>
    <Cell><Data ss:Type="String">u32string</Data></Cell>
    <Cell><Data ss:Type="String">String of 32-bit characters (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;string&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">to_string(val)Param: (Numerical value.)\t\nDesc: Convert numerical value to string (function)\t\nProto: long-proto\t\n[cpp11] [&lt;string&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">to_string</Data></Cell>
    <Cell><Data ss:Type="String">Convert numerical value to string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(val)</Data></Cell>
    <Cell><Data ss:Type="String">Numerical value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;string&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">to_wstring(val)Param: (Numerical value.)\t\nDesc: Convert numerical value to wide string (function)\t\nProto: long-proto\t\n[cpp11] [&lt;string&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">to_wstring</Data></Cell>
    <Cell><Data ss:Type="String">Convert numerical value to wide string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(val)</Data></Cell>
    <Cell><Data ss:Type="String">Numerical value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;string&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">error_category()Param: ()\t\nDesc: Error category (abstract class)\t\nProto: class error_category;\t\n[cpp11 ] [&lt;system_error&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class error_category;</Data></Cell>
    <Cell><Data ss:Type="String">error_category</Data></Cell>
    <Cell><Data ss:Type="String">Error category (abstract class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">abstract class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;system_error&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">System errors</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">error_code()Param: ()\t\nDesc: Error code (class)\t\nProto: class error_code;\t\n[cpp11 ] [&lt;system_error&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class error_code;</Data></Cell>
    <Cell><Data ss:Type="String">error_code</Data></Cell>
    <Cell><Data ss:Type="String">Error code (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;system_error&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">System errors</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">error_condition()Param: ()\t\nDesc: Error condition (class)\t\nProto: class error_condition;\t\n[cpp11 ] [&lt;system_error&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class error_condition;</Data></Cell>
    <Cell><Data ss:Type="String">error_condition</Data></Cell>
    <Cell><Data ss:Type="String">Error condition (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;system_error&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">System errors</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_error_code_enum(T)Param: (A type.)\t\nDesc: error_code enum flag (class)\t\nProto: template &lt;class T&gt;\t\nstruct is_error_code_enum : public false_type {};\t\n[cpp11] [&lt;system_error&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt;\t\nstruct is_error_code_enum : public false_type {};</Data></Cell>
    <Cell><Data ss:Type="String">is_error_code_enum</Data></Cell>
    <Cell><Data ss:Type="String">error_code enum flag (class)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;system_error&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">System errors</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_error_condition_enum(T)Param: (A type.)\t\nDesc: error_condition enum flag (class)\t\nProto: template &lt;class T&gt;\t\nstruct is_error_condition_enum : public false_type {};template&lt;&gt;\t\nstruct is_error_condition_enum&lt;errc&gt; : true_type {};\t\n[cpp11] [&lt;system_error&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt;\t\nstruct is_error_condition_enum : public false_type {};template&lt;&gt;\t\nstruct is_error_condition_enum&lt;errc&gt; : true_type {};</Data></Cell>
    <Cell><Data ss:Type="String">is_error_condition_enum</Data></Cell>
    <Cell><Data ss:Type="String">error_condition enum flag (class)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;system_error&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">System errors</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">system_error()Param: ()\t\nDesc: System error exception (class)\t\nProto: class system_error : public runtime_error;\t\n[cpp11 ] [&lt;system_error&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class system_error : public runtime_error;</Data></Cell>
    <Cell><Data ss:Type="String">system_error</Data></Cell>
    <Cell><Data ss:Type="String">System error exception (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;system_error&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">System errors</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">tuple(Types...)Param: (A list of types used for the elements, in the same order as they are going to be ordered in the tuple.)\t\nDesc: Tuple (class template)\t\nProto: template &lt;class... Types&gt; class tuple;\t\n[cpp11 ] [&lt;tuple&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class... Types&gt; class tuple;</Data></Cell>
    <Cell><Data ss:Type="String">tuple</Data></Cell>
    <Cell><Data ss:Type="String">Tuple (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Types...)</Data></Cell>
    <Cell><Data ss:Type="String">A list of types used for the elements, in the same order as they are going to be ordered in the tuple.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;tuple&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Tuple library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">tuple_element(I)Param: (Order number of the element within the tuple (zero-based).)\t\nDesc: Tuple element type (class template)\t\nProto: long-proto\t\n[cpp11] [&lt;tuple&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">tuple_element</Data></Cell>
    <Cell><Data ss:Type="String">Tuple element type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(I)</Data></Cell>
    <Cell><Data ss:Type="String">Order number of the element within the tuple (zero-based).</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;tuple&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Tuple library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">tuple_size(T)Param: (Type for which the tuple size is obtained.)\t\nDesc: Tuple size traits (class template)\t\nProto: long-proto\t\n[cpp11] [&lt;tuple&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">tuple_size</Data></Cell>
    <Cell><Data ss:Type="String">Tuple size traits (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type for which the tuple size is obtained.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;tuple&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Tuple library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ignore()Param: ()\t\nDesc: Ignore assignment (object)\t\nProto: const ignore;\t\n[cpp11] [&lt;tuple&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">const ignore;</Data></Cell>
    <Cell><Data ss:Type="String">ignore</Data></Cell>
    <Cell><Data ss:Type="String">Ignore assignment (object)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">object</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;tuple&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Tuple library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">type_index()Param: ()\t\nDesc: Type index (class)\t\nProto: class type_index;\t\n[cpp11 ] [&lt;typeindex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class type_index;</Data></Cell>
    <Cell><Data ss:Type="String">type_index</Data></Cell>
    <Cell><Data ss:Type="String">Type index (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;typeindex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Type index</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bad_cast()Param: ()\t\nDesc: Exception thrown on failure to dynamic cast (class)\t\nProto: class bad_cast;\t\n[cpp98 cpp11] [&lt;typeinfo&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class bad_cast;</Data></Cell>
    <Cell><Data ss:Type="String">bad_cast</Data></Cell>
    <Cell><Data ss:Type="String">Exception thrown on failure to dynamic cast (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;typeinfo&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Type information</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bad_typeid()Param: ()\t\nDesc: Exception thrown on typeid of null pointer (class)\t\nProto: class bad_typeid;\t\n[cpp98 cpp11] [&lt;typeinfo&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class bad_typeid;</Data></Cell>
    <Cell><Data ss:Type="String">bad_typeid</Data></Cell>
    <Cell><Data ss:Type="String">Exception thrown on typeid of null pointer (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;typeinfo&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Type information</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">type_info()Param: ()\t\nDesc: Type information type (class)\t\nProto: class type_info;\t\n[cpp98 cpp11 ] [&lt;typeinfo&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class type_info;</Data></Cell>
    <Cell><Data ss:Type="String">type_info</Data></Cell>
    <Cell><Data ss:Type="String">Type information type (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;typeinfo&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Type information</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">false_type()Param: ()\t\nDesc: False type (class)\t\nProto: typedef integral_constant&lt;bool,false&gt; false_type;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef integral_constant&lt;bool,false&gt; false_type;</Data></Cell>
    <Cell><Data ss:Type="String">false_type</Data></Cell>
    <Cell><Data ss:Type="String">False type (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">integral_constant(T)Param: (Type of the integral constant.)\t\nDesc: Integral constant (class template)\t\nProto: template &lt;class T, T v&gt;struct integral_constant;\t\n[cpp11 ] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, T v&gt;struct integral_constant;</Data></Cell>
    <Cell><Data ss:Type="String">integral_constant</Data></Cell>
    <Cell><Data ss:Type="String">Integral constant (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the integral constant.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">true_type()Param: ()\t\nDesc: True type (class)\t\nProto: typedef integral_constant&lt;bool,true&gt; true_type;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">typedef integral_constant&lt;bool,true&gt; true_type;</Data></Cell>
    <Cell><Data ss:Type="String">true_type</Data></Cell>
    <Cell><Data ss:Type="String">True type (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">alignment_of(T)Param: (A complete object type, or an array thereof, or a reference to a complete object type.)\t\nDesc: Alignment of (class template)\t\nProto: template &lt;class T&gt; struct alignment_of;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct alignment_of;</Data></Cell>
    <Cell><Data ss:Type="String">alignment_of</Data></Cell>
    <Cell><Data ss:Type="String">Alignment of (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete object type, or an array thereof, or a reference to a complete object type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">extent(T)Param: (A type.)\t\nDesc: Array dimension extent (class template)\t\nProto: template &lt;class T, unsigned I = 0&gt; struct extent;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, unsigned I = 0&gt; struct extent;</Data></Cell>
    <Cell><Data ss:Type="String">extent</Data></Cell>
    <Cell><Data ss:Type="String">Array dimension extent (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">has_virtual_destructor(T)Param: (A complete type, or )\t\nDesc: Has virtual destructor (class template)\t\nProto: template &lt;class T&gt; struct has_virtual_destructor;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct has_virtual_destructor;</Data></Cell>
    <Cell><Data ss:Type="String">has_virtual_destructor</Data></Cell>
    <Cell><Data ss:Type="String">Has virtual destructor (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_abstract(T)Param: (A complete type, or )\t\nDesc: Is abstract class (class template)\t\nProto: template &lt;class T&gt; struct is_abstract;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_abstract;</Data></Cell>
    <Cell><Data ss:Type="String">is_abstract</Data></Cell>
    <Cell><Data ss:Type="String">Is abstract class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_arithmetic(T)Param: (A type.)\t\nDesc: Is arithmetic type (class template)\t\nProto: template &lt;class T&gt; struct is_arithmetic;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_arithmetic;</Data></Cell>
    <Cell><Data ss:Type="String">is_arithmetic</Data></Cell>
    <Cell><Data ss:Type="String">Is arithmetic type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_array(T)Param: (A type.)\t\nDesc: Is array (class template)\t\nProto: template &lt;class T&gt; struct is_array;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_array;</Data></Cell>
    <Cell><Data ss:Type="String">is_array</Data></Cell>
    <Cell><Data ss:Type="String">Is array (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_assignable(T, U)Param: (Complete types, or )\t\nDesc: Is assignable (class template)\t\nProto: template &lt;class T, class U&gt; struct is_assignable;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class U&gt; struct is_assignable;</Data></Cell>
    <Cell><Data ss:Type="String">is_assignable</Data></Cell>
    <Cell><Data ss:Type="String">Is assignable (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T, U)</Data></Cell>
    <Cell><Data ss:Type="String">Complete types, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_base_of(Base)Param: (A type.)\t\nDesc: Is base class of (class template)\t\nProto: template &lt;class Base, class Derived&gt; struct is_base_of;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Base, class Derived&gt; struct is_base_of;</Data></Cell>
    <Cell><Data ss:Type="String">is_base_of</Data></Cell>
    <Cell><Data ss:Type="String">Is base class of (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Base)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_class(T)Param: (A type.)\t\nDesc: Is non-union class (class template)\t\nProto: template &lt;class T&gt; struct is_class;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_class;</Data></Cell>
    <Cell><Data ss:Type="String">is_class</Data></Cell>
    <Cell><Data ss:Type="String">Is non-union class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_compound(T)Param: (A type.)\t\nDesc: Is compound type (class template)\t\nProto: template &lt;class T&gt; struct is_compound;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_compound;</Data></Cell>
    <Cell><Data ss:Type="String">is_compound</Data></Cell>
    <Cell><Data ss:Type="String">Is compound type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_const(T)Param: (A type.)\t\nDesc: Is const-qualified (class template)\t\nProto: template &lt;class T&gt; struct is_const;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_const;</Data></Cell>
    <Cell><Data ss:Type="String">is_const</Data></Cell>
    <Cell><Data ss:Type="String">Is const-qualified (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_constructible(T)Param: (A complete type, or )\t\nDesc: Is constructible (class template)\t\nProto: template &lt;class T, class... Args&gt; struct is_constructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class... Args&gt; struct is_constructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_constructible</Data></Cell>
    <Cell><Data ss:Type="String">Is constructible (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_convertible(From, To)Param: (Complete types, or )\t\nDesc: Is convertible (class template)\t\nProto: template &lt;class From, class To&gt; struct is_convertible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class From, class To&gt; struct is_convertible;</Data></Cell>
    <Cell><Data ss:Type="String">is_convertible</Data></Cell>
    <Cell><Data ss:Type="String">Is convertible (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(From, To)</Data></Cell>
    <Cell><Data ss:Type="String">Complete types, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_copy_assignable(T)Param: (A complete type, or )\t\nDesc: Is copy assignable (class template)\t\nProto: template &lt;class T&gt; struct is_copy_assignable;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_copy_assignable;</Data></Cell>
    <Cell><Data ss:Type="String">is_copy_assignable</Data></Cell>
    <Cell><Data ss:Type="String">Is copy assignable (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_copy_constructible(T)Param: (A complete type, or )\t\nDesc: Is copy constructible (class template)\t\nProto: template &lt;class T&gt; struct is_copy_constructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_copy_constructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_copy_constructible</Data></Cell>
    <Cell><Data ss:Type="String">Is copy constructible (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_default_constructible(T)Param: (A complete type, or )\t\nDesc: Is default constructible (class template)\t\nProto: template &lt;class T&gt; struct is_default_constructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_default_constructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_default_constructible</Data></Cell>
    <Cell><Data ss:Type="String">Is default constructible (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_destructible(T)Param: (A complete type, or )\t\nDesc: Is destructible (class template)\t\nProto: template &lt;class T&gt; struct is_destructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_destructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_destructible</Data></Cell>
    <Cell><Data ss:Type="String">Is destructible (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_empty(T)Param: (\t\nC++11\t\n\t\nC++14\t\n\t\n\t\n\t\nA complete type, or )\t\nDesc: Is empty class (class template)\t\nProto: template &lt;class T&gt; struct is_empty;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_empty;</Data></Cell>
    <Cell><Data ss:Type="String">is_empty</Data></Cell>
    <Cell><Data ss:Type="String">Is empty class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">\t\nC++11\t\n\t\nC++14\t\n\t\n\t\n\t\nA complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_enum(T)Param: (A type.)\t\nDesc: Is enum (class template)\t\nProto: template &lt;class T&gt; struct is_enum;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_enum;</Data></Cell>
    <Cell><Data ss:Type="String">is_enum</Data></Cell>
    <Cell><Data ss:Type="String">Is enum (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_floating_point(T)Param: (A type.)\t\nDesc: Is floating point (class template)\t\nProto: template &lt;class T&gt; struct is_floating_point;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_floating_point;</Data></Cell>
    <Cell><Data ss:Type="String">is_floating_point</Data></Cell>
    <Cell><Data ss:Type="String">Is floating point (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_function(T)Param: (A type.)\t\nDesc: Is function (class template)\t\nProto: template &lt;class T&gt; struct is_function;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_function;</Data></Cell>
    <Cell><Data ss:Type="String">is_function</Data></Cell>
    <Cell><Data ss:Type="String">Is function (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_fundamental(T)Param: (A type.)\t\nDesc: Is fundamental type (class template)\t\nProto: template &lt;class T&gt; struct is_fundamental;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_fundamental;</Data></Cell>
    <Cell><Data ss:Type="String">is_fundamental</Data></Cell>
    <Cell><Data ss:Type="String">Is fundamental type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_integral(T)Param: (A type.)\t\nDesc: Is integral (class template)\t\nProto: template &lt;class T&gt; struct is_integral;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_integral;</Data></Cell>
    <Cell><Data ss:Type="String">is_integral</Data></Cell>
    <Cell><Data ss:Type="String">Is integral (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_literal_type(T)Param: (A complete type, or )\t\nDesc: Is literal type (class template)\t\nProto: template &lt;class T&gt; struct is_literal_type;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_literal_type;</Data></Cell>
    <Cell><Data ss:Type="String">is_literal_type</Data></Cell>
    <Cell><Data ss:Type="String">Is literal type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_lvalue_reference(T)Param: (A type.)\t\nDesc: Is lvalue reference (class template)\t\nProto: template &lt;class T&gt; struct is_lvalue_reference;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_lvalue_reference;</Data></Cell>
    <Cell><Data ss:Type="String">is_lvalue_reference</Data></Cell>
    <Cell><Data ss:Type="String">Is lvalue reference (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_member_function_pointer(T)Param: (A type.)\t\nDesc: Is member function pointer (class template)\t\nProto: template &lt;class T&gt; struct is_member_function_pointer;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_member_function_pointer;</Data></Cell>
    <Cell><Data ss:Type="String">is_member_function_pointer</Data></Cell>
    <Cell><Data ss:Type="String">Is member function pointer (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_member_object_pointer(T)Param: (A type.)\t\nDesc: Is member object pointer (class template)\t\nProto: template &lt;class T&gt; struct is_member_object_pointer;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_member_object_pointer;</Data></Cell>
    <Cell><Data ss:Type="String">is_member_object_pointer</Data></Cell>
    <Cell><Data ss:Type="String">Is member object pointer (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_member_pointer(T)Param: (A type.)\t\nDesc: Is member pointer type (class template)\t\nProto: template &lt;class T&gt; struct is_member_pointer;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_member_pointer;</Data></Cell>
    <Cell><Data ss:Type="String">is_member_pointer</Data></Cell>
    <Cell><Data ss:Type="String">Is member pointer type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_move_assignable(T)Param: (A complete type, or )\t\nDesc: Is move assignable (class template)\t\nProto: template &lt;class T&gt; struct is_move_assignable;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_move_assignable;</Data></Cell>
    <Cell><Data ss:Type="String">is_move_assignable</Data></Cell>
    <Cell><Data ss:Type="String">Is move assignable (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_move_constructible(T)Param: (A complete type, or )\t\nDesc: Is move constructible (class template)\t\nProto: template &lt;class T&gt; struct is_move_constructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_move_constructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_move_constructible</Data></Cell>
    <Cell><Data ss:Type="String">Is move constructible (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_nothrow_assignable(T, U)Param: (Complete types, or )\t\nDesc: Is assignable throwing no exceptions (class template)\t\nProto: template &lt;class T, class U&gt; struct is_nothrow_assignable;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class U&gt; struct is_nothrow_assignable;</Data></Cell>
    <Cell><Data ss:Type="String">is_nothrow_assignable</Data></Cell>
    <Cell><Data ss:Type="String">Is assignable throwing no exceptions (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T, U)</Data></Cell>
    <Cell><Data ss:Type="String">Complete types, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_nothrow_constructible(T)Param: (A complete type, or )\t\nDesc: Is constructible throwing no exceptions (class template)\t\nProto: template &lt;class T, class... Args&gt; struct is_nothrow_constructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class... Args&gt; struct is_nothrow_constructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_nothrow_constructible</Data></Cell>
    <Cell><Data ss:Type="String">Is constructible throwing no exceptions (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_nothrow_copy_assignable(T)Param: (A complete type, or )\t\nDesc: Is copy assignable throwing no exceptions (class template)\t\nProto: template &lt;class T&gt; struct is_nothrow_copy_assignable;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_nothrow_copy_assignable;</Data></Cell>
    <Cell><Data ss:Type="String">is_nothrow_copy_assignable</Data></Cell>
    <Cell><Data ss:Type="String">Is copy assignable throwing no exceptions (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_nothrow_copy_constructible(T)Param: (A complete type, or )\t\nDesc: Is copy constructible throwing no exceptions (class template)\t\nProto: template &lt;class T&gt; struct is_nothrow_copy_constructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_nothrow_copy_constructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_nothrow_copy_constructible</Data></Cell>
    <Cell><Data ss:Type="String">Is copy constructible throwing no exceptions (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_nothrow_default_constructible(T)Param: (A complete type, or )\t\nDesc: Is default constructible throwing no exceptions (class template)\t\nProto: template &lt;class T&gt; struct is_nothrow_default_constructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_nothrow_default_constructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_nothrow_default_constructible</Data></Cell>
    <Cell><Data ss:Type="String">Is default constructible throwing no exceptions (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_nothrow_destructible(T)Param: (A complete type, or )\t\nDesc: Is nothrow destructible (class template)\t\nProto: template &lt;class T&gt; struct is_nothrow_destructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_nothrow_destructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_nothrow_destructible</Data></Cell>
    <Cell><Data ss:Type="String">Is nothrow destructible (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_nothrow_move_assignable(T)Param: (A complete type, or )\t\nDesc: Is move assignable throwing no exception (class template)\t\nProto: template &lt;class T&gt; struct is_nothrow_move_assignable;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_nothrow_move_assignable;</Data></Cell>
    <Cell><Data ss:Type="String">is_nothrow_move_assignable</Data></Cell>
    <Cell><Data ss:Type="String">Is move assignable throwing no exception (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_nothrow_move_constructible(T)Param: (A complete type, or )\t\nDesc: Is move constructible throwing no exceptions (class template)\t\nProto: template &lt;class T&gt; struct is_nothrow_move_constructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_nothrow_move_constructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_nothrow_move_constructible</Data></Cell>
    <Cell><Data ss:Type="String">Is move constructible throwing no exceptions (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_null_pointer(T)Param: (A type.)\t\nDesc: no-Description (other)\t\nProto: template &lt;class T&gt; struct is_null_pointer;\t\n[cpp14] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_null_pointer;</Data></Cell>
    <Cell><Data ss:Type="String">is_null_pointer</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">cpp14</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_object(T)Param: (A type.)\t\nDesc: Is object type (class template)\t\nProto: template &lt;class T&gt; struct is_object;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_object;</Data></Cell>
    <Cell><Data ss:Type="String">is_object</Data></Cell>
    <Cell><Data ss:Type="String">Is object type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_pod(T)Param: (A complete type, or )\t\nDesc: Is POD type (class template)\t\nProto: template &lt;class T&gt; struct is_pod;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_pod;</Data></Cell>
    <Cell><Data ss:Type="String">is_pod</Data></Cell>
    <Cell><Data ss:Type="String">Is POD type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_pointer(T)Param: (A type.)\t\nDesc: Is pointer (class template)\t\nProto: template &lt;class T&gt; struct is_pointer;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_pointer;</Data></Cell>
    <Cell><Data ss:Type="String">is_pointer</Data></Cell>
    <Cell><Data ss:Type="String">Is pointer (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_polymorphic(T)Param: (\t\nC++11\t\n\t\nC++14\t\n\t\n\t\n\t\nA complete type, or )\t\nDesc: Is polymorphic (class template)\t\nProto: template &lt;class T&gt; struct is_polymorphic;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_polymorphic;</Data></Cell>
    <Cell><Data ss:Type="String">is_polymorphic</Data></Cell>
    <Cell><Data ss:Type="String">Is polymorphic (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">\t\nC++11\t\n\t\nC++14\t\n\t\n\t\n\t\nA complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_reference(T)Param: (A type.)\t\nDesc: Is reference type (class template)\t\nProto: template &lt;class T&gt; struct is_reference;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_reference;</Data></Cell>
    <Cell><Data ss:Type="String">is_reference</Data></Cell>
    <Cell><Data ss:Type="String">Is reference type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_rvalue_reference(T)Param: (A type.)\t\nDesc: Is rvalue reference (class template)\t\nProto: template &lt;class T&gt; struct is_rvalue_reference;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_rvalue_reference;</Data></Cell>
    <Cell><Data ss:Type="String">is_rvalue_reference</Data></Cell>
    <Cell><Data ss:Type="String">Is rvalue reference (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_same(T, U)Param: (Types.)\t\nDesc: Is same type (class template)\t\nProto: template &lt;class T, class U&gt; struct is_same;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class U&gt; struct is_same;</Data></Cell>
    <Cell><Data ss:Type="String">is_same</Data></Cell>
    <Cell><Data ss:Type="String">Is same type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T, U)</Data></Cell>
    <Cell><Data ss:Type="String">Types.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_scalar(T)Param: (A type.)\t\nDesc: Is scalar type (class template)\t\nProto: template &lt;class T&gt; struct is_scalar;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_scalar;</Data></Cell>
    <Cell><Data ss:Type="String">is_scalar</Data></Cell>
    <Cell><Data ss:Type="String">Is scalar type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_signed(T)Param: (A type.)\t\nDesc: Is signed type (class template)\t\nProto: template &lt;class T&gt; struct is_signed;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_signed;</Data></Cell>
    <Cell><Data ss:Type="String">is_signed</Data></Cell>
    <Cell><Data ss:Type="String">Is signed type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_standard_layout(T)Param: (A complete type, or )\t\nDesc: Is standard-layout type (class template)\t\nProto: template &lt;class T&gt; struct is_standard_layout;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_standard_layout;</Data></Cell>
    <Cell><Data ss:Type="String">is_standard_layout</Data></Cell>
    <Cell><Data ss:Type="String">Is standard-layout type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_trivial(T)Param: (A complete type, or )\t\nDesc: Is trivial type (class template)\t\nProto: template &lt;class T&gt; struct is_trivial;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_trivial;</Data></Cell>
    <Cell><Data ss:Type="String">is_trivial</Data></Cell>
    <Cell><Data ss:Type="String">Is trivial type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_trivially_assignable(T, U)Param: (Complete types, or )\t\nDesc: Is trivially assignable (class template)\t\nProto: template &lt;class T, class U&gt; struct is_trivially_assignable;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class U&gt; struct is_trivially_assignable;</Data></Cell>
    <Cell><Data ss:Type="String">is_trivially_assignable</Data></Cell>
    <Cell><Data ss:Type="String">Is trivially assignable (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T, U)</Data></Cell>
    <Cell><Data ss:Type="String">Complete types, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_trivially_constructible(T)Param: (A complete type, or )\t\nDesc: Is trivially constructible (class template)\t\nProto: template &lt;class T, class... Args&gt; struct is_trivially_constructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class... Args&gt; struct is_trivially_constructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_trivially_constructible</Data></Cell>
    <Cell><Data ss:Type="String">Is trivially constructible (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_trivially_copyable(T)Param: (A complete type, or )\t\nDesc: Is trivially copyable (class template)\t\nProto: template &lt;class T&gt; struct is_trivially_copyable;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_trivially_copyable;</Data></Cell>
    <Cell><Data ss:Type="String">is_trivially_copyable</Data></Cell>
    <Cell><Data ss:Type="String">Is trivially copyable (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_trivially_copy_assignable(T)Param: (A complete type, or )\t\nDesc: Is trivially copy assignable (class template)\t\nProto: template &lt;class T&gt; struct is_trivially_copy_assignable;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_trivially_copy_assignable;</Data></Cell>
    <Cell><Data ss:Type="String">is_trivially_copy_assignable</Data></Cell>
    <Cell><Data ss:Type="String">Is trivially copy assignable (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_trivially_copy_constructible(T)Param: (A complete type, or )\t\nDesc: Is trivially copy constructible (class template)\t\nProto: template &lt;class T&gt; struct is_trivially_copy_constructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_trivially_copy_constructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_trivially_copy_constructible</Data></Cell>
    <Cell><Data ss:Type="String">Is trivially copy constructible (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_trivially_default_constructible(T)Param: (A complete type, or )\t\nDesc: Is trivially default constructible (class template)\t\nProto: template &lt;class T&gt; struct is_trivially_default_constructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_trivially_default_constructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_trivially_default_constructible</Data></Cell>
    <Cell><Data ss:Type="String">Is trivially default constructible (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_trivially_destructible(T)Param: (A complete type, or )\t\nDesc: Is trivially destructible (class template)\t\nProto: template &lt;class T&gt; struct is_trivially_destructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_trivially_destructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_trivially_destructible</Data></Cell>
    <Cell><Data ss:Type="String">Is trivially destructible (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_trivially_move_assignable(T)Param: (A complete type, or )\t\nDesc: Is trivially move assignable (class template)\t\nProto: template &lt;class T&gt; struct is_trivially_move_assignable;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_trivially_move_assignable;</Data></Cell>
    <Cell><Data ss:Type="String">is_trivially_move_assignable</Data></Cell>
    <Cell><Data ss:Type="String">Is trivially move assignable (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_trivially_move_constructible(T)Param: (A complete type, or )\t\nDesc: Is trivially move constructible (class template)\t\nProto: template &lt;class T&gt; struct is_trivially_move_constructible;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_trivially_move_constructible;</Data></Cell>
    <Cell><Data ss:Type="String">is_trivially_move_constructible</Data></Cell>
    <Cell><Data ss:Type="String">Is trivially move constructible (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A complete type, or </Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_union(T)Param: (A type.)\t\nDesc: Is union (class template)\t\nProto: template &lt;class T&gt; struct is_union;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_union;</Data></Cell>
    <Cell><Data ss:Type="String">is_union</Data></Cell>
    <Cell><Data ss:Type="String">Is union (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_unsigned(T)Param: (A type.)\t\nDesc: Is unsigned type (class template)\t\nProto: template &lt;class T&gt; struct is_unsigned;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_unsigned;</Data></Cell>
    <Cell><Data ss:Type="String">is_unsigned</Data></Cell>
    <Cell><Data ss:Type="String">Is unsigned type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_void(T)Param: (A type.)\t\nDesc: Is void (class template)\t\nProto: template &lt;class T&gt; struct is_void;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_void;</Data></Cell>
    <Cell><Data ss:Type="String">is_void</Data></Cell>
    <Cell><Data ss:Type="String">Is void (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_volatile(T)Param: (A type.)\t\nDesc: Is volatile-qualified (class template)\t\nProto: template &lt;class T&gt; struct is_volatile;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct is_volatile;</Data></Cell>
    <Cell><Data ss:Type="String">is_volatile</Data></Cell>
    <Cell><Data ss:Type="String">Is volatile-qualified (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">rank(T)Param: (A type.)\t\nDesc: Array rank (class template)\t\nProto: template &lt;class T&gt; struct rank;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct rank;</Data></Cell>
    <Cell><Data ss:Type="String">rank</Data></Cell>
    <Cell><Data ss:Type="String">Array rank (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">add_const(T)Param: (A type.)\t\nDesc: Add const qualification (class template)\t\nProto: template &lt;class T&gt; struct add_const;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct add_const;</Data></Cell>
    <Cell><Data ss:Type="String">add_const</Data></Cell>
    <Cell><Data ss:Type="String">Add const qualification (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">add_cv(T)Param: (A type.)\t\nDesc: Add const volatile qualification (class template)\t\nProto: template &lt;class T&gt; struct add_cv;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct add_cv;</Data></Cell>
    <Cell><Data ss:Type="String">add_cv</Data></Cell>
    <Cell><Data ss:Type="String">Add const volatile qualification (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">add_lvalue_reference(T)Param: (A type.)\t\nDesc: Add lvalue reference (class template)\t\nProto: template &lt;class T&gt; struct add_lvalue_reference;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct add_lvalue_reference;</Data></Cell>
    <Cell><Data ss:Type="String">add_lvalue_reference</Data></Cell>
    <Cell><Data ss:Type="String">Add lvalue reference (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">add_pointer(T)Param: (A type.)\t\nDesc: Add pointer (class template)\t\nProto: template &lt;class T&gt; struct add_pointer;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct add_pointer;</Data></Cell>
    <Cell><Data ss:Type="String">add_pointer</Data></Cell>
    <Cell><Data ss:Type="String">Add pointer (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">add_rvalue_reference(T)Param: (A type.)\t\nDesc: Add rvalue reference (class template)\t\nProto: template &lt;class T&gt; struct add_rvalue_reference;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct add_rvalue_reference;</Data></Cell>
    <Cell><Data ss:Type="String">add_rvalue_reference</Data></Cell>
    <Cell><Data ss:Type="String">Add rvalue reference (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">add_volatile(T)Param: (A type.)\t\nDesc: Add volatile qualification (class template)\t\nProto: template &lt;class T&gt; struct add_volatile;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct add_volatile;</Data></Cell>
    <Cell><Data ss:Type="String">add_volatile</Data></Cell>
    <Cell><Data ss:Type="String">Add volatile qualification (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">aligned_storage(Len)Param: (The size of the storage object, in bytes.)\t\nDesc: Aligned storage (class template)\t\nProto: template &lt;size_t Len, size_t Align = /* default alignment */&gt;\t\nstruct aligned_storage;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;size_t Len, size_t Align = /* default alignment */&gt;\t\nstruct aligned_storage;</Data></Cell>
    <Cell><Data ss:Type="String">aligned_storage</Data></Cell>
    <Cell><Data ss:Type="String">Aligned storage (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Len)</Data></Cell>
    <Cell><Data ss:Type="String">The size of the storage object, in bytes.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">aligned_union(Len)Param: (The minimum size of the storage object, in bytes.)\t\nDesc: Aligned union (class template)\t\nProto: template &lt;size_t Len, class... Types&gt; struct aligned_union;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;size_t Len, class... Types&gt; struct aligned_union;</Data></Cell>
    <Cell><Data ss:Type="String">aligned_union</Data></Cell>
    <Cell><Data ss:Type="String">Aligned union (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Len)</Data></Cell>
    <Cell><Data ss:Type="String">The minimum size of the storage object, in bytes.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">conditional(Cond)Param: (A compile-time constant of type bool.)\t\nDesc: Conditional type (class template)\t\nProto: template &lt;bool Cond, class T, class F&gt; struct conditional;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;bool Cond, class T, class F&gt; struct conditional;</Data></Cell>
    <Cell><Data ss:Type="String">conditional</Data></Cell>
    <Cell><Data ss:Type="String">Conditional type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Cond)</Data></Cell>
    <Cell><Data ss:Type="String">A compile-time constant of type bool.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">decay(T)Param: (A type.)\t\nDesc: Decay type (class template)\t\nProto: template &lt;class T&gt; struct decay;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct decay;</Data></Cell>
    <Cell><Data ss:Type="String">decay</Data></Cell>
    <Cell><Data ss:Type="String">Decay type (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">enable_if(Cond)Param: (A compile-time constant of type bool.)\t\nDesc: Enable type if condition is met (class template)\t\nProto: template &lt;bool Cond, class T = void&gt; struct enable_if;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;bool Cond, class T = void&gt; struct enable_if;</Data></Cell>
    <Cell><Data ss:Type="String">enable_if</Data></Cell>
    <Cell><Data ss:Type="String">Enable type if condition is met (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Cond)</Data></Cell>
    <Cell><Data ss:Type="String">A compile-time constant of type bool.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">make_signed(T)Param: (An integer type (except bool), or an enumeration type.)\t\nDesc: Make signed (class template)\t\nProto: template &lt;class T&gt; struct make_signed;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct make_signed;</Data></Cell>
    <Cell><Data ss:Type="String">make_signed</Data></Cell>
    <Cell><Data ss:Type="String">Make signed (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">An integer type (except bool), or an enumeration type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">make_unsigned(T)Param: (An integer type (except bool), or an enumeration type.)\t\nDesc: Make unsigned (class template)\t\nProto: template &lt;class T&gt; struct make_unsigned;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct make_unsigned;</Data></Cell>
    <Cell><Data ss:Type="String">make_unsigned</Data></Cell>
    <Cell><Data ss:Type="String">Make unsigned (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">An integer type (except bool), or an enumeration type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remove_all_extents(T)Param: (A type.)\t\nDesc: Remove all array extents (class template)\t\nProto: template &lt;class T&gt; struct remove_all_extents;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct remove_all_extents;</Data></Cell>
    <Cell><Data ss:Type="String">remove_all_extents</Data></Cell>
    <Cell><Data ss:Type="String">Remove all array extents (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remove_const(T)Param: (A type.)\t\nDesc: Remove const qualification (class template)\t\nProto: template &lt;class T&gt; struct remove_const;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct remove_const;</Data></Cell>
    <Cell><Data ss:Type="String">remove_const</Data></Cell>
    <Cell><Data ss:Type="String">Remove const qualification (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remove_cv(T)Param: (A type.)\t\nDesc: Remove cv qualification (class template)\t\nProto: template &lt;class T&gt; struct remove_cv;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct remove_cv;</Data></Cell>
    <Cell><Data ss:Type="String">remove_cv</Data></Cell>
    <Cell><Data ss:Type="String">Remove cv qualification (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remove_extent(T)Param: (A type.)\t\nDesc: Remove array extent (class template)\t\nProto: template &lt;class T&gt; struct remove_extent;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct remove_extent;</Data></Cell>
    <Cell><Data ss:Type="String">remove_extent</Data></Cell>
    <Cell><Data ss:Type="String">Remove array extent (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remove_pointer(T)Param: (A type.)\t\nDesc: Remove pointer (class template)\t\nProto: template &lt;class T&gt; struct remove_pointer;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct remove_pointer;</Data></Cell>
    <Cell><Data ss:Type="String">remove_pointer</Data></Cell>
    <Cell><Data ss:Type="String">Remove pointer (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remove_reference(T)Param: (A type.)\t\nDesc: Remove reference (class template)\t\nProto: template &lt;class T&gt; struct remove_reference;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct remove_reference;</Data></Cell>
    <Cell><Data ss:Type="String">remove_reference</Data></Cell>
    <Cell><Data ss:Type="String">Remove reference (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remove_volatile(T)Param: (A type.)\t\nDesc: Remove volatile qualification (class template)\t\nProto: template &lt;class T&gt; struct remove_volatile;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct remove_volatile;</Data></Cell>
    <Cell><Data ss:Type="String">remove_volatile</Data></Cell>
    <Cell><Data ss:Type="String">Remove volatile qualification (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">A type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">underlying_type(T)Param: (An enumeration type (enum).)\t\nDesc: Underlying type of enum (class template)\t\nProto: template &lt;class T&gt; struct underlying_type;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; struct underlying_type;</Data></Cell>
    <Cell><Data ss:Type="String">underlying_type</Data></Cell>
    <Cell><Data ss:Type="String">Underlying type of enum (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">An enumeration type (enum).</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">pair(T1)Param: (Type of member first, aliased as first_type.)\t\nDesc: Pair of values (class template)\t\nProto: template &lt;class T1, class T2&gt; struct pair;\t\n[cpp98 cpp11 ] [&lt;utility&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T1, class T2&gt; struct pair;</Data></Cell>
    <Cell><Data ss:Type="String">pair</Data></Cell>
    <Cell><Data ss:Type="String">Pair of values (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T1)</Data></Cell>
    <Cell><Data ss:Type="String">Type of member first, aliased as first_type.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;utility&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Utility components</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">piecewise_construct_t()Param: ()\t\nDesc: Piecewise construct type (type)\t\nProto: struct piecewise_construct_t {};\t\n[cpp11] [&lt;utility&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">struct piecewise_construct_t {};</Data></Cell>
    <Cell><Data ss:Type="String">piecewise_construct_t</Data></Cell>
    <Cell><Data ss:Type="String">Piecewise construct type (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;utility&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Utility components</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">rel_ops(T)Param: (For operator!=, the type shall be EqualityComparable.)\t\nDesc: Relational Operators (namespace)\t\nProto: long-proto\t\n[cpp98 cpp11] [&lt;utility&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">long-proto</Data></Cell>
    <Cell><Data ss:Type="String">rel_ops</Data></Cell>
    <Cell><Data ss:Type="String">Relational Operators (namespace)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">For operator!=, the type shall be EqualityComparable.</Data></Cell>
    <Cell><Data ss:Type="String">namespace</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;utility&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Utility components</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">gslice()Param: ()\t\nDesc: Valarray generalized slice selector (class)\t\nProto: class gslice;\t\n[cpp98 cpp11 ] [&lt;valarray&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">class gslice;</Data></Cell>
    <Cell><Data ss:Type="String">gslice</Data></Cell>
    <Cell><Data ss:Type="String">Valarray generalized slice selector (class)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;valarray&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Library for arrays of numeric values</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">gslice_array()Param: ()\t\nDesc: Valarray gslice selection (class template)\t\nProto: template &lt;class T&gt; gslice_array;\t\n[cpp98 cpp11] [&lt;valarray&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; gslice_array;</Data></Cell>
    <Cell><Data ss:Type="String">gslice_array</Data></Cell>
    <Cell><Data ss:Type="String">Valarray gslice selection (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;valarray&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Library for arrays of numeric values</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">indirect_array()Param: ()\t\nDesc: Valarray indirect selection (class template)\t\nProto: template &lt;class T&gt; indirect_array;\t\n[cpp98 cpp11] [&lt;valarray&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; indirect_array;</Data></Cell>
    <Cell><Data ss:Type="String">indirect_array</Data></Cell>
    <Cell><Data ss:Type="String">Valarray indirect selection (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;valarray&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Library for arrays of numeric values</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mask_array()Param: ()\t\nDesc: Valarray mask selection (class template)\t\nProto: template &lt;class T&gt; mask_array;\t\n[cpp98 cpp11] [&lt;valarray&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; mask_array;</Data></Cell>
    <Cell><Data ss:Type="String">mask_array</Data></Cell>
    <Cell><Data ss:Type="String">Valarray mask selection (class template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;valarray&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Library for arrays of numeric values</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">valarray(T)Param: (Type of the elements contained in the valarray.)\t\nDesc: Valarray class (class template)\t\nProto: template &lt;class T&gt; class valarray;\t\n[cpp98 cpp11 ] [&lt;valarray&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">!</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; class valarray;</Data></Cell>
    <Cell><Data ss:Type="String">valarray</Data></Cell>
    <Cell><Data ss:Type="String">Valarray class (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(T)</Data></Cell>
    <Cell><Data ss:Type="String">Type of the elements contained in the valarray.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11 </Data></Cell>
    <Cell><Data ss:Type="String">&lt;valarray&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Library for arrays of numeric values</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strcat( char * destination, const char * source )Param: (Pointer to the destination array, which should contain a C string, and be large enough to contain the concatenated resulting string.)\t\nDesc: Concatenate strings (function)\t\nProto: char * strcat ( char * destination, const char * source );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char * destination, const char * source )</Data></Cell>
    <Cell><Data ss:Type="String">char * strcat ( char * destination, const char * source );</Data></Cell>
    <Cell><Data ss:Type="String">strcat</Data></Cell>
    <Cell><Data ss:Type="String">Concatenate strings (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array, which should contain a C string, and be large enough to contain the concatenated resulting string.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strcpy( char * destination, const char * source )Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Copy string (function)\t\nProto: char * strcpy ( char * destination, const char * source );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char * destination, const char * source )</Data></Cell>
    <Cell><Data ss:Type="String">char * strcpy ( char * destination, const char * source );</Data></Cell>
    <Cell><Data ss:Type="String">strcpy</Data></Cell>
    <Cell><Data ss:Type="String">Copy string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array where the content is to be copied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strncat( char * destination, const char * source, size_t num )Param: (Pointer to the destination array, which should contain a C string, and be large enough to contain the concatenated resulting string, including the additional null-character.)\t\nDesc: Append characters from string (function)\t\nProto: char * strncat ( char * destination, const char * source, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char * destination, const char * source, size_t num )</Data></Cell>
    <Cell><Data ss:Type="String">char * strncat ( char * destination, const char * source, size_t num );</Data></Cell>
    <Cell><Data ss:Type="String">strncat</Data></Cell>
    <Cell><Data ss:Type="String">Append characters from string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array, which should contain a C string, and be large enough to contain the concatenated resulting string, including the additional null-character.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strncpy( char * destination, const char * source, size_t num )Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Copy characters from string (function)\t\nProto: char * strncpy ( char * destination, const char * source, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char * destination, const char * source, size_t num )</Data></Cell>
    <Cell><Data ss:Type="String">char * strncpy ( char * destination, const char * source, size_t num );</Data></Cell>
    <Cell><Data ss:Type="String">strncpy</Data></Cell>
    <Cell><Data ss:Type="String">Copy characters from string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array where the content is to be copied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strxfrm( char * destination, const char * source, size_t num )Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Transform string using locale (function)\t\nProto: size_t strxfrm ( char * destination, const char * source, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char * destination, const char * source, size_t num )</Data></Cell>
    <Cell><Data ss:Type="String">size_t strxfrm ( char * destination, const char * source, size_t num );</Data></Cell>
    <Cell><Data ss:Type="String">strxfrm</Data></Cell>
    <Cell><Data ss:Type="String">Transform string using locale (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array where the content is to be copied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">c16rtomb( char * pmb, char16_t c16, mbstate_t * ps )Param: (Pointer to an array large enough to hold a multibyte sequence.)\t\nDesc: Convert 16-bit character to multibyte sequence (function)\t\nProto: size_t c16rtomb ( char * pmb, char16_t c16, mbstate_t * ps );\t\n[c11 cpp11] [&lt;cuchar&gt; (uchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char * pmb, char16_t c16, mbstate_t * ps )</Data></Cell>
    <Cell><Data ss:Type="String">size_t c16rtomb ( char * pmb, char16_t c16, mbstate_t * ps );</Data></Cell>
    <Cell><Data ss:Type="String">c16rtomb</Data></Cell>
    <Cell><Data ss:Type="String">Convert 16-bit character to multibyte sequence (function)</Data></Cell>
    <Cell><Data ss:Type="String">(pmb)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an array large enough to hold a multibyte sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c11 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cuchar&gt; (uchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Unicode characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">c32rtomb( char * pmb, char32_t c32, mbstate_t * ps )Param: (Pointer to an array large enough to hold a multibyte sequence.)\t\nDesc: Convert 32-bit character to multibyte sequence (function)\t\nProto: size_t c32rtomb ( char * pmb, char32_t c32, mbstate_t * ps );\t\n[c11 cpp11] [&lt;cuchar&gt; (uchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char * pmb, char32_t c32, mbstate_t * ps )</Data></Cell>
    <Cell><Data ss:Type="String">size_t c32rtomb ( char * pmb, char32_t c32, mbstate_t * ps );</Data></Cell>
    <Cell><Data ss:Type="String">c32rtomb</Data></Cell>
    <Cell><Data ss:Type="String">Convert 32-bit character to multibyte sequence (function)</Data></Cell>
    <Cell><Data ss:Type="String">(pmb)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an array large enough to hold a multibyte sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c11 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cuchar&gt; (uchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Unicode characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">snprintf( char * s, size_t n, const char * format, ... )Param: (Pointer to a buffer where the resulting C-string is stored.)\t\nDesc: Write formatted output to sized buffer (function)\t\nProto: int snprintf ( char * s, size_t n, const char * format, ... );\t\n[c99 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char * s, size_t n, const char * format, ... )</Data></Cell>
    <Cell><Data ss:Type="String">int snprintf ( char * s, size_t n, const char * format, ... );</Data></Cell>
    <Cell><Data ss:Type="String">snprintf</Data></Cell>
    <Cell><Data ss:Type="String">Write formatted output to sized buffer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(s)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a buffer where the resulting C-string is stored.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">tmpnam( char * str )Param: (Pointer to an array of characters where the proposed temporary name will be stored as a C string.)\t\nDesc: Generate temporary filename (function)\t\nProto: char * tmpnam ( char * str );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char * str )</Data></Cell>
    <Cell><Data ss:Type="String">char * tmpnam ( char * str );</Data></Cell>
    <Cell><Data ss:Type="String">tmpnam</Data></Cell>
    <Cell><Data ss:Type="String">Generate temporary filename (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an array of characters where the proposed temporary name will be stored as a C string.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strtok( char * str, const char * delimiters )Param: (C string to truncate.)\t\nDesc: Split string into tokens (function)\t\nProto: char * strtok ( char * str, const char * delimiters );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char * str, const char * delimiters )</Data></Cell>
    <Cell><Data ss:Type="String">char * strtok ( char * str, const char * delimiters );</Data></Cell>
    <Cell><Data ss:Type="String">strtok</Data></Cell>
    <Cell><Data ss:Type="String">Split string into tokens (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C string to truncate.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">sprintf( char * str, const char * format, ... )Param: (Pointer to a buffer where the resulting C-string is stored.)\t\nDesc: Write formatted data to string (function)\t\nProto: int sprintf ( char * str, const char * format, ... );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char * str, const char * format, ... )</Data></Cell>
    <Cell><Data ss:Type="String">int sprintf ( char * str, const char * format, ... );</Data></Cell>
    <Cell><Data ss:Type="String">sprintf</Data></Cell>
    <Cell><Data ss:Type="String">Write formatted data to string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a buffer where the resulting C-string is stored.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fgets( char * str, int num, FILE * stream )Param: (Pointer to an array of chars where the string read is copied.)\t\nDesc: Get string from stream (function)\t\nProto: char * fgets ( char * str, int num, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char * str, int num, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">char * fgets ( char * str, int num, FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">fgets</Data></Cell>
    <Cell><Data ss:Type="String">Get string from stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an array of chars where the string read is copied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mbrtoc16( char16_t * pc16, const char * pmb, size_t max, mbstate_t * ps)Param: (Pointer to an object of type char16_t.)\t\nDesc: Convert multibyte sequence to 16-bit character (function)\t\nProto: size_t mbrtoc16 ( char16_t * pc16, const char * pmb, size_t max, mbstate_t * ps);\t\n[c11 cpp11] [&lt;cuchar&gt; (uchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char16_t * pc16, const char * pmb, size_t max, mbstate_t * ps)</Data></Cell>
    <Cell><Data ss:Type="String">size_t mbrtoc16 ( char16_t * pc16, const char * pmb, size_t max, mbstate_t * ps);</Data></Cell>
    <Cell><Data ss:Type="String">mbrtoc16</Data></Cell>
    <Cell><Data ss:Type="String">Convert multibyte sequence to 16-bit character (function)</Data></Cell>
    <Cell><Data ss:Type="String">(pc16)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an object of type char16_t.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c11 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cuchar&gt; (uchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Unicode characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mbrtoc32( char32_t * pc32, const char * pmb, size_t max, mbstate_t * ps)Param: (Pointer to an object of type char32_t.)\t\nDesc: Convert multibyte sequence to 32-bit character (function)\t\nProto: size_t mbrtoc32 ( char32_t * pc32, const char * pmb, size_t max, mbstate_t * ps);\t\n[c11 cpp11] [&lt;cuchar&gt; (uchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( char32_t * pc32, const char * pmb, size_t max, mbstate_t * ps)</Data></Cell>
    <Cell><Data ss:Type="String">size_t mbrtoc32 ( char32_t * pc32, const char * pmb, size_t max, mbstate_t * ps);</Data></Cell>
    <Cell><Data ss:Type="String">mbrtoc32</Data></Cell>
    <Cell><Data ss:Type="String">Convert multibyte sequence to 32-bit character (function)</Data></Cell>
    <Cell><Data ss:Type="String">(pc32)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an object of type char32_t.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c11 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cuchar&gt; (uchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Unicode characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remove( const char * filename )Param: (C string containing the name of the file to be deleted.)\t\nDesc: Remove file (function)\t\nProto: int remove ( const char * filename );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * filename )</Data></Cell>
    <Cell><Data ss:Type="String">int remove ( const char * filename );</Data></Cell>
    <Cell><Data ss:Type="String">remove</Data></Cell>
    <Cell><Data ss:Type="String">Remove file (function)</Data></Cell>
    <Cell><Data ss:Type="String">(filename)</Data></Cell>
    <Cell><Data ss:Type="String">C string containing the name of the file to be deleted.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fopen( const char * filename, const char * mode )Param: (C string containing the name of the file to be opened.)\t\nDesc: Open file (function)\t\nProto: FILE * fopen ( const char * filename, const char * mode );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * filename, const char * mode )</Data></Cell>
    <Cell><Data ss:Type="String">FILE * fopen ( const char * filename, const char * mode );</Data></Cell>
    <Cell><Data ss:Type="String">fopen</Data></Cell>
    <Cell><Data ss:Type="String">Open file (function)</Data></Cell>
    <Cell><Data ss:Type="String">(filename)</Data></Cell>
    <Cell><Data ss:Type="String">C string containing the name of the file to be opened.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">freopen( const char * filename, const char * mode, FILE * stream )Param: (C string containing the name of the file to be opened.)\t\nDesc: Reopen stream with different file or mode (function)\t\nProto: FILE * freopen ( const char * filename, const char * mode, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * filename, const char * mode, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">FILE * freopen ( const char * filename, const char * mode, FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">freopen</Data></Cell>
    <Cell><Data ss:Type="String">Reopen stream with different file or mode (function)</Data></Cell>
    <Cell><Data ss:Type="String">(filename)</Data></Cell>
    <Cell><Data ss:Type="String">C string containing the name of the file to be opened.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vprintf( const char * format, va_list arg )Param: (C string that contains a format string that follows the same specifications as format in printf (see printf for details).)\t\nDesc: Print formatted data from variable argument list to stdout (function)\t\nProto: int vprintf ( const char * format, va_list arg );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * format, va_list arg )</Data></Cell>
    <Cell><Data ss:Type="String">int vprintf ( const char * format, va_list arg );</Data></Cell>
    <Cell><Data ss:Type="String">vprintf</Data></Cell>
    <Cell><Data ss:Type="String">Print formatted data from variable argument list to stdout (function)</Data></Cell>
    <Cell><Data ss:Type="String">(format)</Data></Cell>
    <Cell><Data ss:Type="String">C string that contains a format string that follows the same specifications as format in printf (see printf for details).</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vscanf( const char * format, va_list arg )Param: (C string that contains a format string that follows the same specifications as format in scanf (see scanf for details).)\t\nDesc: Read formatted data into variable argument list (function)\t\nProto: int vscanf ( const char * format, va_list arg );\t\n[c99 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * format, va_list arg )</Data></Cell>
    <Cell><Data ss:Type="String">int vscanf ( const char * format, va_list arg );</Data></Cell>
    <Cell><Data ss:Type="String">vscanf</Data></Cell>
    <Cell><Data ss:Type="String">Read formatted data into variable argument list (function)</Data></Cell>
    <Cell><Data ss:Type="String">(format)</Data></Cell>
    <Cell><Data ss:Type="String">C string that contains a format string that follows the same specifications as format in scanf (see scanf for details).</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">rename( const char * oldname, const char * newname )Param: (C string containing the name of an existing file to be renamed and/or moved.)\t\nDesc: Rename file (function)\t\nProto: int rename ( const char * oldname, const char * newname );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * oldname, const char * newname )</Data></Cell>
    <Cell><Data ss:Type="String">int rename ( const char * oldname, const char * newname );</Data></Cell>
    <Cell><Data ss:Type="String">rename</Data></Cell>
    <Cell><Data ss:Type="String">Rename file (function)</Data></Cell>
    <Cell><Data ss:Type="String">(oldname)</Data></Cell>
    <Cell><Data ss:Type="String">C string containing the name of an existing file to be renamed and/or moved.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">sscanf( const char * s, const char * format, ...)Param: (C string that the function processes as its source to retrieve the data.)\t\nDesc: Read formatted data from string (function)\t\nProto: int sscanf ( const char * s, const char * format, ...);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * s, const char * format, ...)</Data></Cell>
    <Cell><Data ss:Type="String">int sscanf ( const char * s, const char * format, ...);</Data></Cell>
    <Cell><Data ss:Type="String">sscanf</Data></Cell>
    <Cell><Data ss:Type="String">Read formatted data from string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(s)</Data></Cell>
    <Cell><Data ss:Type="String">C string that the function processes as its source to retrieve the data.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vsscanf( const char * s, const char * format, va_list arg )Param: (C string that the function processes as its source to retrieve the data.)\t\nDesc: Read formatted data from string into variable argument list (function)\t\nProto: int vsscanf ( const char * s, const char * format, va_list arg );\t\n[c99 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * s, const char * format, va_list arg )</Data></Cell>
    <Cell><Data ss:Type="String">int vsscanf ( const char * s, const char * format, va_list arg );</Data></Cell>
    <Cell><Data ss:Type="String">vsscanf</Data></Cell>
    <Cell><Data ss:Type="String">Read formatted data from string into variable argument list (function)</Data></Cell>
    <Cell><Data ss:Type="String">(s)</Data></Cell>
    <Cell><Data ss:Type="String">C string that the function processes as its source to retrieve the data.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">perror( const char * str )Param: (C string containing a custom message to be printed before the error message itself.)\t\nDesc: Print error message (function)\t\nProto: void perror ( const char * str );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str )</Data></Cell>
    <Cell><Data ss:Type="String">void perror ( const char * str );</Data></Cell>
    <Cell><Data ss:Type="String">perror</Data></Cell>
    <Cell><Data ss:Type="String">Print error message (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C string containing a custom message to be printed before the error message itself.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atol( const char * str )Param: (C-string containing the representation of an integral number.)\t\nDesc: Convert string to long integer (function)\t\nProto: long int atol ( const char * str );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str )</Data></Cell>
    <Cell><Data ss:Type="String">long int atol ( const char * str );</Data></Cell>
    <Cell><Data ss:Type="String">atol</Data></Cell>
    <Cell><Data ss:Type="String">Convert string to long integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C-string containing the representation of an integral number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atoll( const char * str )Param: (C-string containing the representation of an integral number.)\t\nDesc: Convert string to long long integer (function)\t\nProto: long long int atoll ( const char * str );\t\n[c99 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str )</Data></Cell>
    <Cell><Data ss:Type="String">long long int atoll ( const char * str );</Data></Cell>
    <Cell><Data ss:Type="String">atoll</Data></Cell>
    <Cell><Data ss:Type="String">Convert string to long long integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C-string containing the representation of an integral number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strlen( const char * str )Param: (C string.)\t\nDesc: Get string length (function)\t\nProto: size_t strlen ( const char * str );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str )</Data></Cell>
    <Cell><Data ss:Type="String">size_t strlen ( const char * str );</Data></Cell>
    <Cell><Data ss:Type="String">strlen</Data></Cell>
    <Cell><Data ss:Type="String">Get string length (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C string.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fputs( const char * str, FILE * stream )Param: (C string with the content to be written to stream.)\t\nDesc: Write string to stream (function)\t\nProto: int fputs ( const char * str, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">int fputs ( const char * str, FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">fputs</Data></Cell>
    <Cell><Data ss:Type="String">Write string to stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C string with the content to be written to stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strchr( const char * str, int character )Param: (C string.)\t\nDesc: Locate first occurrence of character in string (function)\t\nProto: const char * strchr ( const char * str, int character );char * strchr ( char * str, int character );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str, int character )</Data></Cell>
    <Cell><Data ss:Type="String">const char * strchr ( const char * str, int character );char * strchr ( char * str, int character );</Data></Cell>
    <Cell><Data ss:Type="String">strchr</Data></Cell>
    <Cell><Data ss:Type="String">Locate first occurrence of character in string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C string.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strrchr( const char * str, int character )Param: (C string.)\t\nDesc: Locate last occurrence of character in string (function)\t\nProto: const char * strrchr ( const char * str, int character );char * strrchr ( char * str, int character );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str, int character )</Data></Cell>
    <Cell><Data ss:Type="String">const char * strrchr ( const char * str, int character );char * strrchr ( char * str, int character );</Data></Cell>
    <Cell><Data ss:Type="String">strrchr</Data></Cell>
    <Cell><Data ss:Type="String">Locate last occurrence of character in string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C string.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strcmp( const char * str1, const char * str2 )Param: (C string to be compared.)\t\nDesc: Compare two strings (function)\t\nProto: int strcmp ( const char * str1, const char * str2 );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str1, const char * str2 )</Data></Cell>
    <Cell><Data ss:Type="String">int strcmp ( const char * str1, const char * str2 );</Data></Cell>
    <Cell><Data ss:Type="String">strcmp</Data></Cell>
    <Cell><Data ss:Type="String">Compare two strings (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str1)</Data></Cell>
    <Cell><Data ss:Type="String">C string to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strcoll( const char * str1, const char * str2 )Param: (C string to be compared.)\t\nDesc: Compare two strings using locale (function)\t\nProto: int strcoll ( const char * str1, const char * str2 );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str1, const char * str2 )</Data></Cell>
    <Cell><Data ss:Type="String">int strcoll ( const char * str1, const char * str2 );</Data></Cell>
    <Cell><Data ss:Type="String">strcoll</Data></Cell>
    <Cell><Data ss:Type="String">Compare two strings using locale (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str1)</Data></Cell>
    <Cell><Data ss:Type="String">C string to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strcspn( const char * str1, const char * str2 )Param: (C string to be scanned.)\t\nDesc: Get span until character in string (function)\t\nProto: size_t strcspn ( const char * str1, const char * str2 );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str1, const char * str2 )</Data></Cell>
    <Cell><Data ss:Type="String">size_t strcspn ( const char * str1, const char * str2 );</Data></Cell>
    <Cell><Data ss:Type="String">strcspn</Data></Cell>
    <Cell><Data ss:Type="String">Get span until character in string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str1)</Data></Cell>
    <Cell><Data ss:Type="String">C string to be scanned.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strspn( const char * str1, const char * str2 )Param: (C string to be scanned.)\t\nDesc: Get span of character set in string (function)\t\nProto: size_t strspn ( const char * str1, const char * str2 );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str1, const char * str2 )</Data></Cell>
    <Cell><Data ss:Type="String">size_t strspn ( const char * str1, const char * str2 );</Data></Cell>
    <Cell><Data ss:Type="String">strspn</Data></Cell>
    <Cell><Data ss:Type="String">Get span of character set in string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str1)</Data></Cell>
    <Cell><Data ss:Type="String">C string to be scanned.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strpbrk( const char * str1, const char * str2 )Param: (C string to be scanned.)\t\nDesc: Locate characters in string (function)\t\nProto: const char * strpbrk ( const char * str1, const char * str2 );char * strpbrk ( char * str1, const char * str2 );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str1, const char * str2 )</Data></Cell>
    <Cell><Data ss:Type="String">const char * strpbrk ( const char * str1, const char * str2 );char * strpbrk ( char * str1, const char * str2 );</Data></Cell>
    <Cell><Data ss:Type="String">strpbrk</Data></Cell>
    <Cell><Data ss:Type="String">Locate characters in string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str1)</Data></Cell>
    <Cell><Data ss:Type="String">C string to be scanned.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strstr( const char * str1, const char * str2 )Param: (C string to be scanned.)\t\nDesc: Locate substring (function)\t\nProto: const char * strstr ( const char * str1, const char * str2 );char * strstr ( char * str1, const char * str2 );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str1, const char * str2 )</Data></Cell>
    <Cell><Data ss:Type="String">const char * strstr ( const char * str1, const char * str2 );char * strstr ( char * str1, const char * str2 );</Data></Cell>
    <Cell><Data ss:Type="String">strstr</Data></Cell>
    <Cell><Data ss:Type="String">Locate substring (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str1)</Data></Cell>
    <Cell><Data ss:Type="String">C string to be scanned.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strncmp( const char * str1, const char * str2, size_t num )Param: (C string to be compared.)\t\nDesc: Compare characters of two strings (function)\t\nProto: int strncmp ( const char * str1, const char * str2, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const char * str1, const char * str2, size_t num )</Data></Cell>
    <Cell><Data ss:Type="String">int strncmp ( const char * str1, const char * str2, size_t num );</Data></Cell>
    <Cell><Data ss:Type="String">strncmp</Data></Cell>
    <Cell><Data ss:Type="String">Compare characters of two strings (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str1)</Data></Cell>
    <Cell><Data ss:Type="String">C string to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">memchr( const void * ptr, int value, size_t num )Param: (Pointer to the block of memory where the search is performed.)\t\nDesc: Locate character in block of memory (function)\t\nProto: const void * memchr ( const void * ptr, int value, size_t num );void * memchr ( void * ptr, int value, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const void * ptr, int value, size_t num )</Data></Cell>
    <Cell><Data ss:Type="String">const void * memchr ( const void * ptr, int value, size_t num );void * memchr ( void * ptr, int value, size_t num );</Data></Cell>
    <Cell><Data ss:Type="String">memchr</Data></Cell>
    <Cell><Data ss:Type="String">Locate character in block of memory (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the block of memory where the search is performed.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fwrite( const void * ptr, size_t size, size_t count, FILE * stream )Param: (Pointer to the array of elements to be written, converted to a const )\t\nDesc: Write block of data to stream (function)\t\nProto: size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">fwrite</Data></Cell>
    <Cell><Data ss:Type="String">Write block of data to stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the array of elements to be written, converted to a const </Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">memcmp( const void * ptr1, const void * ptr2, size_t num )Param: (Pointer to block of memory.)\t\nDesc: Compare two blocks of memory (function)\t\nProto: int memcmp ( const void * ptr1, const void * ptr2, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const void * ptr1, const void * ptr2, size_t num )</Data></Cell>
    <Cell><Data ss:Type="String">int memcmp ( const void * ptr1, const void * ptr2, size_t num );</Data></Cell>
    <Cell><Data ss:Type="String">memcmp</Data></Cell>
    <Cell><Data ss:Type="String">Compare two blocks of memory (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr1)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to block of memory.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vwscanf( const wchar_t * format, va_list arg )Param: (C wide string that contains a format string that follows the same specifications as format in scanf (see scanf for details).)\t\nDesc: Read formatted data into variable argument list (function)\t\nProto: int vwscanf ( const wchar_t * format, va_list arg );\t\n[c99 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( const wchar_t * format, va_list arg )</Data></Cell>
    <Cell><Data ss:Type="String">int vwscanf ( const wchar_t * format, va_list arg );</Data></Cell>
    <Cell><Data ss:Type="String">vwscanf</Data></Cell>
    <Cell><Data ss:Type="String">Read formatted data into variable argument list (function)</Data></Cell>
    <Cell><Data ss:Type="String">(format)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string that contains a format string that follows the same specifications as format in scanf (see scanf for details).</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">clearerr( FILE * stream )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Clear error indicators (function)\t\nProto: void clearerr ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">void clearerr ( FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">clearerr</Data></Cell>
    <Cell><Data ss:Type="String">Clear error indicators (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies the stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fclose( FILE * stream )Param: (Pointer to a FILE object that specifies the stream to be closed.)\t\nDesc: Close file (function)\t\nProto: int fclose ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">int fclose ( FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">fclose</Data></Cell>
    <Cell><Data ss:Type="String">Close file (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that specifies the stream to be closed.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">feof( FILE * stream )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Check end-of-file indicator (function)\t\nProto: int feof ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">int feof ( FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">feof</Data></Cell>
    <Cell><Data ss:Type="String">Check end-of-file indicator (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies the stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ferror( FILE * stream )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Check error indicator (function)\t\nProto: int ferror ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">int ferror ( FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">ferror</Data></Cell>
    <Cell><Data ss:Type="String">Check error indicator (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies the stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fflush( FILE * stream )Param: (Pointer to a FILE object that specifies a buffered stream.)\t\nDesc: Flush stream (function)\t\nProto: int fflush ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">int fflush ( FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">fflush</Data></Cell>
    <Cell><Data ss:Type="String">Flush stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that specifies a buffered stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fgetc( FILE * stream )Param: (Pointer to a FILE object that identifies an input stream.)\t\nDesc: Get character from stream (function)\t\nProto: int fgetc ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">int fgetc ( FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">fgetc</Data></Cell>
    <Cell><Data ss:Type="String">Get character from stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies an input stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ftell( FILE * stream )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Get current position in stream (function)\t\nProto: long int ftell ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">long int ftell ( FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">ftell</Data></Cell>
    <Cell><Data ss:Type="String">Get current position in stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies the stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">rewind( FILE * stream )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Set position of stream to the beginning (function)\t\nProto: void rewind ( FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">void rewind ( FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">rewind</Data></Cell>
    <Cell><Data ss:Type="String">Set position of stream to the beginning (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies the stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">setbuf( FILE * stream, char * buffer )Param: (Pointer to a FILE object that identifies an open stream.)\t\nDesc: Set stream buffer (function)\t\nProto: void setbuf ( FILE * stream, char * buffer );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream, char * buffer )</Data></Cell>
    <Cell><Data ss:Type="String">void setbuf ( FILE * stream, char * buffer );</Data></Cell>
    <Cell><Data ss:Type="String">setbuf</Data></Cell>
    <Cell><Data ss:Type="String">Set stream buffer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies an open stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">setvbuf( FILE * stream, char * buffer, int mode, size_t size )Param: (Pointer to a FILE object that identifies an open stream.)\t\nDesc: Change stream buffering (function)\t\nProto: int setvbuf ( FILE * stream, char * buffer, int mode, size_t size );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream, char * buffer, int mode, size_t size )</Data></Cell>
    <Cell><Data ss:Type="String">int setvbuf ( FILE * stream, char * buffer, int mode, size_t size );</Data></Cell>
    <Cell><Data ss:Type="String">setvbuf</Data></Cell>
    <Cell><Data ss:Type="String">Change stream buffering (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies an open stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fprintf( FILE * stream, const char * format, ... )Param: (Pointer to a FILE object that identifies an output stream.)\t\nDesc: Write formatted data to stream (function)\t\nProto: int fprintf ( FILE * stream, const char * format, ... );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream, const char * format, ... )</Data></Cell>
    <Cell><Data ss:Type="String">int fprintf ( FILE * stream, const char * format, ... );</Data></Cell>
    <Cell><Data ss:Type="String">fprintf</Data></Cell>
    <Cell><Data ss:Type="String">Write formatted data to stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies an output stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fscanf( FILE * stream, const char * format, ... )Param: (Pointer to a FILE object that identifies the input stream to read data from.)\t\nDesc: Read formatted data from stream (function)\t\nProto: int fscanf ( FILE * stream, const char * format, ... );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream, const char * format, ... )</Data></Cell>
    <Cell><Data ss:Type="String">int fscanf ( FILE * stream, const char * format, ... );</Data></Cell>
    <Cell><Data ss:Type="String">fscanf</Data></Cell>
    <Cell><Data ss:Type="String">Read formatted data from stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies the input stream to read data from.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vfprintf( FILE * stream, const char * format, va_list arg )Param: (Pointer to a FILE object that identifies an output stream.)\t\nDesc: Write formatted data from variable argument list to stream (function)\t\nProto: int vfprintf ( FILE * stream, const char * format, va_list arg );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream, const char * format, va_list arg )</Data></Cell>
    <Cell><Data ss:Type="String">int vfprintf ( FILE * stream, const char * format, va_list arg );</Data></Cell>
    <Cell><Data ss:Type="String">vfprintf</Data></Cell>
    <Cell><Data ss:Type="String">Write formatted data from variable argument list to stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies an output stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vfscanf( FILE * stream, const char * format, va_list arg )Param: (Pointer to a FILE object that identifies an input stream.)\t\nDesc: Read formatted data from stream into variable argument list (function)\t\nProto: int vfscanf ( FILE * stream, const char * format, va_list arg );\t\n[c99 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream, const char * format, va_list arg )</Data></Cell>
    <Cell><Data ss:Type="String">int vfscanf ( FILE * stream, const char * format, va_list arg );</Data></Cell>
    <Cell><Data ss:Type="String">vfscanf</Data></Cell>
    <Cell><Data ss:Type="String">Read formatted data from stream into variable argument list (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies an input stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fsetpos( FILE * stream, const fpos_t * pos )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Set position indicator of stream (function)\t\nProto: int fsetpos ( FILE * stream, const fpos_t * pos );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream, const fpos_t * pos )</Data></Cell>
    <Cell><Data ss:Type="String">int fsetpos ( FILE * stream, const fpos_t * pos );</Data></Cell>
    <Cell><Data ss:Type="String">fsetpos</Data></Cell>
    <Cell><Data ss:Type="String">Set position indicator of stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies the stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fgetpos( FILE * stream, fpos_t * pos )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Get current position in stream (function)\t\nProto: int fgetpos ( FILE * stream, fpos_t * pos );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream, fpos_t * pos )</Data></Cell>
    <Cell><Data ss:Type="String">int fgetpos ( FILE * stream, fpos_t * pos );</Data></Cell>
    <Cell><Data ss:Type="String">fgetpos</Data></Cell>
    <Cell><Data ss:Type="String">Get current position in stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies the stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fseek( FILE * stream, long int offset, int origin )Param: (Pointer to a FILE object that identifies the stream.)\t\nDesc: Reposition stream position indicator (function)\t\nProto: int fseek ( FILE * stream, long int offset, int origin );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( FILE * stream, long int offset, int origin )</Data></Cell>
    <Cell><Data ss:Type="String">int fseek ( FILE * stream, long int offset, int origin );</Data></Cell>
    <Cell><Data ss:Type="String">fseek</Data></Cell>
    <Cell><Data ss:Type="String">Reposition stream position indicator (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies the stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">uninitialized_copy( InputIterator first, InputIterator last,    ForwardIterator result )Param: (Input iterators to the initial and final positions in a sequence to be copied.)\t\nDesc: Copy block of memory (function template)\t\nProto: template &lt;class InputIterator, class ForwardIterator&gt;\t\nForwardIterator uninitialized_copy ( InputIterator first, InputIterator last,    ForwardIterator result );\t\n[cpp98 cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( InputIterator first, InputIterator last,    ForwardIterator result )</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class ForwardIterator&gt;\t\nForwardIterator uninitialized_copy ( InputIterator first, InputIterator last,    ForwardIterator result );</Data></Cell>
    <Cell><Data ss:Type="String">uninitialized_copy</Data></Cell>
    <Cell><Data ss:Type="String">Copy block of memory (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence to be copied.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">uninitialized_copy_n( InputIterator first, Size n,ForwardIterator result )Param: (Forward iterator to the initial position in an uninitialized sequence of at least n elements.)\t\nDesc: Copy block of memory (function template)\t\nProto: template &lt;class InputIterator, class Size, class ForwardIterator&gt;\t\nForwardIterator uninitialized_copy_n ( InputIterator first, Size n,ForwardIterator result );\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( InputIterator first, Size n,ForwardIterator result )</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class Size, class ForwardIterator&gt;\t\nForwardIterator uninitialized_copy_n ( InputIterator first, Size n,ForwardIterator result );</Data></Cell>
    <Cell><Data ss:Type="String">uninitialized_copy_n</Data></Cell>
    <Cell><Data ss:Type="String">Copy block of memory (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterator to the initial position in an uninitialized sequence of at least n elements.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isalnum( int c )Param: (Character to be checked, casted as an int, or EOF.)\t\nDesc: Check if character is alphanumeric (function)\t\nProto: int isalnum ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int isalnum ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">isalnum</Data></Cell>
    <Cell><Data ss:Type="String">Check if character is alphanumeric (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be checked, casted as an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isalpha( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is alphabetic (function)\t\nProto: int isalpha ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int isalpha ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">isalpha</Data></Cell>
    <Cell><Data ss:Type="String">Check if character is alphabetic (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be checked, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isblank( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is blank (function)\t\nProto: int isblank ( int c );\t\n[c99 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int isblank ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">isblank</Data></Cell>
    <Cell><Data ss:Type="String">Check if character is blank (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be checked, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iscntrl( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is a control character (function)\t\nProto: int iscntrl ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int iscntrl ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">iscntrl</Data></Cell>
    <Cell><Data ss:Type="String">Check if character is a control character (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be checked, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isdigit( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is decimal digit (function)\t\nProto: int isdigit ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int isdigit ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">isdigit</Data></Cell>
    <Cell><Data ss:Type="String">Check if character is decimal digit (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be checked, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isgraph( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character has graphical representation (function)\t\nProto: int isgraph ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int isgraph ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">isgraph</Data></Cell>
    <Cell><Data ss:Type="String">Check if character has graphical representation (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be checked, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">islower( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is lowercase letter (function)\t\nProto: int islower ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int islower ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">islower</Data></Cell>
    <Cell><Data ss:Type="String">Check if character is lowercase letter (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be checked, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isprint( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is printable (function)\t\nProto: int isprint ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int isprint ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">isprint</Data></Cell>
    <Cell><Data ss:Type="String">Check if character is printable (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be checked, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ispunct( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is a punctuation character (function)\t\nProto: int ispunct ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int ispunct ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">ispunct</Data></Cell>
    <Cell><Data ss:Type="String">Check if character is a punctuation character (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be checked, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isspace( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is a white-space (function)\t\nProto: int isspace ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int isspace ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">isspace</Data></Cell>
    <Cell><Data ss:Type="String">Check if character is a white-space (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be checked, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isupper( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is uppercase letter (function)\t\nProto: int isupper ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int isupper ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">isupper</Data></Cell>
    <Cell><Data ss:Type="String">Check if character is uppercase letter (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be checked, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">isxdigit( int c )Param: (Character to be checked, casted to an int, or EOF.)\t\nDesc: Check if character is hexadecimal digit (function)\t\nProto: int isxdigit ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int isxdigit ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">isxdigit</Data></Cell>
    <Cell><Data ss:Type="String">Check if character is hexadecimal digit (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be checked, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">tolower( int c )Param: (Character to be converted, casted to an int, or EOF.)\t\nDesc: Convert uppercase letter to lowercase (function)\t\nProto: int tolower ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int tolower ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">tolower</Data></Cell>
    <Cell><Data ss:Type="String">Convert uppercase letter to lowercase (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be converted, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">toupper( int c )Param: (Character to be converted, casted to an int, or EOF.)\t\nDesc: Convert lowercase letter to uppercase (function)\t\nProto: int toupper ( int c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cctype&gt; (ctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int c )</Data></Cell>
    <Cell><Data ss:Type="String">int toupper ( int c );</Data></Cell>
    <Cell><Data ss:Type="String">toupper</Data></Cell>
    <Cell><Data ss:Type="String">Convert lowercase letter to uppercase (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Character to be converted, casted to an int, or EOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cctype&gt; (ctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Character handling functions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">putchar( int character )Param: (The int promotion of the character to be written.)\t\nDesc: Write character to stdout (function)\t\nProto: int putchar ( int character );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int character )</Data></Cell>
    <Cell><Data ss:Type="String">int putchar ( int character );</Data></Cell>
    <Cell><Data ss:Type="String">putchar</Data></Cell>
    <Cell><Data ss:Type="String">Write character to stdout (function)</Data></Cell>
    <Cell><Data ss:Type="String">(character)</Data></Cell>
    <Cell><Data ss:Type="String">The int promotion of the character to be written.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fputc( int character, FILE * stream )Param: (The int promotion of the character to be written.)\t\nDesc: Write character to stream (function)\t\nProto: int fputc ( int character, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int character, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">int fputc ( int character, FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">fputc</Data></Cell>
    <Cell><Data ss:Type="String">Write character to stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(character)</Data></Cell>
    <Cell><Data ss:Type="String">The int promotion of the character to be written.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ungetc( int character, FILE * stream )Param: (The int promotion of the character to be put back.)\t\nDesc: Unget character from stream (function)\t\nProto: int ungetc ( int character, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int character, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">int ungetc ( int character, FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">ungetc</Data></Cell>
    <Cell><Data ss:Type="String">Unget character from stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(character)</Data></Cell>
    <Cell><Data ss:Type="String">The int promotion of the character to be put back.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strerror( int errnum )Param: (Error number.)\t\nDesc: Get pointer to error message string (function)\t\nProto: char * strerror ( int errnum );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int errnum )</Data></Cell>
    <Cell><Data ss:Type="String">char * strerror ( int errnum );</Data></Cell>
    <Cell><Data ss:Type="String">strerror</Data></Cell>
    <Cell><Data ss:Type="String">Get pointer to error message string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(errnum)</Data></Cell>
    <Cell><Data ss:Type="String">Error number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">itoa( int value, char * str, int base )Param: (Value to be converted to a string.)\t\nDesc: no-Description (other)\t\nProto: char * itoa ( int value, char * str, int base );\t\n[arm] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( int value, char * str, int base )</Data></Cell>
    <Cell><Data ss:Type="String">char * itoa ( int value, char * str, int base );</Data></Cell>
    <Cell><Data ss:Type="String">itoa</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">(value)</Data></Cell>
    <Cell><Data ss:Type="String">Value to be converted to a string.</Data></Cell>
    <Cell><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">arm</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">get_temporary_buffer( ptrdiff_t n )Param: (Number of elements of type T for which temporary memory is requested.)\t\nDesc: Get block of temporary memory (function template)\t\nProto: template &lt;class T&gt; pair &lt;T*,ptrdiff_t&gt; get_temporary_buffer ( ptrdiff_t n );\t\n[cpp98 cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( ptrdiff_t n )</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; pair &lt;T*,ptrdiff_t&gt; get_temporary_buffer ( ptrdiff_t n );</Data></Cell>
    <Cell><Data ss:Type="String">get_temporary_buffer</Data></Cell>
    <Cell><Data ss:Type="String">Get block of temporary memory (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(n)</Data></Cell>
    <Cell><Data ss:Type="String">Number of elements of type T for which temporary memory is requested.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">getchar( void )Param: ()\t\nDesc: Get character from stdin (function)\t\nProto: int getchar ( void );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( void )</Data></Cell>
    <Cell><Data ss:Type="String">int getchar ( void );</Data></Cell>
    <Cell><Data ss:Type="String">getchar</Data></Cell>
    <Cell><Data ss:Type="String">Get character from stdin (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">tmpfile( void )Param: ()\t\nDesc: Open a temporary file (function)\t\nProto: FILE * tmpfile ( void );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( void )</Data></Cell>
    <Cell><Data ss:Type="String">FILE * tmpfile ( void );</Data></Cell>
    <Cell><Data ss:Type="String">tmpfile</Data></Cell>
    <Cell><Data ss:Type="String">Open a temporary file (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">memcpy( void * destination, const void * source, size_t num )Param: (Pointer to the destination array where the content is to be copied, type-casted to a pointer of type )\t\nDesc: Copy block of memory (function)\t\nProto: void * memcpy ( void * destination, const void * source, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( void * destination, const void * source, size_t num )</Data></Cell>
    <Cell><Data ss:Type="String">void * memcpy ( void * destination, const void * source, size_t num );</Data></Cell>
    <Cell><Data ss:Type="String">memcpy</Data></Cell>
    <Cell><Data ss:Type="String">Copy block of memory (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array where the content is to be copied, type-casted to a pointer of type </Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">memmove( void * destination, const void * source, size_t num )Param: (Pointer to the destination array where the content is to be copied, type-casted to a pointer of type )\t\nDesc: Move block of memory (function)\t\nProto: void * memmove ( void * destination, const void * source, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( void * destination, const void * source, size_t num )</Data></Cell>
    <Cell><Data ss:Type="String">void * memmove ( void * destination, const void * source, size_t num );</Data></Cell>
    <Cell><Data ss:Type="String">memmove</Data></Cell>
    <Cell><Data ss:Type="String">Move block of memory (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array where the content is to be copied, type-casted to a pointer of type </Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">memset( void * ptr, int value, size_t num )Param: (Pointer to the block of memory to fill.)\t\nDesc: Fill block of memory (function)\t\nProto: void * memset ( void * ptr, int value, size_t num );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstring&gt; (string.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, int value, size_t num )</Data></Cell>
    <Cell><Data ss:Type="String">void * memset ( void * ptr, int value, size_t num );</Data></Cell>
    <Cell><Data ss:Type="String">memset</Data></Cell>
    <Cell><Data ss:Type="String">Fill block of memory (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the block of memory to fill.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstring&gt; (string.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fread( void * ptr, size_t size, size_t count, FILE * stream )Param: (Pointer to a block of memory with a size of at least (size*count) bytes, converted to a )\t\nDesc: Read block of data from stream (function)\t\nProto: size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );</Data></Cell>
    <Cell><Data ss:Type="String">fread</Data></Cell>
    <Cell><Data ss:Type="String">Read block of data from stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a block of memory with a size of at least (size*count) bytes, converted to a </Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">towlower( void * ptr, size_t size, size_t count, FILE * stream )Param: (Wide character to be converted, casted to a wint_t value, or WEOF.)\t\nDesc: Convert uppercase wide character to lowercase (function)\t\nProto: wint_t towlower ( wint_t c );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">wint_t towlower ( wint_t c );</Data></Cell>
    <Cell><Data ss:Type="String">towlower</Data></Cell>
    <Cell><Data ss:Type="String">Convert uppercase wide character to lowercase (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be converted, casted to a wint_t value, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">future_category( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return future category (function)\t\nProto: const error_category&amp; future_category() noexcept;\t\n[cpp11] [&lt;future&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">const error_category&amp; future_category() noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">future_category</Data></Cell>
    <Cell><Data ss:Type="String">Return future category (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;future&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Future</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">current_exception( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get smart pointer to current exception (function)\t\nProto: exception_ptr current_exception() noexcept;\t\n[cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">exception_ptr current_exception() noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">current_exception</Data></Cell>
    <Cell><Data ss:Type="String">Get smart pointer to current exception (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">get_terminate( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get terminate handler function (function)\t\nProto: terminate_handler get_terminate() noexcept;\t\n[cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">terminate_handler get_terminate() noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">get_terminate</Data></Cell>
    <Cell><Data ss:Type="String">Get terminate handler function (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">get_unexpected( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get unexpected handler function (function)\t\nProto: unexpected_handler get_unexpected() noexcept;\t\n[cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">unexpected_handler get_unexpected() noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">get_unexpected</Data></Cell>
    <Cell><Data ss:Type="String">Get unexpected handler function (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">get_pointer_safety( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get pointer safety (function)\t\nProto: pointer_safety get_pointer_safety() noexcept;\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">pointer_safety get_pointer_safety() noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">get_pointer_safety</Data></Cell>
    <Cell><Data ss:Type="String">Get pointer safety (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">get_new_handler( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Get new handler function (function)\t\nProto: new_handler get_new_handler() noexcept;\t\n[cpp11] [&lt;new&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">new_handler get_new_handler() noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">get_new_handler</Data></Cell>
    <Cell><Data ss:Type="String">Get new handler function (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;new&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Dynamic memory</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">generic_category( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return generic category (function)\t\nProto: const error_category&amp; generic_category() noexcept;\t\n[cpp11] [&lt;system_error&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">const error_category&amp; generic_category() noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">generic_category</Data></Cell>
    <Cell><Data ss:Type="String">Return generic category (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;system_error&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">System errors</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">system_category( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return system category (function)\t\nProto: const error_category&amp; system_category() noexcept;\t\n[cpp11] [&lt;system_error&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">const error_category&amp; system_category() noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">system_category</Data></Cell>
    <Cell><Data ss:Type="String">Return system category (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;system_error&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">System errors</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">declval( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Declaration value (function template)\t\nProto: template &lt;class T&gt;\t\ntypename add_rvalue_reference&lt;T&gt;::type declval() noexcept;\t\n[cpp11] [&lt;utility&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt;\t\ntypename add_rvalue_reference&lt;T&gt;::type declval() noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">declval</Data></Cell>
    <Cell><Data ss:Type="String">Declaration value (function template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;utility&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Utility components</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">uncaught_exception( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return exception status (function)\t\nProto: bool uncaught_exception() throw();\t\n[cpp98 cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">bool uncaught_exception() throw();</Data></Cell>
    <Cell><Data ss:Type="String">uncaught_exception</Data></Cell>
    <Cell><Data ss:Type="String">Return exception status (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iostream_category( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Return iostream category (function)\t\nProto: const error_category&amp; iostream_category();\t\n[cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">const error_category&amp; iostream_category();</Data></Cell>
    <Cell><Data ss:Type="String">iostream_category</Data></Cell>
    <Cell><Data ss:Type="String">Return iostream category (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">signal( void * ptr, size_t size, size_t count, FILE * stream )Param: (The signal value to which a handling function is set.)\t\nDesc: Set function to handle signal (function)\t\nProto: void (*signal(int sig, void (*func)(int)))(int);\t\n[c90 c99 arm cpp98 cpp11] [&lt;csignal&gt; (signal.h)]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">void (*signal(int sig, void (*func)(int)))(int);</Data></Cell>
    <Cell><Data ss:Type="String">signal</Data></Cell>
    <Cell><Data ss:Type="String">Set function to handle signal (function)</Data></Cell>
    <Cell><Data ss:Type="String">(sig)</Data></Cell>
    <Cell><Data ss:Type="String">The signal value to which a handling function is set.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;csignal&gt; (signal.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to handle signals</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">terminate_handler( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Type of terminate handler function (type)\t\nProto: typedef void (*terminate_handler)();\t\n[cpp98 cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">typedef void (*terminate_handler)();</Data></Cell>
    <Cell><Data ss:Type="String">terminate_handler</Data></Cell>
    <Cell><Data ss:Type="String">Type of terminate handler function (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">unexpected_handler( void * ptr, size_t size, size_t count, FILE * stream )Param: ()\t\nDesc: Type of unexpected handler function (type)\t\nProto: typedef void (*unexpected_handler)();\t\n[cpp98 cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">( void * ptr, size_t size, size_t count, FILE * stream )</Data></Cell>
    <Cell><Data ss:Type="String">typedef void (*unexpected_handler)();</Data></Cell>
    <Cell><Data ss:Type="String">unexpected_handler</Data></Cell>
    <Cell><Data ss:Type="String">Type of unexpected handler function (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">make_shared(Args&amp;&amp;... args)Param: (List of elements passed to T's constructor.)\t\nDesc: Make shared_ptr (function template)\t\nProto: template &lt;class T, class... Args&gt;\t\nshared_ptr&lt;T&gt; make_shared (Args&amp;&amp;... args);\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(Args&amp;&amp;... args)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class... Args&gt;\t\nshared_ptr&lt;T&gt; make_shared (Args&amp;&amp;... args);</Data></Cell>
    <Cell><Data ss:Type="String">make_shared</Data></Cell>
    <Cell><Data ss:Type="String">Make shared_ptr (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(args)</Data></Cell>
    <Cell><Data ss:Type="String">List of elements passed to T's constructor.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">result_of(Fn)Param: (A callable type (i.)\t\nDesc: Result of call (class template)\t\nProto: template &lt;class Fn, class... ArgTypes&gt; struct result_of&lt;Fn(ArgTypes...)&gt;;\t\n[cpp11] [&lt;type_traits&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ArgTypes...)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Fn, class... ArgTypes&gt; struct result_of&lt;Fn(ArgTypes...)&gt;;</Data></Cell>
    <Cell><Data ss:Type="String">result_of</Data></Cell>
    <Cell><Data ss:Type="String">Result of call (class template)</Data></Cell>
    <Cell><Data ss:Type="String">(Fn)</Data></Cell>
    <Cell><Data ss:Type="String">A callable type (i.</Data></Cell>
    <Cell><Data ss:Type="String">class template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;type_traits&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">type_traits</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">reverse_copy(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence to be copied.)\t\nDesc: Copy range reversed (function template)\t\nProto: template &lt;class BidirectionalIterator, class OutputIterator&gt;\t\nOutputIterator reverse_copy (BidirectionalIterator first,   BidirectionalIterator last, OutputIterator result);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(BidirectionalIterator first,   BidirectionalIterator last, OutputIterator result)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class BidirectionalIterator, class OutputIterator&gt;\t\nOutputIterator reverse_copy (BidirectionalIterator first,   BidirectionalIterator last, OutputIterator result);</Data></Cell>
    <Cell><Data ss:Type="String">reverse_copy</Data></Cell>
    <Cell><Data ss:Type="String">Copy range reversed (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Bidirectional iterators to the initial and final positions of the sequence to be copied.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">reverse(first, last)Param: (Bidirectional iterators to the initial and final positions of the sequence to be reversed.)\t\nDesc: Reverse range (function template)\t\nProto: template &lt;class BidirectionalIterator&gt;\t\nvoid reverse (BidirectionalIterator first, BidirectionalIterator last);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(BidirectionalIterator first, BidirectionalIterator last)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class BidirectionalIterator&gt;\t\nvoid reverse (BidirectionalIterator first, BidirectionalIterator last);</Data></Cell>
    <Cell><Data ss:Type="String">reverse</Data></Cell>
    <Cell><Data ss:Type="String">Reverse range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Bidirectional iterators to the initial and final positions of the sequence to be reversed.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vsprintf(char * s, const char * format, va_list arg )Param: (Pointer to a buffer where the resulting C-string is stored.)\t\nDesc: Write formatted data from variable argument list to string (function)\t\nProto: int vsprintf (char * s, const char * format, va_list arg );\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(char * s, const char * format, va_list arg )</Data></Cell>
    <Cell><Data ss:Type="String">int vsprintf (char * s, const char * format, va_list arg );</Data></Cell>
    <Cell><Data ss:Type="String">vsprintf</Data></Cell>
    <Cell><Data ss:Type="String">Write formatted data from variable argument list to string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(s)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a buffer where the resulting C-string is stored.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vsnprintf(char * s, size_t n, const char * format, va_list arg )Param: (Pointer to a buffer where the resulting C-string is stored.)\t\nDesc: Write formatted data from variable argument list to sized buffer (function)\t\nProto: int vsnprintf (char * s, size_t n, const char * format, va_list arg );\t\n[c99 cpp11] [&lt;cstdio&gt; (stdio.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(char * s, size_t n, const char * format, va_list arg )</Data></Cell>
    <Cell><Data ss:Type="String">int vsnprintf (char * s, size_t n, const char * format, va_list arg );</Data></Cell>
    <Cell><Data ss:Type="String">vsnprintf</Data></Cell>
    <Cell><Data ss:Type="String">Write formatted data from variable argument list to sized buffer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(s)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a buffer where the resulting C-string is stored.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdio&gt; (stdio.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C library to perform Input/Output operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcstombs(char* dest, const wchar_t* src, size_t max)Param: (Pointer to an array of char elements long enough to contain the resulting sequence (at most, max bytes).)\t\nDesc: Convert wide-character string to multibyte string (function)\t\nProto: size_t wcstombs (char* dest, const wchar_t* src, size_t max);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(char* dest, const wchar_t* src, size_t max)</Data></Cell>
    <Cell><Data ss:Type="String">size_t wcstombs (char* dest, const wchar_t* src, size_t max);</Data></Cell>
    <Cell><Data ss:Type="String">wcstombs</Data></Cell>
    <Cell><Data ss:Type="String">Convert wide-character string to multibyte string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(dest)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an array of char elements long enough to contain the resulting sequence (at most, max bytes).</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcsrtombs(char* dest, const wchar_t** src, size_t max, mbstate_t* ps)Param: (Pointer to an array of char elements long enough to store a C string of max bytes.)\t\nDesc: Convert wide-character string to multibyte string (function)\t\nProto: size_t wcsrtombs (char* dest, const wchar_t** src, size_t max, mbstate_t* ps);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(char* dest, const wchar_t** src, size_t max, mbstate_t* ps)</Data></Cell>
    <Cell><Data ss:Type="String">size_t wcsrtombs (char* dest, const wchar_t** src, size_t max, mbstate_t* ps);</Data></Cell>
    <Cell><Data ss:Type="String">wcsrtombs</Data></Cell>
    <Cell><Data ss:Type="String">Convert wide-character string to multibyte string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(dest)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an array of char elements long enough to store a C string of max bytes.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">declare_no_pointers(char* p, size_t n)Param: (Pointer to the first byte of the range to be declared.)\t\nDesc: Declare memory block as containing no pointers (function)\t\nProto: void declare_no_pointers (char* p, size_t n);\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(char* p, size_t n)</Data></Cell>
    <Cell><Data ss:Type="String">void declare_no_pointers (char* p, size_t n);</Data></Cell>
    <Cell><Data ss:Type="String">declare_no_pointers</Data></Cell>
    <Cell><Data ss:Type="String">Declare memory block as containing no pointers (function)</Data></Cell>
    <Cell><Data ss:Type="String">(p)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the first byte of the range to be declared.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">undeclare_no_pointers(char* p, size_t n)Param: (Pointer to the first byte of the range.)\t\nDesc: Undeclare memory block as containing no pointers (function)\t\nProto: void undeclare_no_pointers (char* p, size_t n);\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(char* p, size_t n)</Data></Cell>
    <Cell><Data ss:Type="String">void undeclare_no_pointers (char* p, size_t n);</Data></Cell>
    <Cell><Data ss:Type="String">undeclare_no_pointers</Data></Cell>
    <Cell><Data ss:Type="String">Undeclare memory block as containing no pointers (function)</Data></Cell>
    <Cell><Data ss:Type="String">(p)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the first byte of the range.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wctomb(char* pmb, wchar_t wc)Param: ()\t\nDesc: Convert wide character to multibyte sequence (function)\t\nProto: int wctomb (char* pmb, wchar_t wc);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(char* pmb, wchar_t wc)</Data></Cell>
    <Cell><Data ss:Type="String">int wctomb (char* pmb, wchar_t wc);</Data></Cell>
    <Cell><Data ss:Type="String">wctomb</Data></Cell>
    <Cell><Data ss:Type="String">Convert wide character to multibyte sequence (function)</Data></Cell>
    <Cell><Data ss:Type="String">(pmb)</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcrtomb(char* pmb, wchar_t wc, mbstate_t* ps)Param: (Pointer to an array large enough to hold a multibyte sequence.)\t\nDesc: Convert wide character to multibyte sequence (function)\t\nProto: size_t wcrtomb (char* pmb, wchar_t wc, mbstate_t* ps);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(char* pmb, wchar_t wc, mbstate_t* ps)</Data></Cell>
    <Cell><Data ss:Type="String">size_t wcrtomb (char* pmb, wchar_t wc, mbstate_t* ps);</Data></Cell>
    <Cell><Data ss:Type="String">wcrtomb</Data></Cell>
    <Cell><Data ss:Type="String">Convert wide character to multibyte sequence (function)</Data></Cell>
    <Cell><Data ss:Type="String">(pmb)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an array large enough to hold a multibyte sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strftime(char* ptr, size_t maxsize, const char* format,const struct tm* timeptr )Param: (Pointer to the destination array where the resulting C string is copied.)\t\nDesc: Format time as string (function)\t\nProto: size_t strftime (char* ptr, size_t maxsize, const char* format,const struct tm* timeptr );\t\n[c90 c99 arm cpp98 cpp11] [&lt;ctime&gt; (time.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(char* ptr, size_t maxsize, const char* format,const struct tm* timeptr )</Data></Cell>
    <Cell><Data ss:Type="String">size_t strftime (char* ptr, size_t maxsize, const char* format,const struct tm* timeptr );</Data></Cell>
    <Cell><Data ss:Type="String">strftime</Data></Cell>
    <Cell><Data ss:Type="String">Format time as string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array where the resulting C string is copied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ctime&gt; (time.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Time Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">setfill(char_type c)Param: (The new fill character for the stream.)\t\nDesc: Set fill character (function)\t\nProto: /*unspecified*/ setfill (char_type c);\t\n[arm cpp98 cpp11] [&lt;iomanip&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(char_type c)</Data></Cell>
    <Cell><Data ss:Type="String">/*unspecified*/ setfill (char_type c);</Data></Cell>
    <Cell><Data ss:Type="String">setfill</Data></Cell>
    <Cell><Data ss:Type="String">Set fill character (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">The new fill character for the stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iomanip&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">IO Manipulators</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">notify_all_at_thread_exit(condition_variable&amp; cond, unique_lock&lt;mutex&gt; lck)Param: (A condition_variable object to notify all at thread exit.)\t\nDesc: Notify all at thread exit (function)\t\nProto: void notify_all_at_thread_exit (condition_variable&amp; cond, unique_lock&lt;mutex&gt; lck);\t\n[cpp11] [&lt;condition_variable&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(condition_variable&amp; cond, unique_lock&lt;mutex&gt; lck)</Data></Cell>
    <Cell><Data ss:Type="String">void notify_all_at_thread_exit (condition_variable&amp; cond, unique_lock&lt;mutex&gt; lck);</Data></Cell>
    <Cell><Data ss:Type="String">notify_all_at_thread_exit</Data></Cell>
    <Cell><Data ss:Type="String">Notify all at thread exit (function)</Data></Cell>
    <Cell><Data ss:Type="String">(cond)</Data></Cell>
    <Cell><Data ss:Type="String">A condition_variable object to notify all at thread exit.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;condition_variable&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Condition variable</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">allocate_shared(const Alloc&amp; alloc, Args&amp;&amp;... args)Param: (An allocator object.)\t\nDesc: Allocate shared_ptr (function template)\t\nProto: template &lt;class T, class Alloc, class... Args&gt;\t\nshared_ptr&lt;T&gt; allocate_shared (const Alloc&amp; alloc, Args&amp;&amp;... args);\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const Alloc&amp; alloc, Args&amp;&amp;... args)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class Alloc, class... Args&gt;\t\nshared_ptr&lt;T&gt; allocate_shared (const Alloc&amp; alloc, Args&amp;&amp;... args);</Data></Cell>
    <Cell><Data ss:Type="String">allocate_shared</Data></Cell>
    <Cell><Data ss:Type="String">Allocate shared_ptr (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(alloc)</Data></Cell>
    <Cell><Data ss:Type="String">An allocator object.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atoi(const char * str)Param: (C-string beginning with the representation of an integral number.)\t\nDesc: Convert string to integer (function)\t\nProto: int atoi (const char * str);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char * str)</Data></Cell>
    <Cell><Data ss:Type="String">int atoi (const char * str);</Data></Cell>
    <Cell><Data ss:Type="String">atoi</Data></Cell>
    <Cell><Data ss:Type="String">Convert string to integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C-string beginning with the representation of an integral number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">system(const char* command)Param: (C-string containing the system command to be executed.)\t\nDesc: Execute system command (function)\t\nProto: int system (const char* command);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* command)</Data></Cell>
    <Cell><Data ss:Type="String">int system (const char* command);</Data></Cell>
    <Cell><Data ss:Type="String">system</Data></Cell>
    <Cell><Data ss:Type="String">Execute system command (function)</Data></Cell>
    <Cell><Data ss:Type="String">(command)</Data></Cell>
    <Cell><Data ss:Type="String">C-string containing the system command to be executed.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mblen(const char* pmb, size_t max)Param: (Pointer to the first byte of a multibyte character.)\t\nDesc: Get length of multibyte character (function)\t\nProto: int mblen (const char* pmb, size_t max);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* pmb, size_t max)</Data></Cell>
    <Cell><Data ss:Type="String">int mblen (const char* pmb, size_t max);</Data></Cell>
    <Cell><Data ss:Type="String">mblen</Data></Cell>
    <Cell><Data ss:Type="String">Get length of multibyte character (function)</Data></Cell>
    <Cell><Data ss:Type="String">(pmb)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the first byte of a multibyte character.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mbrlen(const char* pmb, size_t max, mbstate_t* ps)Param: (Pointer to the first byte of a multibyte character.)\t\nDesc: Get length of multibyte character (function)\t\nProto: size_t mbrlen (const char* pmb, size_t max, mbstate_t* ps);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* pmb, size_t max, mbstate_t* ps)</Data></Cell>
    <Cell><Data ss:Type="String">size_t mbrlen (const char* pmb, size_t max, mbstate_t* ps);</Data></Cell>
    <Cell><Data ss:Type="String">mbrlen</Data></Cell>
    <Cell><Data ss:Type="String">Get length of multibyte character (function)</Data></Cell>
    <Cell><Data ss:Type="String">(pmb)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the first byte of a multibyte character.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atof(const char* str)Param: (C-string beginning with the representation of a floating-point number.)\t\nDesc: Convert string to double (function)\t\nProto: double atof (const char* str);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* str)</Data></Cell>
    <Cell><Data ss:Type="String">double atof (const char* str);</Data></Cell>
    <Cell><Data ss:Type="String">atof</Data></Cell>
    <Cell><Data ss:Type="String">Convert string to double (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C-string beginning with the representation of a floating-point number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strtod(const char* str, char** endptr)Param: (C-string beginning with the representation of a floating-point number.)\t\nDesc: Convert string to double (function)\t\nProto: double strtod (const char* str, char** endptr);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* str, char** endptr)</Data></Cell>
    <Cell><Data ss:Type="String">double strtod (const char* str, char** endptr);</Data></Cell>
    <Cell><Data ss:Type="String">strtod</Data></Cell>
    <Cell><Data ss:Type="String">Convert string to double (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C-string beginning with the representation of a floating-point number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strtof(const char* str, char** endptr)Param: (C-string beginning with the representation of a floating-point number.)\t\nDesc: Convert string to float (function)\t\nProto: float strtof (const char* str, char** endptr);\t\n[c99 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* str, char** endptr)</Data></Cell>
    <Cell><Data ss:Type="String">float strtof (const char* str, char** endptr);</Data></Cell>
    <Cell><Data ss:Type="String">strtof</Data></Cell>
    <Cell><Data ss:Type="String">Convert string to float (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C-string beginning with the representation of a floating-point number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strtold(const char* str, char** endptr)Param: (C string beginning with the representation of a floating-point number.)\t\nDesc: Convert string to long double (function)\t\nProto: long double strtold (const char* str, char** endptr);\t\n[c99 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* str, char** endptr)</Data></Cell>
    <Cell><Data ss:Type="String">long double strtold (const char* str, char** endptr);</Data></Cell>
    <Cell><Data ss:Type="String">strtold</Data></Cell>
    <Cell><Data ss:Type="String">Convert string to long double (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C string beginning with the representation of a floating-point number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strtol(const char* str, char** endptr, int base)Param: (C-string beginning with the representation of an integral number.)\t\nDesc: Convert string to long integer (function)\t\nProto: long int strtol (const char* str, char** endptr, int base);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* str, char** endptr, int base)</Data></Cell>
    <Cell><Data ss:Type="String">long int strtol (const char* str, char** endptr, int base);</Data></Cell>
    <Cell><Data ss:Type="String">strtol</Data></Cell>
    <Cell><Data ss:Type="String">Convert string to long integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C-string beginning with the representation of an integral number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strtoll(const char* str, char** endptr, int base)Param: (C-string beginning with the representation of an integral number.)\t\nDesc: Convert string to long long integer (function)\t\nProto: long long int strtoll (const char* str, char** endptr, int base);\t\n[c99 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* str, char** endptr, int base)</Data></Cell>
    <Cell><Data ss:Type="String">long long int strtoll (const char* str, char** endptr, int base);</Data></Cell>
    <Cell><Data ss:Type="String">strtoll</Data></Cell>
    <Cell><Data ss:Type="String">Convert string to long long integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C-string beginning with the representation of an integral number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strtoul(const char* str, char** endptr, int base)Param: (C-string containing the representation of an integral number.)\t\nDesc: Convert string to unsigned long integer (function)\t\nProto: unsigned long int strtoul (const char* str, char** endptr, int base);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* str, char** endptr, int base)</Data></Cell>
    <Cell><Data ss:Type="String">unsigned long int strtoul (const char* str, char** endptr, int base);</Data></Cell>
    <Cell><Data ss:Type="String">strtoul</Data></Cell>
    <Cell><Data ss:Type="String">Convert string to unsigned long integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C-string containing the representation of an integral number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">strtoull(const char* str, char** endptr, int base)Param: (C-string beginning with the representation of an integral number.)\t\nDesc: Convert string to unsigned long long integer (function)\t\nProto: unsigned long long int strtoull (const char* str, char** endptr, int base);\t\n[c99 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* str, char** endptr, int base)</Data></Cell>
    <Cell><Data ss:Type="String">unsigned long long int strtoull (const char* str, char** endptr, int base);</Data></Cell>
    <Cell><Data ss:Type="String">strtoull</Data></Cell>
    <Cell><Data ss:Type="String">Convert string to unsigned long long integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C-string beginning with the representation of an integral number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">nanf(const char* tagp)Param: (An implementation-specific C-string.)\t\nDesc: no-Description (other)\t\nProto: float nanf (const char* tagp);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* tagp)</Data></Cell>
    <Cell><Data ss:Type="String">float nanf (const char* tagp);</Data></Cell>
    <Cell><Data ss:Type="String">nanf</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">(tagp)</Data></Cell>
    <Cell><Data ss:Type="String">An implementation-specific C-string.</Data></Cell>
    <Cell><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">nanl(const char* tagp)Param: (An implementation-specific C-string.)\t\nDesc: no-Description (other)\t\nProto: float nanl (const char* tagp);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const char* tagp)</Data></Cell>
    <Cell><Data ss:Type="String">float nanl (const char* tagp);</Data></Cell>
    <Cell><Data ss:Type="String">nanl</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">(tagp)</Data></Cell>
    <Cell><Data ss:Type="String">An implementation-specific C-string.</Data></Cell>
    <Cell><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">regex_match(s)Param: (A string with the target sequence (the subject) against which the regex expression is matched.)\t\nDesc: Match sequence (function template)\t\nProto: template &lt;class charT, class traits&gt; bool regex_match (const charT* s, const basic_regex&lt;charT,traits&gt;&amp; rgx, regex_constants::match_flag_type flags = regex_constants::match_default);\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const charT* s, const basic_regex&lt;charT,traits&gt;&amp; rgx, regex_constants::match_flag_type flags = regex_constants::match_default)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class traits&gt; bool regex_match (const charT* s, const basic_regex&lt;charT,traits&gt;&amp; rgx, regex_constants::match_flag_type flags = regex_constants::match_default);</Data></Cell>
    <Cell><Data ss:Type="String">regex_match</Data></Cell>
    <Cell><Data ss:Type="String">Match sequence (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(s)</Data></Cell>
    <Cell><Data ss:Type="String">A string with the target sequence (the subject) against which the regex expression is matched.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[5]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">regex_search(s)Param: (A string with the target sequence (the subject) to be searched for a match of the regex expression.)\t\nDesc: Search sequence (function template)\t\nProto: template &lt;class charT, class traits&gt; bool regex_search (const charT* s, const basic_regex&lt;charT,traits&gt;&amp; rgx, regex_constants::match_flag_type flags = regex_constants::match_default);\t\n[cpp11] [&lt;regex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const charT* s, const basic_regex&lt;charT,traits&gt;&amp; rgx, regex_constants::match_flag_type flags = regex_constants::match_default)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT, class traits&gt; bool regex_search (const charT* s, const basic_regex&lt;charT,traits&gt;&amp; rgx, regex_constants::match_flag_type flags = regex_constants::match_default);</Data></Cell>
    <Cell><Data ss:Type="String">regex_search</Data></Cell>
    <Cell><Data ss:Type="String">Search sequence (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(s)</Data></Cell>
    <Cell><Data ss:Type="String">A string with the target sequence (the subject) to be searched for a match of the regex expression.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;regex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Regular Expressions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">conj(const complex&lt;T&gt;&amp; x)Param: (Complex value.)\t\nDesc: Complex conjugate (function template)\t\nProto: template&lt;class T&gt; complex&lt;T&gt; conj (const complex&lt;T&gt;&amp; x);\t\n[cpp98 cpp11] [&lt;complex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const complex&lt;T&gt;&amp; x)</Data></Cell>
    <Cell><Data ss:Type="String">template&lt;class T&gt; complex&lt;T&gt; conj (const complex&lt;T&gt;&amp; x);</Data></Cell>
    <Cell><Data ss:Type="String">conj</Data></Cell>
    <Cell><Data ss:Type="String">Complex conjugate (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Complex value.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;complex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Complex numbers library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">imag(const complex&lt;T&gt;&amp; x)Param: (Complex value.)\t\nDesc: Imaginary part of complex (function template)\t\nProto: template&lt;class T&gt; T imag (const complex&lt;T&gt;&amp; x);\t\n[cpp98 cpp11] [&lt;complex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const complex&lt;T&gt;&amp; x)</Data></Cell>
    <Cell><Data ss:Type="String">template&lt;class T&gt; T imag (const complex&lt;T&gt;&amp; x);</Data></Cell>
    <Cell><Data ss:Type="String">imag</Data></Cell>
    <Cell><Data ss:Type="String">Imaginary part of complex (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Complex value.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;complex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Complex numbers library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">proj(const complex&lt;T&gt;&amp; x)Param: (Complex value.)\t\nDesc: Complex projection. (function template)\t\nProto: template&lt;class T&gt; complex&lt;T&gt; proj (const complex&lt;T&gt;&amp; x);\t\n[cpp11] [&lt;complex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const complex&lt;T&gt;&amp; x)</Data></Cell>
    <Cell><Data ss:Type="String">template&lt;class T&gt; complex&lt;T&gt; proj (const complex&lt;T&gt;&amp; x);</Data></Cell>
    <Cell><Data ss:Type="String">proj</Data></Cell>
    <Cell><Data ss:Type="String">Complex projection. (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Complex value.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;complex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Complex numbers library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">duration_cast(const duration&lt;Rep,Period&gt;&amp; dtn)Param: (A duration object.)\t\nDesc: Duration cast (function template)\t\nProto: template &lt;class ToDuration, class Rep, class Period&gt;\t\nconstexpr ToDuration duration_cast (const duration&lt;Rep,Period&gt;&amp; dtn);\t\n[cpp11] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const duration&lt;Rep,Period&gt;&amp; dtn)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ToDuration, class Rep, class Period&gt;\t\nconstexpr ToDuration duration_cast (const duration&lt;Rep,Period&gt;&amp; dtn);</Data></Cell>
    <Cell><Data ss:Type="String">duration_cast</Data></Cell>
    <Cell><Data ss:Type="String">Duration cast (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(dtn)</Data></Cell>
    <Cell><Data ss:Type="String">A duration object.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fesetenv(const fenv_t* envp)Param: (Either a pointer to a fenv_t value (filled by a previous call to fegetenv or feholdexcept), or one of the floating-point environment macro.)\t\nDesc: Set floating-point environment (function)\t\nProto: int fesetenv (const fenv_t* envp);\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const fenv_t* envp)</Data></Cell>
    <Cell><Data ss:Type="String">int fesetenv (const fenv_t* envp);</Data></Cell>
    <Cell><Data ss:Type="String">fesetenv</Data></Cell>
    <Cell><Data ss:Type="String">Set floating-point environment (function)</Data></Cell>
    <Cell><Data ss:Type="String">(envp)</Data></Cell>
    <Cell><Data ss:Type="String">Either a pointer to a fenv_t value (filled by a previous call to fegetenv or feholdexcept), or one of the floating-point environment macro.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">feupdateenv(const fenv_t* envp)Param: (Either a pointer to a fenv_t value (filled by a previous call to fegetenv or feholdexcept), or one of the floating-point environment macro values.)\t\nDesc: Update floating-point environment (function)\t\nProto: int feupdateenv (const fenv_t* envp);\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const fenv_t* envp)</Data></Cell>
    <Cell><Data ss:Type="String">int feupdateenv (const fenv_t* envp);</Data></Cell>
    <Cell><Data ss:Type="String">feupdateenv</Data></Cell>
    <Cell><Data ss:Type="String">Update floating-point environment (function)</Data></Cell>
    <Cell><Data ss:Type="String">(envp)</Data></Cell>
    <Cell><Data ss:Type="String">Either a pointer to a fenv_t value (filled by a previous call to fegetenv or feholdexcept), or one of the floating-point environment macro values.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fesetexceptflag(const fexcept_t* flagp, int excepts)Param: (Pointer to a fexcept_t object with a representation of floating-point exceptions.)\t\nDesc: Set floating-point exception flags (function)\t\nProto: int fesetexceptflag (const fexcept_t* flagp, int excepts);\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const fexcept_t* flagp, int excepts)</Data></Cell>
    <Cell><Data ss:Type="String">int fesetexceptflag (const fexcept_t* flagp, int excepts);</Data></Cell>
    <Cell><Data ss:Type="String">fesetexceptflag</Data></Cell>
    <Cell><Data ss:Type="String">Set floating-point exception flags (function)</Data></Cell>
    <Cell><Data ss:Type="String">(flagp)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a fexcept_t object with a representation of floating-point exceptions.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">make_move_iterator(const Iterator&amp; it)Param: (An iterator.)\t\nDesc: Construct move iterator (function template)\t\nProto: template &lt;class Iterator&gt; move_iterator&lt;Iterator&gt; make_move_iterator (const Iterator&amp; it);\t\n[cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const Iterator&amp; it)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Iterator&gt; move_iterator&lt;Iterator&gt; make_move_iterator (const Iterator&amp; it);</Data></Cell>
    <Cell><Data ss:Type="String">make_move_iterator</Data></Cell>
    <Cell><Data ss:Type="String">Construct move iterator (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(it)</Data></Cell>
    <Cell><Data ss:Type="String">An iterator.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">has_facet(const locale&amp; loc)Param: (locale object.)\t\nDesc: Check if locale has facet (function template)\t\nProto: template &lt;class Facet&gt; bool has_facet (const locale&amp; loc) throw();\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const locale&amp; loc)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Facet&gt; bool has_facet (const locale&amp; loc) throw();</Data></Cell>
    <Cell><Data ss:Type="String">has_facet</Data></Cell>
    <Cell><Data ss:Type="String">Check if locale has facet (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(loc)</Data></Cell>
    <Cell><Data ss:Type="String">locale object.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">use_facet(const locale&amp; loc)Param: (locale object.)\t\nDesc: Access facet of locale (function template)\t\nProto: template &lt;class Facet&gt; const Facet&amp; use_facet (const locale&amp; loc);\t\n[cpp98 cpp11] [&lt;locale&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const locale&amp; loc)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Facet&gt; const Facet&amp; use_facet (const locale&amp; loc);</Data></Cell>
    <Cell><Data ss:Type="String">use_facet</Data></Cell>
    <Cell><Data ss:Type="String">Access facet of locale (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(loc)</Data></Cell>
    <Cell><Data ss:Type="String">locale object.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;locale&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mbsinit(const mbstate_t* ps)Param: (Pointer to an mbstate_t object.)\t\nDesc: Check if initial conversion state (function)\t\nProto: int mbsinit (const mbstate_t* ps);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const mbstate_t* ps)</Data></Cell>
    <Cell><Data ss:Type="String">int mbsinit (const mbstate_t* ps);</Data></Cell>
    <Cell><Data ss:Type="String">mbsinit</Data></Cell>
    <Cell><Data ss:Type="String">Check if initial conversion state (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ps)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an mbstate_t object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">put_money(const moneyT&amp; mon, bool intl = false)Param: (Monetary value.)\t\nDesc: Put monetary value (function)\t\nProto: template &lt;class moneyT&gt;\t\n/*unspecified*/ put_money (const moneyT&amp; mon, bool intl = false);\t\n[cpp11] [&lt;iomanip&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const moneyT&amp; mon, bool intl = false)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class moneyT&gt;\t\n/*unspecified*/ put_money (const moneyT&amp; mon, bool intl = false);</Data></Cell>
    <Cell><Data ss:Type="String">put_money</Data></Cell>
    <Cell><Data ss:Type="String">Put monetary value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(mon)</Data></Cell>
    <Cell><Data ss:Type="String">Monetary value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iomanip&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">IO Manipulators</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bind1st(const Operation&amp; op, const T&amp; x)Param: ()\t\nDesc: Return function object with first parameter bound (function template)\t\nProto: template &lt;class Operation, class T&gt;\t\nbinder1st&lt;Operation&gt; bind1st (const Operation&amp; op, const T&amp; x);\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const Operation&amp; op, const T&amp; x)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Operation, class T&gt;\t\nbinder1st&lt;Operation&gt; bind1st (const Operation&amp; op, const T&amp; x);</Data></Cell>
    <Cell><Data ss:Type="String">bind1st</Data></Cell>
    <Cell><Data ss:Type="String">Return function object with first parameter bound (function template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bind2nd(const Operation&amp; op, const T&amp; x)Param: ()\t\nDesc: Return function object with second parameter bound (function template)\t\nProto: template &lt;class Operation, class T&gt;\t\nbinder2nd&lt;Operation&gt; bind2nd (const Operation&amp; op, const T&amp; x);\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const Operation&amp; op, const T&amp; x)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Operation, class T&gt;\t\nbinder2nd&lt;Operation&gt; bind2nd (const Operation&amp; op, const T&amp; x);</Data></Cell>
    <Cell><Data ss:Type="String">bind2nd</Data></Cell>
    <Cell><Data ss:Type="String">Return function object with second parameter bound (function template)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">not1(const Predicate&amp; pred)Param: (Unary function object of a class type with member argument_type defined.)\t\nDesc: Return negation of unary function object (function template)\t\nProto: template &lt;class Predicate&gt;\t\nunary_negate&lt;Predicate&gt; not1 (const Predicate&amp; pred);\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const Predicate&amp; pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Predicate&gt;\t\nunary_negate&lt;Predicate&gt; not1 (const Predicate&amp; pred);</Data></Cell>
    <Cell><Data ss:Type="String">not1</Data></Cell>
    <Cell><Data ss:Type="String">Return negation of unary function object (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(pred)</Data></Cell>
    <Cell><Data ss:Type="String">Unary function object of a class type with member argument_type defined.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">not2(const Predicate&amp; pred)Param: (Binary function object derived from binary_function.)\t\nDesc: Return negation of binary function object (function template)\t\nProto: template &lt;class Predicate&gt;\t\nbinary_negate&lt;Predicate&gt; not2 (const Predicate&amp; pred);\t\n[cpp98 cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const Predicate&amp; pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Predicate&gt;\t\nbinary_negate&lt;Predicate&gt; not2 (const Predicate&amp; pred);</Data></Cell>
    <Cell><Data ss:Type="String">not2</Data></Cell>
    <Cell><Data ss:Type="String">Return negation of binary function object (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(Predicate)</Data></Cell>
    <Cell><Data ss:Type="String">Binary function object derived from binary_function.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">get_deleter(const shared_ptr&lt;T&gt;&amp; sp)Param: (A shared_ptr object.)\t\nDesc: Get deleter from shared_ptr (function template)\t\nProto: template &lt;class D, class T&gt;\t\nD* get_deleter (const shared_ptr&lt;T&gt;&amp; sp) noexcept;\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const shared_ptr&lt;T&gt;&amp; sp)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class D, class T&gt;\t\nD* get_deleter (const shared_ptr&lt;T&gt;&amp; sp) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">get_deleter</Data></Cell>
    <Cell><Data ss:Type="String">Get deleter from shared_ptr (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(sp)</Data></Cell>
    <Cell><Data ss:Type="String">A shared_ptr object.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">const_pointer_cast(const shared_ptr&lt;T&gt;&amp; sp)Param: (A shared_pointer.)\t\nDesc: Const cast of shared_ptr (function template)\t\nProto: template &lt;class T, class U&gt;\t\nshared_ptr&lt;T&gt; const_pointer_cast (const shared_ptr&lt;U&gt;&amp; sp) noexcept;\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const shared_ptr&lt;T&gt;&amp; sp)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class U&gt;\t\nshared_ptr&lt;T&gt; const_pointer_cast (const shared_ptr&lt;U&gt;&amp; sp) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">const_pointer_cast</Data></Cell>
    <Cell><Data ss:Type="String">Const cast of shared_ptr (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(sp)</Data></Cell>
    <Cell><Data ss:Type="String">A shared_pointer.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">dynamic_pointer_cast(const shared_ptr&lt;T&gt;&amp; sp)Param: (A shared_ptr.)\t\nDesc: Dynamic cast of shared_ptr (function template)\t\nProto: template &lt;class T, class U&gt;\t\nshared_ptr&lt;T&gt; dynamic_pointer_cast (const shared_ptr&lt;U&gt;&amp; sp) noexcept;\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const shared_ptr&lt;T&gt;&amp; sp)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class U&gt;\t\nshared_ptr&lt;T&gt; dynamic_pointer_cast (const shared_ptr&lt;U&gt;&amp; sp) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">dynamic_pointer_cast</Data></Cell>
    <Cell><Data ss:Type="String">Dynamic cast of shared_ptr (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(sp)</Data></Cell>
    <Cell><Data ss:Type="String">A shared_ptr.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">static_pointer_cast(const shared_ptr&lt;T&gt;&amp; sp)Param: (A shared_pointer.)\t\nDesc: Static cast of shared_ptr (function template)\t\nProto: template &lt;class T, class U&gt;\t\nshared_ptr&lt;T&gt; static_pointer_cast (const shared_ptr&lt;U&gt;&amp; sp) noexcept;\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const shared_ptr&lt;T&gt;&amp; sp)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T, class U&gt;\t\nshared_ptr&lt;T&gt; static_pointer_cast (const shared_ptr&lt;U&gt;&amp; sp) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">static_pointer_cast</Data></Cell>
    <Cell><Data ss:Type="String">Static cast of shared_ptr (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(sp)</Data></Cell>
    <Cell><Data ss:Type="String">A shared_pointer.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">stoi(const string&amp; str, size_t* idx = 0, int base = 10)Param: (String object with the representation of an integral number.)\t\nDesc: Convert string to integer (function template)\t\nProto: int stoi (const string&amp; str, size_t* idx = 0, int base = 10);int stoi (const wstring&amp; str, size_t* idx = 0, int base = 10);\t\n[cpp11] [&lt;string&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const string&amp; str, size_t* idx = 0, int base = 10)</Data></Cell>
    <Cell><Data ss:Type="String">int stoi (const string&amp; str, size_t* idx = 0, int base = 10);int stoi (const wstring&amp; str, size_t* idx = 0, int base = 10);</Data></Cell>
    <Cell><Data ss:Type="String">stoi</Data></Cell>
    <Cell><Data ss:Type="String">Convert string to integer (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">String object with the representation of an integral number.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;string&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Strings</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">asctime(const struct tm * timeptr)Param: (Pointer to a tm structure that contains a calendar time broken down into its components (see struct tm).)\t\nDesc: Convert tm structure to string (function)\t\nProto: char* asctime (const struct tm * timeptr);\t\n[c90 c99 arm cpp98 cpp11] [&lt;ctime&gt; (time.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const struct tm * timeptr)</Data></Cell>
    <Cell><Data ss:Type="String">char* asctime (const struct tm * timeptr);</Data></Cell>
    <Cell><Data ss:Type="String">asctime</Data></Cell>
    <Cell><Data ss:Type="String">Convert tm structure to string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(timeptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a tm structure that contains a calendar time broken down into its components (see struct tm).</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ctime&gt; (time.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Time Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">put_time(const struct tm* tmb, const charT* fmt)Param: (Pointer to the object of type struct tm with the date and time information to format.)\t\nDesc: Put date and time (function)\t\nProto: template &lt;class charT&gt;\t\n/*unspecified*/ put_time (const struct tm* tmb, const charT* fmt);\t\n[cpp11] [&lt;iomanip&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const struct tm* tmb, const charT* fmt)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT&gt;\t\n/*unspecified*/ put_time (const struct tm* tmb, const charT* fmt);</Data></Cell>
    <Cell><Data ss:Type="String">put_time</Data></Cell>
    <Cell><Data ss:Type="String">Put date and time (function)</Data></Cell>
    <Cell><Data ss:Type="String">(tmb)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the object of type struct tm with the date and time information to format.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iomanip&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">IO Manipulators</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">minmax(const T&amp; a, const T&amp; b)Param: (Values to compare.)\t\nDesc: Return smallest and largest elements (function template)\t\nProto: template &lt;class T&gt; pair &lt;const T&amp;,const T&amp;&gt; minmax (const T&amp; a, const T&amp; b);\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const T&amp; a, const T&amp; b)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; pair &lt;const T&amp;,const T&amp;&gt; minmax (const T&amp; a, const T&amp; b);</Data></Cell>
    <Cell><Data ss:Type="String">minmax</Data></Cell>
    <Cell><Data ss:Type="String">Return smallest and largest elements (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(a, b)</Data></Cell>
    <Cell><Data ss:Type="String">Values to compare.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">rethrow_if_nested(const T&amp; e)Param: (An object or reference.)\t\nDesc: Rethrow if nested (function)\t\nProto: template &lt;class T&gt;\t\nvoid rethrow_if_nested (const T&amp; e);\t\n[cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const T&amp; e)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt;\t\nvoid rethrow_if_nested (const T&amp; e);</Data></Cell>
    <Cell><Data ss:Type="String">rethrow_if_nested</Data></Cell>
    <Cell><Data ss:Type="String">Rethrow if nested (function)</Data></Cell>
    <Cell><Data ss:Type="String">(e)</Data></Cell>
    <Cell><Data ss:Type="String">An object or reference.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">polar(const T&amp; rho, const T&amp; theta = 0)Param: (Magnitude (modulus) of the complex number.)\t\nDesc: Complex from polar components (function template)\t\nProto: template&lt;class T&gt; complex&lt;T&gt; polar (const T&amp; rho, const T&amp; theta = 0);\t\n[cpp98 cpp11] [&lt;complex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const T&amp; rho, const T&amp; theta = 0)</Data></Cell>
    <Cell><Data ss:Type="String">template&lt;class T&gt; complex&lt;T&gt; polar (const T&amp; rho, const T&amp; theta = 0);</Data></Cell>
    <Cell><Data ss:Type="String">polar</Data></Cell>
    <Cell><Data ss:Type="String">Complex from polar components (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(rho)</Data></Cell>
    <Cell><Data ss:Type="String">Magnitude (modulus) of the complex number.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;complex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Complex numbers library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">time_point_cast(const time_point&lt;Clock,Duration&gt;&amp; tp)Param: (A time_point object.)\t\nDesc: Time_point cast (function template)\t\nProto: template &lt;class ToDuration, class Clock, class Duration&gt;\t\ntime_point&lt;Clock,ToDuration&gt; time_point_cast (const time_point&lt;Clock,Duration&gt;&amp; tp);\t\n[cpp11] [&lt;chrono&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(const time_point&lt;Clock,Duration&gt;&amp; tp)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ToDuration, class Clock, class Duration&gt;\t\ntime_point&lt;Clock,ToDuration&gt; time_point_cast (const time_point&lt;Clock,Duration&gt;&amp; tp);</Data></Cell>
    <Cell><Data ss:Type="String">time_point_cast</Data></Cell>
    <Cell><Data ss:Type="String">Time_point cast (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(tp)</Data></Cell>
    <Cell><Data ss:Type="String">A time_point object.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;chrono&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Time library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">gmtime(const time_t * timer)Param: (Pointer to an object of type time_t that contains a time value.)\t\nDesc: Convert time_t to tm as UTC time (function)\t\nProto: struct tm * gmtime (const time_t * timer);\t\n[c90 c99 arm cpp98 cpp11] [&lt;ctime&gt; (time.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const time_t * timer)</Data></Cell>
    <Cell><Data ss:Type="String">struct tm * gmtime (const time_t * timer);</Data></Cell>
    <Cell><Data ss:Type="String">gmtime</Data></Cell>
    <Cell><Data ss:Type="String">Convert time_t to tm as UTC time (function)</Data></Cell>
    <Cell><Data ss:Type="String">(timer)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an object of type time_t that contains a time value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ctime&gt; (time.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Time Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">localtime(const time_t * timer)Param: (Pointer to an object of type time_t that contains a time value.)\t\nDesc: Convert time_t to tm as local time (function)\t\nProto: struct tm * localtime (const time_t * timer);\t\n[c90 c99 arm cpp98 cpp11] [&lt;ctime&gt; (time.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const time_t * timer)</Data></Cell>
    <Cell><Data ss:Type="String">struct tm * localtime (const time_t * timer);</Data></Cell>
    <Cell><Data ss:Type="String">localtime</Data></Cell>
    <Cell><Data ss:Type="String">Convert time_t to tm as local time (function)</Data></Cell>
    <Cell><Data ss:Type="String">(timer)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an object of type time_t that contains a time value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ctime&gt; (time.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Time Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">bsearch(const void* key, const void* base,   size_t num, size_t size,   int (*compar)(const void*,const void*))Param: (Pointer to the object that serves as key for the search, type-casted to a )\t\nDesc: Binary search in array (function)\t\nProto: void* bsearch (const void* key, const void* base,   size_t num, size_t size,   int (*compar)(const void*,const void*));\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const void* key, const void* base,   size_t num, size_t size,   int (*compar)(const void*,const void*))</Data></Cell>
    <Cell><Data ss:Type="String">void* bsearch (const void* key, const void* base,   size_t num, size_t size,   int (*compar)(const void*,const void*));</Data></Cell>
    <Cell><Data ss:Type="String">bsearch</Data></Cell>
    <Cell><Data ss:Type="String">Binary search in array (function)</Data></Cell>
    <Cell><Data ss:Type="String">(key)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the object that serves as key for the search, type-casted to a </Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vwprintf(const wchar_t* format, va_list arg)Param: (C wide string that contains a format string that follows the same specifications as format in printf (see printf for details).)\t\nDesc: Print formatted data from variable argument list to stdout (function)\t\nProto: int vwprintf (const wchar_t* format, va_list arg);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* format, va_list arg)</Data></Cell>
    <Cell><Data ss:Type="String">int vwprintf (const wchar_t* format, va_list arg);</Data></Cell>
    <Cell><Data ss:Type="String">vwprintf</Data></Cell>
    <Cell><Data ss:Type="String">Print formatted data from variable argument list to stdout (function)</Data></Cell>
    <Cell><Data ss:Type="String">(format)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string that contains a format string that follows the same specifications as format in printf (see printf for details).</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wmemchr(const wchar_t* ptr, wchar_t wc, size_t num)wchar_t* wmemchr (wchar_t* ptr, wchar_t wc, size_t num)Param: (Pointer to the array of wchar_t elements to be searched.)\t\nDesc: Locate character in block of wide characters (function)\t\nProto: const wchar_t* wmemchr (const wchar_t* ptr, wchar_t wc, size_t num);wchar_t* wmemchr (wchar_t* ptr, wchar_t wc, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* ptr, wchar_t wc, size_t num)wchar_t* wmemchr (wchar_t* ptr, wchar_t wc, size_t num)</Data></Cell>
    <Cell><Data ss:Type="String">const wchar_t* wmemchr (const wchar_t* ptr, wchar_t wc, size_t num);wchar_t* wmemchr (wchar_t* ptr, wchar_t wc, size_t num);</Data></Cell>
    <Cell><Data ss:Type="String">wmemchr</Data></Cell>
    <Cell><Data ss:Type="String">Locate character in block of wide characters (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the array of wchar_t elements to be searched.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wmemcmp(const wchar_t* ptr1, const wchar_t* ptr2, size_t num)Param: (Pointer to block of elements of type wchar_t.)\t\nDesc: Compare two blocks of wide characters (function)\t\nProto: int wmemcmp (const wchar_t* ptr1, const wchar_t* ptr2, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* ptr1, const wchar_t* ptr2, size_t num)</Data></Cell>
    <Cell><Data ss:Type="String">int wmemcmp (const wchar_t* ptr1, const wchar_t* ptr2, size_t num);</Data></Cell>
    <Cell><Data ss:Type="String">wmemcmp</Data></Cell>
    <Cell><Data ss:Type="String">Compare two blocks of wide characters (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr1)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to block of elements of type wchar_t.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcstod(const wchar_t* str, wchar_t** endptr)Param: (C wide string beginning with the representation of a floating-point number.)\t\nDesc: Convert wide string to double (function)\t\nProto: double wcstod (const wchar_t* str, wchar_t** endptr);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* str, wchar_t** endptr)</Data></Cell>
    <Cell><Data ss:Type="String">double wcstod (const wchar_t* str, wchar_t** endptr);</Data></Cell>
    <Cell><Data ss:Type="String">wcstod</Data></Cell>
    <Cell><Data ss:Type="String">Convert wide string to double (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string beginning with the representation of a floating-point number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcstof(const wchar_t* str, wchar_t** endptr)Param: (C wide string beginning with the representation of a floating-point number.)\t\nDesc: Convert wide string to float (function)\t\nProto: float wcstof (const wchar_t* str, wchar_t** endptr);\t\n[c99 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* str, wchar_t** endptr)</Data></Cell>
    <Cell><Data ss:Type="String">float wcstof (const wchar_t* str, wchar_t** endptr);</Data></Cell>
    <Cell><Data ss:Type="String">wcstof</Data></Cell>
    <Cell><Data ss:Type="String">Convert wide string to float (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string beginning with the representation of a floating-point number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcstold(const wchar_t* str, wchar_t** endptr)Param: (C wide string beginning with the representation of a floating-point number.)\t\nDesc: Convert wide string to long double (function)\t\nProto: long double wcstold (const wchar_t* str, wchar_t** endptr);\t\n[c99 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* str, wchar_t** endptr)</Data></Cell>
    <Cell><Data ss:Type="String">long double wcstold (const wchar_t* str, wchar_t** endptr);</Data></Cell>
    <Cell><Data ss:Type="String">wcstold</Data></Cell>
    <Cell><Data ss:Type="String">Convert wide string to long double (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string beginning with the representation of a floating-point number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcstol(const wchar_t* str, wchar_t** endptr, int base)Param: (C wide string beginning with the representation of an integral number.)\t\nDesc: Convert wide string to long integer (function)\t\nProto: long int wcstol (const wchar_t* str, wchar_t** endptr, int base);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* str, wchar_t** endptr, int base)</Data></Cell>
    <Cell><Data ss:Type="String">long int wcstol (const wchar_t* str, wchar_t** endptr, int base);</Data></Cell>
    <Cell><Data ss:Type="String">wcstol</Data></Cell>
    <Cell><Data ss:Type="String">Convert wide string to long integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string beginning with the representation of an integral number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcstoll(const wchar_t* str, wchar_t** endptr, int base)Param: (C wide string beginning with the representation of an integral number.)\t\nDesc: Convert wide string to long long integer (function)\t\nProto: long long int strtoll (const wchar_t* str, wchar_t** endptr, int base);\t\n[c99 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* str, wchar_t** endptr, int base)</Data></Cell>
    <Cell><Data ss:Type="String">long long int strtoll (const wchar_t* str, wchar_t** endptr, int base);</Data></Cell>
    <Cell><Data ss:Type="String">wcstoll</Data></Cell>
    <Cell><Data ss:Type="String">Convert wide string to long long integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string beginning with the representation of an integral number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcstoul(const wchar_t* str, wchar_t** endptr, int base)Param: (C wide string containing the representation of an integral number.)\t\nDesc: Convert wide string to unsigned long integer (function)\t\nProto: unsigned long int wcstoul (const wchar_t* str, wchar_t** endptr, int base);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* str, wchar_t** endptr, int base)</Data></Cell>
    <Cell><Data ss:Type="String">unsigned long int wcstoul (const wchar_t* str, wchar_t** endptr, int base);</Data></Cell>
    <Cell><Data ss:Type="String">wcstoul</Data></Cell>
    <Cell><Data ss:Type="String">Convert wide string to unsigned long integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string containing the representation of an integral number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcstoull(const wchar_t* str, wchar_t** endptr, int base)Param: (C wide string beginning with the representation of an integral number.)\t\nDesc: Convert wide string to unsigned long long integer (function)\t\nProto: unsigned long long int wcstoull (const wchar_t* str, wchar_t** endptr, int base);\t\n[c99 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* str, wchar_t** endptr, int base)</Data></Cell>
    <Cell><Data ss:Type="String">unsigned long long int wcstoull (const wchar_t* str, wchar_t** endptr, int base);</Data></Cell>
    <Cell><Data ss:Type="String">wcstoull</Data></Cell>
    <Cell><Data ss:Type="String">Convert wide string to unsigned long long integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string beginning with the representation of an integral number.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcslen(const wchar_t* wcs)Param: (C wide string.)\t\nDesc: Get wide string length (function)\t\nProto: size_t wcslen (const wchar_t* wcs);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* wcs)</Data></Cell>
    <Cell><Data ss:Type="String">size_t wcslen (const wchar_t* wcs);</Data></Cell>
    <Cell><Data ss:Type="String">wcslen</Data></Cell>
    <Cell><Data ss:Type="String">Get wide string length (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wcs)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcscmp(const wchar_t* wcs1, const wchar_t* wcs2)Param: (C wide string to be compared.)\t\nDesc: Compare two strings (function)\t\nProto: int wcscmp (const wchar_t* wcs1, const wchar_t* wcs2);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* wcs1, const wchar_t* wcs2)</Data></Cell>
    <Cell><Data ss:Type="String">int wcscmp (const wchar_t* wcs1, const wchar_t* wcs2);</Data></Cell>
    <Cell><Data ss:Type="String">wcscmp</Data></Cell>
    <Cell><Data ss:Type="String">Compare two strings (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wcs1)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcscoll(const wchar_t* wcs1, const wchar_t* wcs2)Param: (C wide string to be compared.)\t\nDesc: Compare two wide strings using locale (function)\t\nProto: int wcscoll (const wchar_t* wcs1, const wchar_t* wcs2);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* wcs1, const wchar_t* wcs2)</Data></Cell>
    <Cell><Data ss:Type="String">int wcscoll (const wchar_t* wcs1, const wchar_t* wcs2);</Data></Cell>
    <Cell><Data ss:Type="String">wcscoll</Data></Cell>
    <Cell><Data ss:Type="String">Compare two wide strings using locale (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wcs1)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcscspn(const wchar_t* wcs1, const wchar_t* wcs2)Param: (C wide string to be scanned.)\t\nDesc: Get span until character in wide string (function)\t\nProto: size_t wcscspn (const wchar_t* wcs1, const wchar_t* wcs2);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* wcs1, const wchar_t* wcs2)</Data></Cell>
    <Cell><Data ss:Type="String">size_t wcscspn (const wchar_t* wcs1, const wchar_t* wcs2);</Data></Cell>
    <Cell><Data ss:Type="String">wcscspn</Data></Cell>
    <Cell><Data ss:Type="String">Get span until character in wide string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wcs1)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string to be scanned.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcsspn(const wchar_t* wcs1, const wchar_t* wcs2)Param: (C wide string to be scanned.)\t\nDesc: Get span of character set in wide string (function)\t\nProto: size_t wcsspn (const wchar_t* wcs1, const wchar_t* wcs2);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* wcs1, const wchar_t* wcs2)</Data></Cell>
    <Cell><Data ss:Type="String">size_t wcsspn (const wchar_t* wcs1, const wchar_t* wcs2);</Data></Cell>
    <Cell><Data ss:Type="String">wcsspn</Data></Cell>
    <Cell><Data ss:Type="String">Get span of character set in wide string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wcs1)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string to be scanned.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcspbrk(const wchar_t* wcs1, const wchar_t* wcs2)Param: (C wide string to be scanned.)\t\nDesc: Locate characters in wide string (function)\t\nProto: const wchar_t* wcspbrk (const wchar_t* wcs1, const wchar_t* wcs2);wchar_t* wcspbrk (wchar_t* wcs1, const wchar_t* wcs2);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* wcs1, const wchar_t* wcs2)</Data></Cell>
    <Cell><Data ss:Type="String">const wchar_t* wcspbrk (const wchar_t* wcs1, const wchar_t* wcs2);wchar_t* wcspbrk (wchar_t* wcs1, const wchar_t* wcs2);</Data></Cell>
    <Cell><Data ss:Type="String">wcspbrk</Data></Cell>
    <Cell><Data ss:Type="String">Locate characters in wide string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wcs1)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string to be scanned.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcsstr(const wchar_t* wcs1, const wchar_t* wcs2)Param: (C wide string to be scanned.)\t\nDesc: Locate substring of wide string (function)\t\nProto: const wchar_t* wcsstr (const wchar_t* wcs1, const wchar_t* wcs2);wchar_t* wcsstr (wchar_t* wcs1, const wchar_t* wcs2);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* wcs1, const wchar_t* wcs2)</Data></Cell>
    <Cell><Data ss:Type="String">const wchar_t* wcsstr (const wchar_t* wcs1, const wchar_t* wcs2);wchar_t* wcsstr (wchar_t* wcs1, const wchar_t* wcs2);</Data></Cell>
    <Cell><Data ss:Type="String">wcsstr</Data></Cell>
    <Cell><Data ss:Type="String">Locate substring of wide string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wcs1)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string to be scanned.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcsncmp(const wchar_t* wcs1, const wchar_t* wcs2, size_t num)Param: (C wide string to be compared.)\t\nDesc: Compare characters of two wide strings (function)\t\nProto: int wcsncmp (const wchar_t* wcs1, const wchar_t* wcs2, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* wcs1, const wchar_t* wcs2, size_t num)</Data></Cell>
    <Cell><Data ss:Type="String">int wcsncmp (const wchar_t* wcs1, const wchar_t* wcs2, size_t num);</Data></Cell>
    <Cell><Data ss:Type="String">wcsncmp</Data></Cell>
    <Cell><Data ss:Type="String">Compare characters of two wide strings (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wcs1)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string to be compared.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">swscanf(const wchar_t* ws, const wchar_t* format, ...)Param: (C wide string that the function processes as its source to retrieve the data.)\t\nDesc: Read formatted data from string (function)\t\nProto: int swscanf (const wchar_t* ws, const wchar_t* format, ...);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* ws, const wchar_t* format, ...)</Data></Cell>
    <Cell><Data ss:Type="String">int swscanf (const wchar_t* ws, const wchar_t* format, ...);</Data></Cell>
    <Cell><Data ss:Type="String">swscanf</Data></Cell>
    <Cell><Data ss:Type="String">Read formatted data from string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ws)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string that the function processes as its source to retrieve the data.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vswscanf(const wchar_t* ws, const wchar_t* format, va_list arg)Param: (C wide string that the function processes as its source to retrieve the data.)\t\nDesc: Read formatted data from wide string into variable argument list (function)\t\nProto: int vswscanf (const wchar_t* ws, const wchar_t* format, va_list arg);\t\n[c99 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* ws, const wchar_t* format, va_list arg)</Data></Cell>
    <Cell><Data ss:Type="String">int vswscanf (const wchar_t* ws, const wchar_t* format, va_list arg);</Data></Cell>
    <Cell><Data ss:Type="String">vswscanf</Data></Cell>
    <Cell><Data ss:Type="String">Read formatted data from wide string into variable argument list (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ws)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string that the function processes as its source to retrieve the data.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fputws(const wchar_t* ws, FILE* stream)Param: (C wide string with the content to write to the stream.)\t\nDesc: Write wide string to stream (function)\t\nProto: int fputws (const wchar_t* ws, FILE* stream);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* ws, FILE* stream)</Data></Cell>
    <Cell><Data ss:Type="String">int fputws (const wchar_t* ws, FILE* stream);</Data></Cell>
    <Cell><Data ss:Type="String">fputws</Data></Cell>
    <Cell><Data ss:Type="String">Write wide string to stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ws)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string with the content to write to the stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcschr(const wchar_t* ws, wchar_t wc)Param: (C wide string.)\t\nDesc: Locate first occurrence of character in wide string (function)\t\nProto: const wchar_t* wcschr (const wchar_t* ws, wchar_t wc);wchar_t* wcschr (wchar_t* ws, wchar_t wc);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* ws, wchar_t wc)</Data></Cell>
    <Cell><Data ss:Type="String">const wchar_t* wcschr (const wchar_t* ws, wchar_t wc);wchar_t* wcschr (wchar_t* ws, wchar_t wc);</Data></Cell>
    <Cell><Data ss:Type="String">wcschr</Data></Cell>
    <Cell><Data ss:Type="String">Locate first occurrence of character in wide string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ws)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcsrchr(const wchar_t* ws, wchar_t wc)Param: (C wide string.)\t\nDesc: Locate last occurrence of character in wide string (function)\t\nProto: const wchar_t* wcsrchr (const wchar_t* ws, wchar_t wc);wchar_t* wcsrchr (wchar_t* ws, wchar_t wc);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(const wchar_t* ws, wchar_t wc)</Data></Cell>
    <Cell><Data ss:Type="String">const wchar_t* wcsrchr (const wchar_t* ws, wchar_t wc);wchar_t* wcsrchr (wchar_t* ws, wchar_t wc);</Data></Cell>
    <Cell><Data ss:Type="String">wcsrchr</Data></Cell>
    <Cell><Data ss:Type="String">Locate last occurrence of character in wide string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ws)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">begin(Container&amp; cont)Param: (An object of a class type for which member begin is defined.)\t\nDesc: Iterator to beginning (function template)\t\nProto: template &lt;class Container&gt; auto begin (Container&amp; cont) -&gt; decltype (cont.begin());template &lt;class Container&gt; auto begin (const Container&amp; cont) -&gt; decltype (cont.begin());\t\n[cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(Container&amp; cont)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Container&gt; auto begin (Container&amp; cont) -&gt; decltype (cont.begin());template &lt;class Container&gt; auto begin (const Container&amp; cont) -&gt; decltype (cont.begin());</Data></Cell>
    <Cell><Data ss:Type="String">begin</Data></Cell>
    <Cell><Data ss:Type="String">Iterator to beginning (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(cont)</Data></Cell>
    <Cell><Data ss:Type="String">An object of a class type for which member begin is defined.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">back_inserter(Container&amp; x)Param: (Container on which the iterator will insert new elements.)\t\nDesc: Construct back insert iterator (function template)\t\nProto: template &lt;class Container&gt;\t\nback_insert_iterator&lt;Container&gt; back_inserter (Container&amp; x);\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(Container&amp; x)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Container&gt;\t\nback_insert_iterator&lt;Container&gt; back_inserter (Container&amp; x);</Data></Cell>
    <Cell><Data ss:Type="String">back_inserter</Data></Cell>
    <Cell><Data ss:Type="String">Construct back insert iterator (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Container on which the iterator will insert new elements.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">front_inserter(Container&amp; x)Param: (Container on which the iterator will insert new elements.)\t\nDesc: Constructs front insert iterator (function template)\t\nProto: template &lt;class Container&gt;\t\nfront_insert_iterator&lt;Container&gt; front_inserter (Container&amp; x);\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(Container&amp; x)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Container&gt;\t\nfront_insert_iterator&lt;Container&gt; front_inserter (Container&amp; x);</Data></Cell>
    <Cell><Data ss:Type="String">front_inserter</Data></Cell>
    <Cell><Data ss:Type="String">Constructs front insert iterator (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Container on which the iterator will insert new elements.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">pow(double base, double exponent)Param: (Base value.)\t\nDesc: Raise to power (function)\t\nProto: double pow (double base, double exponent);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double base, double exponent)</Data></Cell>
    <Cell><Data ss:Type="String">double pow (double base, double exponent);</Data></Cell>
    <Cell><Data ss:Type="String">pow</Data></Cell>
    <Cell><Data ss:Type="String">Raise to power (function)</Data></Cell>
    <Cell><Data ss:Type="String">(base)</Data></Cell>
    <Cell><Data ss:Type="String">Base value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fmod(double numer, double denom)Param: (Value of the quotient numerator.)\t\nDesc: Compute remainder of division (function)\t\nProto: double fmod (double numer, double denom);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double numer, double denom)</Data></Cell>
    <Cell><Data ss:Type="String">double fmod (double numer, double denom);</Data></Cell>
    <Cell><Data ss:Type="String">fmod</Data></Cell>
    <Cell><Data ss:Type="String">Compute remainder of division (function)</Data></Cell>
    <Cell><Data ss:Type="String">(numer)</Data></Cell>
    <Cell><Data ss:Type="String">Value of the quotient numerator.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remainder(double numer, double denom)Param: (Value of the quotient numerator.)\t\nDesc: Compute remainder (IEC 60559) (function)\t\nProto: double remainder (double numer, double denom); float remainderf (float numer , float denom);long double remainderl (long double numer, long double denom);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double numer, double denom)</Data></Cell>
    <Cell><Data ss:Type="String">double remainder (double numer, double denom); float remainderf (float numer , float denom);long double remainderl (long double numer, long double denom);</Data></Cell>
    <Cell><Data ss:Type="String">remainder</Data></Cell>
    <Cell><Data ss:Type="String">Compute remainder (IEC 60559) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(numer)</Data></Cell>
    <Cell><Data ss:Type="String">Value of the quotient numerator.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remquo(double numer, double denom, int* quot)Param: (Floating point value with the quotient numerator.)\t\nDesc: Compute remainder and quotient (function)\t\nProto: double remquo (double numer, double denom, int* quot); float remquof (float numer , float denom , int* quot);long double remquol (long double numer, long double denom, int* quot);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double numer, double denom, int* quot)</Data></Cell>
    <Cell><Data ss:Type="String">double remquo (double numer, double denom, int* quot); float remquof (float numer , float denom , int* quot);long double remquol (long double numer, long double denom, int* quot);</Data></Cell>
    <Cell><Data ss:Type="String">remquo</Data></Cell>
    <Cell><Data ss:Type="String">Compute remainder and quotient (function)</Data></Cell>
    <Cell><Data ss:Type="String">(numer)</Data></Cell>
    <Cell><Data ss:Type="String">Floating point value with the quotient numerator.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">acos(double x)Param: (Value whose arc cosine is computed, in the interval [-1,+1].)\t\nDesc: Compute arc cosine (function)\t\nProto: double acos (double x);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double acos (double x);</Data></Cell>
    <Cell><Data ss:Type="String">acos</Data></Cell>
    <Cell><Data ss:Type="String">Compute arc cosine (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose arc cosine is computed, in the interval [-1,+1].</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">asin(double x)Param: (Value whose arc sine is computed, in the interval [-1,+1].)\t\nDesc: Compute arc sine (function)\t\nProto: double asin(double x);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double asin(double x);</Data></Cell>
    <Cell><Data ss:Type="String">asin</Data></Cell>
    <Cell><Data ss:Type="String">Compute arc sine (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose arc sine is computed, in the interval [-1,+1].</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atan(double x)Param: (Value whose arc tangent is computed.)\t\nDesc: Compute arc tangent (function)\t\nProto: double atan(double x);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double atan(double x);</Data></Cell>
    <Cell><Data ss:Type="String">atan</Data></Cell>
    <Cell><Data ss:Type="String">Compute arc tangent (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose arc tangent is computed.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ceil(double x)Param: (Value to round up.)\t\nDesc: Round up value (function)\t\nProto: double ceil (double x);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double ceil (double x);</Data></Cell>
    <Cell><Data ss:Type="String">ceil</Data></Cell>
    <Cell><Data ss:Type="String">Round up value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value to round up.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">exp(double x)Param: (Value of the exponent.)\t\nDesc: Compute exponential function (function)\t\nProto: double exp (double x);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double exp (double x);</Data></Cell>
    <Cell><Data ss:Type="String">exp</Data></Cell>
    <Cell><Data ss:Type="String">Compute exponential function (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value of the exponent.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fabs(double x)Param: (Value whose absolute value is returned.)\t\nDesc: Compute absolute value (function)\t\nProto: double fabs (double x);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double fabs (double x);</Data></Cell>
    <Cell><Data ss:Type="String">fabs</Data></Cell>
    <Cell><Data ss:Type="String">Compute absolute value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose absolute value is returned.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">floor(double x)Param: (Value to round down.)\t\nDesc: Round down value (function)\t\nProto: double floor (double x);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double floor (double x);</Data></Cell>
    <Cell><Data ss:Type="String">floor</Data></Cell>
    <Cell><Data ss:Type="String">Round down value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value to round down.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">log10(double x)Param: (Value whose logarithm is calculated.)\t\nDesc: Compute common logarithm (function)\t\nProto: double log10 (double x);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double log10 (double x);</Data></Cell>
    <Cell><Data ss:Type="String">log10</Data></Cell>
    <Cell><Data ss:Type="String">Compute common logarithm (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose logarithm is calculated.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">sqrt(double x)Param: (Value whose square root is computed.)\t\nDesc: Compute square root (function)\t\nProto: double sqrt (double x);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double sqrt (double x);</Data></Cell>
    <Cell><Data ss:Type="String">sqrt</Data></Cell>
    <Cell><Data ss:Type="String">Compute square root (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose square root is computed.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">abs(double x)Param: (Value whose absolute value is returned.)\t\nDesc: Compute absolute value (function)\t\nProto: double abs (double x); float abs (float x);long double abs (long double x);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double abs (double x); float abs (float x);long double abs (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">abs</Data></Cell>
    <Cell><Data ss:Type="String">Compute absolute value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose absolute value is returned.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">acosh(double x)Param: (Value whose arc hyperbolic cosine is computed.)\t\nDesc: Compute arc hyperbolic cosine (function)\t\nProto: double acosh (double x); float acoshf (float x);long double acoshl (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double acosh (double x); float acoshf (float x);long double acoshl (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">acosh</Data></Cell>
    <Cell><Data ss:Type="String">Compute arc hyperbolic cosine (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose arc hyperbolic cosine is computed.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">asinh(double x)Param: (Value whose arc hyperbolic sine is computed.)\t\nDesc: Compute arc hyperbolic sine (function)\t\nProto: double asinh (double x); float asinhf (float x);long double asinhl (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double asinh (double x); float asinhf (float x);long double asinhl (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">asinh</Data></Cell>
    <Cell><Data ss:Type="String">Compute arc hyperbolic sine (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose arc hyperbolic sine is computed.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atanh(double x)Param: (Value whose arc hyperbolic tangent is computed, in the interval [-1,+1].)\t\nDesc: Compute arc hyperbolic tangent (function)\t\nProto: double atanh (double x); float atanhf (float x);long double atanhl (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double atanh (double x); float atanhf (float x);long double atanhl (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">atanh</Data></Cell>
    <Cell><Data ss:Type="String">Compute arc hyperbolic tangent (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose arc hyperbolic tangent is computed, in the interval [-1,+1].</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">cbrt(double x)Param: (Value whose cubit root is computed.)\t\nDesc: Compute cubic root (function)\t\nProto: double cbrt (double x); float cbrtf (float x);long double cbrtl (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double cbrt (double x); float cbrtf (float x);long double cbrtl (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">cbrt</Data></Cell>
    <Cell><Data ss:Type="String">Compute cubic root (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose cubit root is computed.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">erfc(double x)Param: (Parameter for the complementary error function.)\t\nDesc: Compute complementary error function (function)\t\nProto: double erfc (double x); float erfcf (float x);long double erfcl (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double erfc (double x); float erfcf (float x);long double erfcl (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">erfc</Data></Cell>
    <Cell><Data ss:Type="String">Compute complementary error function (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Parameter for the complementary error function.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">erf(double x)Param: (Parameter for the error function.)\t\nDesc: Compute error function (function)\t\nProto: double erf (double x); float erff (float x);long double erfl (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double erf (double x); float erff (float x);long double erfl (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">erf</Data></Cell>
    <Cell><Data ss:Type="String">Compute error function (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Parameter for the error function.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">exp2(double x)Param: (Value of the exponent.)\t\nDesc: Compute binary exponential function (function)\t\nProto: double exp2 (double x); float exp2f (float x);long double exp2l (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double exp2 (double x); float exp2f (float x);long double exp2l (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">exp2</Data></Cell>
    <Cell><Data ss:Type="String">Compute binary exponential function (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value of the exponent.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">expm1(double x)Param: (Value of the exponent.)\t\nDesc: Compute exponential minus one (function)\t\nProto: double expm1 (double x); float expm1f (float x);long double expm1l (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double expm1 (double x); float expm1f (float x);long double expm1l (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">expm1</Data></Cell>
    <Cell><Data ss:Type="String">Compute exponential minus one (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value of the exponent.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">lgamma(double x)Param: (Parameter for the log-gamma function.)\t\nDesc: Compute log-gamma function (function)\t\nProto: double lgamma (double x); float lgammaf (float x);long double lgammal (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double lgamma (double x); float lgammaf (float x);long double lgammal (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">lgamma</Data></Cell>
    <Cell><Data ss:Type="String">Compute log-gamma function (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Parameter for the log-gamma function.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">log1p(double x)Param: (Value whose logarithm is calculated.)\t\nDesc: Compute logarithm plus one (function)\t\nProto: double log1p (double x); float log1pf (float x);long double log1pl (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double log1p (double x); float log1pf (float x);long double log1pl (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">log1p</Data></Cell>
    <Cell><Data ss:Type="String">Compute logarithm plus one (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose logarithm is calculated.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">log2(double x)Param: (Value whose logarithm is calculated.)\t\nDesc: Compute binary logarithm (function)\t\nProto: double log2 (double x); float log2f (float x);long double log2l (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double log2 (double x); float log2f (float x);long double log2l (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">log2</Data></Cell>
    <Cell><Data ss:Type="String">Compute binary logarithm (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose logarithm is calculated.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">nearbyint(double x)Param: (Value to round.)\t\nDesc: Round to nearby integral value (function)\t\nProto: double nearbyint (double x); float nearbyintf (float x);long double nearbyintl (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double nearbyint (double x); float nearbyintf (float x);long double nearbyintl (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">nearbyint</Data></Cell>
    <Cell><Data ss:Type="String">Round to nearby integral value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value to round.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">tgamma(double x)Param: (Parameter for the gamma function.)\t\nDesc: Compute gamma function (function)\t\nProto: double tgamma (double x); float tgammaf ( float x);long double tgammal (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double tgamma (double x); float tgammaf ( float x);long double tgammal (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">tgamma</Data></Cell>
    <Cell><Data ss:Type="String">Compute gamma function (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Parameter for the gamma function.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">trunc(double x)Param: (Value to truncate.)\t\nDesc: Truncate value (function)\t\nProto: double trunc (double x); float truncf ( float x);long double truncl (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double trunc (double x); float truncf ( float x);long double truncl (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">trunc</Data></Cell>
    <Cell><Data ss:Type="String">Truncate value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value to truncate.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ilogb(double x)Param: (Value whose ilogb is returned.)\t\nDesc: Integer binary logarithm (function)\t\nProto: int ilogb (double x);int ilogbf (float x);int ilogbl (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">int ilogb (double x);int ilogbf (float x);int ilogbl (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">ilogb</Data></Cell>
    <Cell><Data ss:Type="String">Integer binary logarithm (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value whose ilogb is returned.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">llrint(double x)Param: (Value to round.)\t\nDesc: Round and cast to long long integer (function)\t\nProto: long long int llrint (double x);long long int llrintf (float x);long long int llrintl (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">long long int llrint (double x);long long int llrintf (float x);long long int llrintl (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">llrint</Data></Cell>
    <Cell><Data ss:Type="String">Round and cast to long long integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value to round.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">llround(double x)Param: (Value to round.)\t\nDesc: Round to nearest and cast to long long integer (function)\t\nProto: long long int llround (double x);long long int llroundf (float x);long long int llroundl (long double x);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">long long int llround (double x);long long int llroundf (float x);long long int llroundl (long double x);</Data></Cell>
    <Cell><Data ss:Type="String">llround</Data></Cell>
    <Cell><Data ss:Type="String">Round to nearest and cast to long long integer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value to round.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">copysign(double x)Param: (Value with the magnitude of the resulting value.)\t\nDesc: Copy sign (function)\t\nProto: double copysign (double x, double y); float copysignf (float x , float y);long double copysignl (long double x, long double y);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double copysign (double x, double y); float copysignf (float x , float y);long double copysignl (long double x, long double y);</Data></Cell>
    <Cell><Data ss:Type="String">copysign</Data></Cell>
    <Cell><Data ss:Type="String">Copy sign (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value with the magnitude of the resulting value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fdim(double x)Param: (Values whose difference is calculated.)\t\nDesc: Positive difference (function)\t\nProto: double fdim (double x, double y); float fdimf (float x , float y);long double fdiml (long double x, long double y);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double fdim (double x, double y); float fdimf (float x , float y);long double fdiml (long double x, long double y);</Data></Cell>
    <Cell><Data ss:Type="String">fdim</Data></Cell>
    <Cell><Data ss:Type="String">Positive difference (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x, y)</Data></Cell>
    <Cell><Data ss:Type="String">Values whose difference is calculated.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fmax(double x)Param: (Values among which the function selects a maximum.)\t\nDesc: Maximum value (function)\t\nProto: double fmax (double x, double y); float fmaxf (float x , float y);long double fmaxl (long double x, long double y);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double fmax (double x, double y); float fmaxf (float x , float y);long double fmaxl (long double x, long double y);</Data></Cell>
    <Cell><Data ss:Type="String">fmax</Data></Cell>
    <Cell><Data ss:Type="String">Maximum value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x, y)</Data></Cell>
    <Cell><Data ss:Type="String">Values among which the function selects a maximum.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fmin(double x)Param: (Values among which the function selects a minimum.)\t\nDesc: Minimum value (function)\t\nProto: double fmin (double x, double y); float fminf (float x , float y);long double fminl (long double x, long double y);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double fmin (double x, double y); float fminf (float x , float y);long double fminl (long double x, long double y);</Data></Cell>
    <Cell><Data ss:Type="String">fmin</Data></Cell>
    <Cell><Data ss:Type="String">Minimum value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x, y)</Data></Cell>
    <Cell><Data ss:Type="String">Values among which the function selects a minimum.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">hypot(double x)Param: (Floating point values corresponding to the legs of a right-angled triangle for which the hypotenuse is computed.)\t\nDesc: Compute hypotenuse (function)\t\nProto: double hypot (double x, double y); float hypotf (float x , float y);long double hypotl (long double x, long double y);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double hypot (double x, double y); float hypotf (float x , float y);long double hypotl (long double x, long double y);</Data></Cell>
    <Cell><Data ss:Type="String">hypot</Data></Cell>
    <Cell><Data ss:Type="String">Compute hypotenuse (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x, y)</Data></Cell>
    <Cell><Data ss:Type="String">Floating point values corresponding to the legs of a right-angled triangle for which the hypotenuse is computed.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">nextafter(double x)Param: (Base value.)\t\nDesc: Next representable value (function)\t\nProto: double nextafter (double x, double y); float nextafterf (float x , float y);long double nextafterl (long double x, long double y);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double nextafter (double x, double y); float nextafterf (float x , float y);long double nextafterl (long double x, long double y);</Data></Cell>
    <Cell><Data ss:Type="String">nextafter</Data></Cell>
    <Cell><Data ss:Type="String">Next representable value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Base value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fma(double x)Param: (Values to be multiplied.)\t\nDesc: Multiply-add (function)\t\nProto: double fma (double x, double y, double z); float fmaf (float x , float y , float z);long double fmal (long double x, long double y, long double z);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double fma (double x, double y, double z); float fmaf (float x , float y , float z);long double fmal (long double x, long double y, long double z);</Data></Cell>
    <Cell><Data ss:Type="String">fma</Data></Cell>
    <Cell><Data ss:Type="String">Multiply-add (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x, y)</Data></Cell>
    <Cell><Data ss:Type="String">Values to be multiplied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">modf(double x)Param: (Floating point value to break into parts.)\t\nDesc: Break into fractional and integral parts (function)\t\nProto: double modf (double x, double* intpart);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double modf (double x, double* intpart);</Data></Cell>
    <Cell><Data ss:Type="String">modf</Data></Cell>
    <Cell><Data ss:Type="String">Break into fractional and integral parts (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Floating point value to break into parts.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ldexp(double x)Param: (Floating point value representing the significand.)\t\nDesc: Generate value from significand and exponent (function)\t\nProto: double ldexp (double x, int exp);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double ldexp (double x, int exp);</Data></Cell>
    <Cell><Data ss:Type="String">ldexp</Data></Cell>
    <Cell><Data ss:Type="String">Generate value from significand and exponent (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Floating point value representing the significand.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">scalbn(double x)Param: (Value representing the significand.)\t\nDesc: Scale significand using floating-point base exponent (function)\t\nProto: double scalbn (double x, int n); float scalbnf (float x , int n);long double scalbnl (long double x, int n);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double scalbn (double x, int n); float scalbnf (float x , int n);long double scalbnl (long double x, int n);</Data></Cell>
    <Cell><Data ss:Type="String">scalbn</Data></Cell>
    <Cell><Data ss:Type="String">Scale significand using floating-point base exponent (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value representing the significand.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">frexp(double x)Param: (Value to be decomposed.)\t\nDesc: Get significand and exponent (function)\t\nProto: double frexp (double x, int* exp);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double frexp (double x, int* exp);</Data></Cell>
    <Cell><Data ss:Type="String">frexp</Data></Cell>
    <Cell><Data ss:Type="String">Get significand and exponent (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Value to be decomposed.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">nexttoward(double x)Param: (Base value.)\t\nDesc: Next representable value toward precise value (function)\t\nProto: double nexttoward (double x, long double y); float nexttowardf (float x , long double y);long double nexttowardl (long double x, long double y);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double nexttoward (double x, long double y); float nexttowardf (float x , long double y);long double nexttowardl (long double x, long double y);</Data></Cell>
    <Cell><Data ss:Type="String">nexttoward</Data></Cell>
    <Cell><Data ss:Type="String">Next representable value toward precise value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(x)</Data></Cell>
    <Cell><Data ss:Type="String">Base value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">scalbln(double x)Param: (significand.)\t\nDesc: Scale significand using floating-point base exponent (long) (function)\t\nProto: double scalbln (double x, long int n); float scalblnf (float x , long int n);long double scalblnl (long double x, long int n);\t\n[c99 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double x)</Data></Cell>
    <Cell><Data ss:Type="String">double scalbln (double x, long int n); float scalblnf (float x , long int n);long double scalblnl (long double x, long int n);</Data></Cell>
    <Cell><Data ss:Type="String">scalbln</Data></Cell>
    <Cell><Data ss:Type="String">Scale significand using floating-point base exponent (long) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(value)</Data></Cell>
    <Cell><Data ss:Type="String">significand.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atan2(double y, double x)Param: (Value representing the proportion of the y-coordinate.)\t\nDesc: Compute arc tangent with two parameters (function)\t\nProto: double atan2(double y, double x);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cmath&gt; (math.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(double y, double x)</Data></Cell>
    <Cell><Data ss:Type="String">double atan2(double y, double x);</Data></Cell>
    <Cell><Data ss:Type="String">atan2</Data></Cell>
    <Cell><Data ss:Type="String">Compute arc tangent with two parameters (function)</Data></Cell>
    <Cell><Data ss:Type="String">(y)</Data></Cell>
    <Cell><Data ss:Type="String">Value representing the proportion of the y-coordinate.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cmath&gt; (math.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C numerics library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">make_exception_ptr(E e)Param: (An object or reference.)\t\nDesc: Make exception_ptr (function template)\t\nProto: template &lt;class E&gt;\t\nexception_ptr make_exception_ptr (E e) noexcept;\t\n[cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(E e)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class E&gt;\t\nexception_ptr make_exception_ptr (E e) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">make_exception_ptr</Data></Cell>
    <Cell><Data ss:Type="String">Make exception_ptr (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(e)</Data></Cell>
    <Cell><Data ss:Type="String">An object or reference.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">make_error_code(errc e)Param: (An enum value of type errc (see errc).)\t\nDesc: Make error code (function)\t\nProto: error_code make_error_code (errc e) noexcept;\t\n[cpp11] [&lt;system_error&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(errc e)</Data></Cell>
    <Cell><Data ss:Type="String">error_code make_error_code (errc e) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">make_error_code</Data></Cell>
    <Cell><Data ss:Type="String">Make error code (function)</Data></Cell>
    <Cell><Data ss:Type="String">(e)</Data></Cell>
    <Cell><Data ss:Type="String">An enum value of type errc (see errc).</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;system_error&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">System errors</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">make_error_condition(errc e)Param: (An enum value of type errc (see errc).)\t\nDesc: Make error condition (function)\t\nProto: error_condition make_error_condition (errc e) noexcept;\t\n[cpp11] [&lt;system_error&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(errc e)</Data></Cell>
    <Cell><Data ss:Type="String">error_condition make_error_condition (errc e) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">make_error_condition</Data></Cell>
    <Cell><Data ss:Type="String">Make error condition (function)</Data></Cell>
    <Cell><Data ss:Type="String">(e)</Data></Cell>
    <Cell><Data ss:Type="String">An enum value of type errc (see errc).</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;system_error&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">System errors</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">rethrow_exception(exception_ptr p)Param: (An exception_ptr object pointing to an exception object.)\t\nDesc: Rethrow exception (function)\t\nProto: [[noreturn]] void rethrow_exception (exception_ptr p);\t\n[cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(exception_ptr p)</Data></Cell>
    <Cell><Data ss:Type="String">[[noreturn]] void rethrow_exception (exception_ptr p);</Data></Cell>
    <Cell><Data ss:Type="String">rethrow_exception</Data></Cell>
    <Cell><Data ss:Type="String">Rethrow exception (function)</Data></Cell>
    <Cell><Data ss:Type="String">(p)</Data></Cell>
    <Cell><Data ss:Type="String">An exception_ptr object pointing to an exception object.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fegetenv(fenv_t* envp)Param: (Pointer to a fenv_t object where the state of the floating-point environment is stored.)\t\nDesc: Get floating-point environment (function)\t\nProto: int fegetenv (fenv_t* envp);\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(fenv_t* envp)</Data></Cell>
    <Cell><Data ss:Type="String">int fegetenv (fenv_t* envp);</Data></Cell>
    <Cell><Data ss:Type="String">fegetenv</Data></Cell>
    <Cell><Data ss:Type="String">Get floating-point environment (function)</Data></Cell>
    <Cell><Data ss:Type="String">(envp)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a fenv_t object where the state of the floating-point environment is stored.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">feholdexcept(fenv_t* envp)Param: (Pointer to a fenv_t object where the state of the floating-point environment is stored.)\t\nDesc: Hold floating-point exceptions (function)\t\nProto: int feholdexcept (fenv_t* envp);\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(fenv_t* envp)</Data></Cell>
    <Cell><Data ss:Type="String">int feholdexcept (fenv_t* envp);</Data></Cell>
    <Cell><Data ss:Type="String">feholdexcept</Data></Cell>
    <Cell><Data ss:Type="String">Hold floating-point exceptions (function)</Data></Cell>
    <Cell><Data ss:Type="String">(envp)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a fenv_t object where the state of the floating-point environment is stored.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fegetexceptflag(fexcept_t* flagp, int excepts)Param: (Pointer to a fexcept_t object where the representation is stored.)\t\nDesc: Get floating-point exception flags (function)\t\nProto: int fegetexceptflag (fexcept_t* flagp, int excepts);\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(fexcept_t* flagp, int excepts)</Data></Cell>
    <Cell><Data ss:Type="String">int fegetexceptflag (fexcept_t* flagp, int excepts);</Data></Cell>
    <Cell><Data ss:Type="String">fegetexceptflag</Data></Cell>
    <Cell><Data ss:Type="String">Get floating-point exception flags (function)</Data></Cell>
    <Cell><Data ss:Type="String">(flagp)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a fexcept_t object where the representation is stored.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fgetwc(FILE * stream)Param: (Pointer to a FILE object that identifies an input stream.)\t\nDesc: Get wide character from stream (function)\t\nProto: wint_t fgetwc (FILE * stream);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(FILE * stream)</Data></Cell>
    <Cell><Data ss:Type="String">wint_t fgetwc (FILE * stream);</Data></Cell>
    <Cell><Data ss:Type="String">fgetwc</Data></Cell>
    <Cell><Data ss:Type="String">Get wide character from stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies an input stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fwprintf(FILE* stream, const wchar_t* format, ...)Param: (Pointer to a FILE object that identifies an output stream.)\t\nDesc: Write formatted data to stream (function)\t\nProto: int fwprintf (FILE* stream, const wchar_t* format, ...);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(FILE* stream, const wchar_t* format, ...)</Data></Cell>
    <Cell><Data ss:Type="String">int fwprintf (FILE* stream, const wchar_t* format, ...);</Data></Cell>
    <Cell><Data ss:Type="String">fwprintf</Data></Cell>
    <Cell><Data ss:Type="String">Write formatted data to stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies an output stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fwscanf(FILE* stream, const wchar_t* format, ...)Param: (Pointer to a FILE object that identifies the input stream to read data from.)\t\nDesc: Read formatted data from stream (function)\t\nProto: int fwscanf (FILE* stream, const wchar_t* format, ...);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(FILE* stream, const wchar_t* format, ...)</Data></Cell>
    <Cell><Data ss:Type="String">int fwscanf (FILE* stream, const wchar_t* format, ...);</Data></Cell>
    <Cell><Data ss:Type="String">fwscanf</Data></Cell>
    <Cell><Data ss:Type="String">Read formatted data from stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies the input stream to read data from.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vfwprintf(FILE* stream, const wchar_t* format, va_list arg)Param: (Pointer to a FILE object that identifies an output stream.)\t\nDesc: Write formatted data from variable argument list to stream (function)\t\nProto: int vfwprintf (FILE* stream, const wchar_t* format, va_list arg);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(FILE* stream, const wchar_t* format, va_list arg)</Data></Cell>
    <Cell><Data ss:Type="String">int vfwprintf (FILE* stream, const wchar_t* format, va_list arg);</Data></Cell>
    <Cell><Data ss:Type="String">vfwprintf</Data></Cell>
    <Cell><Data ss:Type="String">Write formatted data from variable argument list to stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies an output stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vfwscanf(FILE* stream, const wchar_t* format, va_list arg)Param: (Pointer to a FILE object that identifies an input stream.)\t\nDesc: Read formatted data from stream into variable argument list (function)\t\nProto: int vfwscanf (FILE* stream, const wchar_t* format, va_list arg);\t\n[c99 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(FILE* stream, const wchar_t* format, va_list arg)</Data></Cell>
    <Cell><Data ss:Type="String">int vfwscanf (FILE* stream, const wchar_t* format, va_list arg);</Data></Cell>
    <Cell><Data ss:Type="String">vfwscanf</Data></Cell>
    <Cell><Data ss:Type="String">Read formatted data from stream into variable argument list (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies an input stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fwide(FILE* stream, int mode)Param: (Pointer to a FILE object that identifies a stream.)\t\nDesc: Stream orientation (function)\t\nProto: int fwide (FILE* stream, int mode);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(FILE* stream, int mode)</Data></Cell>
    <Cell><Data ss:Type="String">int fwide (FILE* stream, int mode);</Data></Cell>
    <Cell><Data ss:Type="String">fwide</Data></Cell>
    <Cell><Data ss:Type="String">Stream orientation (function)</Data></Cell>
    <Cell><Data ss:Type="String">(stream)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a FILE object that identifies a stream.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">partition_point(ForwardIterator first, ForwardIterator last,  UnaryPredicate pred)Param: (Forward iterators to the initial and final positions of the partitioned sequence.)\t\nDesc: Get partition point (function template)\t\nProto: template &lt;class ForwardIterator, class UnaryPredicate&gt;\t\nForwardIterator partition_point (ForwardIterator first, ForwardIterator last,  UnaryPredicate pred);\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator first, ForwardIterator last,  UnaryPredicate pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator, class UnaryPredicate&gt;\t\nForwardIterator partition_point (ForwardIterator first, ForwardIterator last,  UnaryPredicate pred);</Data></Cell>
    <Cell><Data ss:Type="String">partition_point</Data></Cell>
    <Cell><Data ss:Type="String">Get partition point (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of the partitioned sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">replace(ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value)Param: (Forward iterators to the initial and final positions in a sequence of elements that support being compared and assigned a value of type T.)\t\nDesc: Replace value in range (function template)\t\nProto: template &lt;class ForwardIterator, class T&gt;\t\nvoid replace (ForwardIterator first, ForwardIterator last,   const T&amp; old_value, const T&amp; new_value);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator, class T&gt;\t\nvoid replace (ForwardIterator first, ForwardIterator last,   const T&amp; old_value, const T&amp; new_value);</Data></Cell>
    <Cell><Data ss:Type="String">replace</Data></Cell>
    <Cell><Data ss:Type="String">Replace value in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions in a sequence of elements that support being compared and assigned a value of type T.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">uninitialized_fill(ForwardIterator first, ForwardIterator last, const T&amp; x)Param: (Forward iterators to the initial and final positions in an uninitialized sequence.)\t\nDesc: Fill block of memory (function template)\t\nProto: template &lt;class ForwardIterator, class T&gt;\t\nvoid uninitialized_fill (ForwardIterator first, ForwardIterator last, const T&amp; x);\t\n[cpp98 cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator first, ForwardIterator last, const T&amp; x)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator, class T&gt;\t\nvoid uninitialized_fill (ForwardIterator first, ForwardIterator last, const T&amp; x);</Data></Cell>
    <Cell><Data ss:Type="String">uninitialized_fill</Data></Cell>
    <Cell><Data ss:Type="String">Fill block of memory (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions in an uninitialized sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">generate(ForwardIterator first, ForwardIterator last, Generator gen)Param: (Forward iterators to the initial and final positions in a sequence.)\t\nDesc: Generate values for range with function (function template)\t\nProto: template &lt;class ForwardIterator, class Generator&gt;\t\nvoid generate (ForwardIterator first, ForwardIterator last, Generator gen);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator first, ForwardIterator last, Generator gen)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator, class Generator&gt;\t\nvoid generate (ForwardIterator first, ForwardIterator last, Generator gen);</Data></Cell>
    <Cell><Data ss:Type="String">generate</Data></Cell>
    <Cell><Data ss:Type="String">Generate values for range with function (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iota(ForwardIterator first, ForwardIterator last, T val)Param: (Forward iterators to the initial and final positions of the sequence to be written.)\t\nDesc: Store increasing sequence (function template)\t\nProto: template &lt;class ForwardIterator, class T&gt;\t\nvoid iota (ForwardIterator first, ForwardIterator last, T val);\t\n[cpp11] [&lt;numeric&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator first, ForwardIterator last, T val)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator, class T&gt;\t\nvoid iota (ForwardIterator first, ForwardIterator last, T val);</Data></Cell>
    <Cell><Data ss:Type="String">iota</Data></Cell>
    <Cell><Data ss:Type="String">Store increasing sequence (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of the sequence to be written.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;numeric&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Generalized numeric operations</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">replace_if(ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T&amp; new_value )Param: (Forward iterators to the initial and final positions in a sequence of elements that support being assigned a value of type T.)\t\nDesc: Replace values in range (function template)\t\nProto: template &lt;class ForwardIterator, class UnaryPredicate, class T&gt;\t\nvoid replace_if (ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T&amp; new_value );\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T&amp; new_value )</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator, class UnaryPredicate, class T&gt;\t\nvoid replace_if (ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T&amp; new_value );</Data></Cell>
    <Cell><Data ss:Type="String">replace_if</Data></Cell>
    <Cell><Data ss:Type="String">Replace values in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions in a sequence of elements that support being assigned a value of type T.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remove_if(ForwardIterator first, ForwardIterator last,UnaryPredicate pred)Param: (Forward iterators to the initial and final positions in a sequence of move-assignable elements.)\t\nDesc: Remove elements from range (function template)\t\nProto: template &lt;class ForwardIterator, class UnaryPredicate&gt; ForwardIterator remove_if (ForwardIterator first, ForwardIterator last,UnaryPredicate pred);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator first, ForwardIterator last,UnaryPredicate pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator, class UnaryPredicate&gt; ForwardIterator remove_if (ForwardIterator first, ForwardIterator last,UnaryPredicate pred);</Data></Cell>
    <Cell><Data ss:Type="String">remove_if</Data></Cell>
    <Cell><Data ss:Type="String">Remove elements from range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions in a sequence of move-assignable elements.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last)Param: (Forward iterators to the initial and final positions of the sequence to be rotated left.)\t\nDesc: Rotate left the elements in range (function template)\t\nProto: template &lt;class ForwardIterator&gt; void rotate (ForwardIterator first, ForwardIterator middle, ForwardIterator last);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator first, ForwardIterator middle, ForwardIterator last)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator&gt; void rotate (ForwardIterator first, ForwardIterator middle, ForwardIterator last);</Data></Cell>
    <Cell><Data ss:Type="String">rotate</Data></Cell>
    <Cell><Data ss:Type="String">Rotate left the elements in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of the sequence to be rotated left.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">rotate_copy(ForwardIterator first, ForwardIterator middle,ForwardIterator last, OutputIterator result)Param: (Forward iterators to the initial and final positions of the range to be copy-rotated.)\t\nDesc: Copy range rotated left (function template)\t\nProto: template &lt;class ForwardIterator, class OutputIterator&gt;\t\nOutputIterator rotate_copy (ForwardIterator first, ForwardIterator middle,ForwardIterator last, OutputIterator result);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator first, ForwardIterator middle,ForwardIterator last, OutputIterator result)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator, class OutputIterator&gt;\t\nOutputIterator rotate_copy (ForwardIterator first, ForwardIterator middle,ForwardIterator last, OutputIterator result);</Data></Cell>
    <Cell><Data ss:Type="String">rotate_copy</Data></Cell>
    <Cell><Data ss:Type="String">Copy range rotated left (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of the range to be copy-rotated.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x)Param: (Forward iterator to the initial position in an uninitialized sequence of at least n elements.)\t\nDesc: Fill block of memory (function template)\t\nProto: template &lt;class ForwardIterator, class Size, class T&gt; void uninitialized_fill_n (ForwardIterator first, Size n, const T&amp; x);\t\n[cpp98 cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator first, Size n, const T&amp; x)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator, class Size, class T&gt; void uninitialized_fill_n (ForwardIterator first, Size n, const T&amp; x);</Data></Cell>
    <Cell><Data ss:Type="String">uninitialized_fill_n</Data></Cell>
    <Cell><Data ss:Type="String">Fill block of memory (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterator to the initial position in an uninitialized sequence of at least n elements.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iter_swap(ForwardIterator1 a, ForwardIterator2 b)Param: (Forward iterators to the objects to swap.)\t\nDesc: Exchange values of objects pointed to by two iterators (function template)\t\nProto: template &lt;class ForwardIterator1, class ForwardIterator2&gt;\t\nvoid iter_swap (ForwardIterator1 a, ForwardIterator2 b);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator1 a, ForwardIterator2 b)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator1, class ForwardIterator2&gt;\t\nvoid iter_swap (ForwardIterator1 a, ForwardIterator2 b);</Data></Cell>
    <Cell><Data ss:Type="String">iter_swap</Data></Cell>
    <Cell><Data ss:Type="String">Exchange values of objects pointed to by two iterators (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(a, b)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the objects to swap.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,   ForwardIterator2 first2, ForwardIterator2 last2)Param: (Forward iterators to the initial and final positions of the searched sequence.)\t\nDesc: Find element from set in range (function template)\t\nProto: template &lt;class ForwardIterator1, class ForwardIterator2&gt;  ForwardIterator1 find_first_of (ForwardIterator1 first1, ForwardIterator1 last1,   ForwardIterator2 first2, ForwardIterator2 last2);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator1 first1, ForwardIterator1 last1,   ForwardIterator2 first2, ForwardIterator2 last2)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator1, class ForwardIterator2&gt;  ForwardIterator1 find_first_of (ForwardIterator1 first1, ForwardIterator1 last1,   ForwardIterator2 first2, ForwardIterator2 last2);</Data></Cell>
    <Cell><Data ss:Type="String">find_first_of</Data></Cell>
    <Cell><Data ss:Type="String">Find element from set in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of the searched sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">find_end(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)Param: (Forward iterators to the initial and final positions of the searched sequence.)\t\nDesc: Find last subsequence in range (function template)\t\nProto: template &lt;class ForwardIterator1, class ForwardIterator2&gt;  ForwardIterator1 find_end (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator1, class ForwardIterator2&gt;  ForwardIterator1 find_end (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);</Data></Cell>
    <Cell><Data ss:Type="String">find_end</Data></Cell>
    <Cell><Data ss:Type="String">Find last subsequence in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions of the searched sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,ForwardIterator2 first2)Param: (Forward iterators to the initial and final positions in one of the sequences to be swapped.)\t\nDesc: Exchange values of two ranges (function template)\t\nProto: template &lt;class ForwardIterator1, class ForwardIterator2&gt;\t\nForwardIterator2 swap_ranges (ForwardIterator1 first1, ForwardIterator1 last1,ForwardIterator2 first2);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ForwardIterator1 first1, ForwardIterator1 last1,ForwardIterator2 first2)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class ForwardIterator1, class ForwardIterator2&gt;\t\nForwardIterator2 swap_ranges (ForwardIterator1 first1, ForwardIterator1 last1,ForwardIterator2 first2);</Data></Cell>
    <Cell><Data ss:Type="String">swap_ranges</Data></Cell>
    <Cell><Data ss:Type="String">Exchange values of two ranges (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first1, last1)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions in one of the sequences to be swapped.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">distance(InputIterator first, InputIterator last)Param: (Iterator pointing to the initial element.)\t\nDesc: Return distance between iterators (function template)\t\nProto: template&lt;class InputIterator&gt;\t\ntypename iterator_traits&lt;InputIterator&gt;::difference_type\t\n distance (InputIterator first, InputIterator last);\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last)</Data></Cell>
    <Cell><Data ss:Type="String">template&lt;class InputIterator&gt;\t\ntypename iterator_traits&lt;InputIterator&gt;::difference_type\t\n distance (InputIterator first, InputIterator last);</Data></Cell>
    <Cell><Data ss:Type="String">distance</Data></Cell>
    <Cell><Data ss:Type="String">Return distance between iterators (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first)</Data></Cell>
    <Cell><Data ss:Type="String">Iterator pointing to the initial element.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remove_copy(InputIterator first, InputIterator last,   OutputIterator result, const T&amp; val)Param: (Forward iterators to the initial and final positions in a sequence of elements supporting being compared to a value of type T.)\t\nDesc: Copy range removing value (function template)\t\nProto: template &lt;class InputIterator, class OutputIterator, class T&gt;\t\nOutputIterator remove_copy (InputIterator first, InputIterator last,   OutputIterator result, const T&amp; val);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last,   OutputIterator result, const T&amp; val)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class OutputIterator, class T&gt;\t\nOutputIterator remove_copy (InputIterator first, InputIterator last,   OutputIterator result, const T&amp; val);</Data></Cell>
    <Cell><Data ss:Type="String">remove_copy</Data></Cell>
    <Cell><Data ss:Type="String">Copy range removing value (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions in a sequence of elements supporting being compared to a value of type T.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">count(InputIterator first, InputIterator last, const T&amp; val)Param: (Input iterators to the initial and final positions of the sequence of elements.)\t\nDesc: Count appearances of value in range (function template)\t\nProto: template &lt;class InputIterator, class T&gt;\t\ntypename iterator_traits&lt;InputIterator&gt;::difference_type\t\n count (InputIterator first, InputIterator last, const T&amp; val);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last, const T&amp; val)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class T&gt;\t\ntypename iterator_traits&lt;InputIterator&gt;::difference_type\t\n count (InputIterator first, InputIterator last, const T&amp; val);</Data></Cell>
    <Cell><Data ss:Type="String">count</Data></Cell>
    <Cell><Data ss:Type="String">Count appearances of value in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the sequence of elements.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">for_each(InputIterator first, InputIterator last, Function fn)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Apply function to range (function template)\t\nProto: template &lt;class InputIterator, class Function&gt;  Function for_each (InputIterator first, InputIterator last, Function fn);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last, Function fn)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class Function&gt;  Function for_each (InputIterator first, InputIterator last, Function fn);</Data></Cell>
    <Cell><Data ss:Type="String">for_each</Data></Cell>
    <Cell><Data ss:Type="String">Apply function to range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">copy_if(InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Copy certain elements of range (function template)\t\nProto: template &lt;class InputIterator, class OutputIterator, class UnaryPredicate&gt;\t\nOutputIterator copy_if (InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred);\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class OutputIterator, class UnaryPredicate&gt;\t\nOutputIterator copy_if (InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred);</Data></Cell>
    <Cell><Data ss:Type="String">copy_if</Data></Cell>
    <Cell><Data ss:Type="String">Copy certain elements of range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred)Param: (Forward iterators to the initial and final positions in a sequence.)\t\nDesc: Copy range removing values (function template)\t\nProto: template &lt;class InputIterator, class OutputIterator, class UnaryPredicate&gt;\t\nOutputIterator remove_copy_if (InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class OutputIterator, class UnaryPredicate&gt;\t\nOutputIterator remove_copy_if (InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred);</Data></Cell>
    <Cell><Data ss:Type="String">remove_copy_if</Data></Cell>
    <Cell><Data ss:Type="String">Copy range removing values (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Forward iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">all_of(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Test condition on all elements in range (function template)\t\nProto: template &lt;class InputIterator, class UnaryPredicate&gt;\t\nbool all_of (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last, UnaryPredicate pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class UnaryPredicate&gt;\t\nbool all_of (InputIterator first, InputIterator last, UnaryPredicate pred);</Data></Cell>
    <Cell><Data ss:Type="String">all_of</Data></Cell>
    <Cell><Data ss:Type="String">Test condition on all elements in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">any_of(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Test if any element in range fulfills condition (function template)\t\nProto: template &lt;class InputIterator, class UnaryPredicate&gt;\t\nbool any_of (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last, UnaryPredicate pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class UnaryPredicate&gt;\t\nbool any_of (InputIterator first, InputIterator last, UnaryPredicate pred);</Data></Cell>
    <Cell><Data ss:Type="String">any_of</Data></Cell>
    <Cell><Data ss:Type="String">Test if any element in range fulfills condition (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">count_if(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions of the sequence of elements.)\t\nDesc: Return number of elements in range satisfying condition (function template)\t\nProto: template &lt;class InputIterator, class UnaryPredicate&gt;\t\ntypename iterator_traits&lt;InputIterator&gt;::difference_type\t\n count_if (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last, UnaryPredicate pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class UnaryPredicate&gt;\t\ntypename iterator_traits&lt;InputIterator&gt;::difference_type\t\n count_if (InputIterator first, InputIterator last, UnaryPredicate pred);</Data></Cell>
    <Cell><Data ss:Type="String">count_if</Data></Cell>
    <Cell><Data ss:Type="String">Return number of elements in range satisfying condition (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the sequence of elements.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">find_if(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Find element in range (function template)\t\nProto: template &lt;class InputIterator, class UnaryPredicate&gt;\t\n InputIterator find_if (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last, UnaryPredicate pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class UnaryPredicate&gt;\t\n InputIterator find_if (InputIterator first, InputIterator last, UnaryPredicate pred);</Data></Cell>
    <Cell><Data ss:Type="String">find_if</Data></Cell>
    <Cell><Data ss:Type="String">Find element in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">find_if_not(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Find element in range (negative condition) (function template)\t\nProto: template &lt;class InputIterator, class UnaryPredicate&gt;\t\n InputIterator find_if_not (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last, UnaryPredicate pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class UnaryPredicate&gt;\t\n InputIterator find_if_not (InputIterator first, InputIterator last, UnaryPredicate pred);</Data></Cell>
    <Cell><Data ss:Type="String">find_if_not</Data></Cell>
    <Cell><Data ss:Type="String">Find element in range (negative condition) (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">is_partitioned(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions of the sequence.)\t\nDesc: Test whether range is partitioned (function template)\t\nProto: template &lt;class InputIterator, class UnaryPredicate&gt;\t\nbool is_partitioned (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last, UnaryPredicate pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class UnaryPredicate&gt;\t\nbool is_partitioned (InputIterator first, InputIterator last, UnaryPredicate pred);</Data></Cell>
    <Cell><Data ss:Type="String">is_partitioned</Data></Cell>
    <Cell><Data ss:Type="String">Test whether range is partitioned (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions of the sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">none_of(InputIterator first, InputIterator last, UnaryPredicate pred)Param: (Input iterators to the initial and final positions in a sequence.)\t\nDesc: Test if no elements fulfill condition (function template)\t\nProto: template &lt;class InputIterator, class UnaryPredicate&gt;\t\nbool none_of (InputIterator first, InputIterator last, UnaryPredicate pred);\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, InputIterator last, UnaryPredicate pred)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class UnaryPredicate&gt;\t\nbool none_of (InputIterator first, InputIterator last, UnaryPredicate pred);</Data></Cell>
    <Cell><Data ss:Type="String">none_of</Data></Cell>
    <Cell><Data ss:Type="String">Test if no elements fulfill condition (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial and final positions in a sequence.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">copy_n(InputIterator first, Size n, OutputIterator result)Param: (Input iterators to the initial position in a sequence of at least n elements to be copied.)\t\nDesc: Copy elements (function template)\t\nProto: template &lt;class InputIterator, class Size, class OutputIterator&gt;\t\nOutputIterator copy_n (InputIterator first, Size n, OutputIterator result);\t\n[cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator first, Size n, OutputIterator result)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class Size, class OutputIterator&gt;\t\nOutputIterator copy_n (InputIterator first, Size n, OutputIterator result);</Data></Cell>
    <Cell><Data ss:Type="String">copy_n</Data></Cell>
    <Cell><Data ss:Type="String">Copy elements (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first)</Data></Cell>
    <Cell><Data ss:Type="String">Input iterators to the initial position in a sequence of at least n elements to be copied.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">advance(InputIterator&amp; it, Distance n)Param: (Iterator to be advanced.)\t\nDesc: Advance iterator (function template)\t\nProto: template &lt;class InputIterator, class Distance&gt;\t\nvoid advance (InputIterator&amp; it, Distance n);\t\n[cpp98 cpp11] [&lt;iterator&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(InputIterator&amp; it, Distance n)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class InputIterator, class Distance&gt;\t\nvoid advance (InputIterator&amp; it, Distance n);</Data></Cell>
    <Cell><Data ss:Type="String">advance</Data></Cell>
    <Cell><Data ss:Type="String">Advance iterator (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(it)</Data></Cell>
    <Cell><Data ss:Type="String">Iterator to be advanced.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iterator&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Iterator definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">setbase(int base)Param: (Numerical radix to be used:\t\n\t\nbase argument\t\n\t\nsame as inserting.)\t\nDesc: Set basefield flag (function)\t\nProto: /*unspecified*/ setbase (int base);\t\n[arm cpp98 cpp11] [&lt;iomanip&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(int base)</Data></Cell>
    <Cell><Data ss:Type="String">/*unspecified*/ setbase (int base);</Data></Cell>
    <Cell><Data ss:Type="String">setbase</Data></Cell>
    <Cell><Data ss:Type="String">Set basefield flag (function)</Data></Cell>
    <Cell><Data ss:Type="String">(base)</Data></Cell>
    <Cell><Data ss:Type="String">Numerical radix to be used:\t\n\t\nbase argument\t\n\t\nsame as inserting.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iomanip&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">IO Manipulators</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">setlocale(int category, const char* locale)Param: (Portion of the locale affected.)\t\nDesc: Set or retrieve locale (function)\t\nProto: char* setlocale (int category, const char* locale);\t\n[c90 c99 arm cpp98 cpp11] [&lt;clocale&gt; (locale.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(int category, const char* locale)</Data></Cell>
    <Cell><Data ss:Type="String">char* setlocale (int category, const char* locale);</Data></Cell>
    <Cell><Data ss:Type="String">setlocale</Data></Cell>
    <Cell><Data ss:Type="String">Set or retrieve locale (function)</Data></Cell>
    <Cell><Data ss:Type="String">(category)</Data></Cell>
    <Cell><Data ss:Type="String">Portion of the locale affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;clocale&gt; (locale.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">feclearexcept(int excepts)Param: (Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation.)\t\nDesc: Clear floating-point exceptions (function)\t\nProto: int feclearexcept (int excepts);\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(int excepts)</Data></Cell>
    <Cell><Data ss:Type="String">int feclearexcept (int excepts);</Data></Cell>
    <Cell><Data ss:Type="String">feclearexcept</Data></Cell>
    <Cell><Data ss:Type="String">Clear floating-point exceptions (function)</Data></Cell>
    <Cell><Data ss:Type="String">(excepts)</Data></Cell>
    <Cell><Data ss:Type="String">Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">feraiseexcept(int excepts)Param: (Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation.)\t\nDesc: Raise floating-point exception (function)\t\nProto: int feraiseexcept (int excepts);\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(int excepts)</Data></Cell>
    <Cell><Data ss:Type="String">int feraiseexcept (int excepts);</Data></Cell>
    <Cell><Data ss:Type="String">feraiseexcept</Data></Cell>
    <Cell><Data ss:Type="String">Raise floating-point exception (function)</Data></Cell>
    <Cell><Data ss:Type="String">(excepts)</Data></Cell>
    <Cell><Data ss:Type="String">Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fetestexcept(int excepts)Param: (Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation.)\t\nDesc: Test for floating-point exceptions (function)\t\nProto: int fetestexcept (int excepts);\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(int excepts)</Data></Cell>
    <Cell><Data ss:Type="String">int fetestexcept (int excepts);</Data></Cell>
    <Cell><Data ss:Type="String">fetestexcept</Data></Cell>
    <Cell><Data ss:Type="String">Test for floating-point exceptions (function)</Data></Cell>
    <Cell><Data ss:Type="String">(excepts)</Data></Cell>
    <Cell><Data ss:Type="String">Bitmask value: A combination (with bitwise OR) of any number of floating-point exception values supported by the implementation.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">assert(int expression)Param: (Expression to be evaluated.)\t\nDesc: Evaluate assertion (macro)\t\nProto: void assert (int expression);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cassert&gt; (assert.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(int expression)</Data></Cell>
    <Cell><Data ss:Type="String">void assert (int expression);</Data></Cell>
    <Cell><Data ss:Type="String">assert</Data></Cell>
    <Cell><Data ss:Type="String">Evaluate assertion (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(expression)</Data></Cell>
    <Cell><Data ss:Type="String">Expression to be evaluated.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cassert&gt; (assert.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Diagnostics Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">setprecision(int n)Param: (New value for the decimal precision.)\t\nDesc: Set decimal precision (function)\t\nProto: /*unspecified*/ setprecision (int n);\t\n[arm cpp98 cpp11] [&lt;iomanip&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(int n)</Data></Cell>
    <Cell><Data ss:Type="String">/*unspecified*/ setprecision (int n);</Data></Cell>
    <Cell><Data ss:Type="String">setprecision</Data></Cell>
    <Cell><Data ss:Type="String">Set decimal precision (function)</Data></Cell>
    <Cell><Data ss:Type="String">(n)</Data></Cell>
    <Cell><Data ss:Type="String">New value for the decimal precision.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iomanip&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">IO Manipulators</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">setw(int n)Param: (Number of characters to be used as field width.)\t\nDesc: Set field width (function)\t\nProto: /*undefined*/ setw (int n);\t\n[arm cpp98 cpp11] [&lt;iomanip&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(int n)</Data></Cell>
    <Cell><Data ss:Type="String">/*undefined*/ setw (int n);</Data></Cell>
    <Cell><Data ss:Type="String">setw</Data></Cell>
    <Cell><Data ss:Type="String">Set field width (function)</Data></Cell>
    <Cell><Data ss:Type="String">(n)</Data></Cell>
    <Cell><Data ss:Type="String">Number of characters to be used as field width.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iomanip&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">IO Manipulators</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">div(int numer, int denom)Param: (Numerator.)\t\nDesc: Integral division (function)\t\nProto: div_t div (int numer, int denom);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(int numer, int denom)</Data></Cell>
    <Cell><Data ss:Type="String">div_t div (int numer, int denom);</Data></Cell>
    <Cell><Data ss:Type="String">div</Data></Cell>
    <Cell><Data ss:Type="String">Integral division (function)</Data></Cell>
    <Cell><Data ss:Type="String">(numer)</Data></Cell>
    <Cell><Data ss:Type="String">Numerator.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fesetround(int rdir)Param: (One of the values defined as rounding direction mode.)\t\nDesc: Set rounding direction mode (function)\t\nProto: int fesetround (int rdir);\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(int rdir)</Data></Cell>
    <Cell><Data ss:Type="String">int fesetround (int rdir);</Data></Cell>
    <Cell><Data ss:Type="String">fesetround</Data></Cell>
    <Cell><Data ss:Type="String">Set rounding direction mode (function)</Data></Cell>
    <Cell><Data ss:Type="String">(rdir)</Data></Cell>
    <Cell><Data ss:Type="String">One of the values defined as rounding direction mode.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">_Exit(int status)Param: (Status code.)\t\nDesc: Terminate calling process (function)\t\nProto: void _Exit (int status);\t\n[c99 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(int status)</Data></Cell>
    <Cell><Data ss:Type="String">void _Exit (int status);</Data></Cell>
    <Cell><Data ss:Type="String">_Exit</Data></Cell>
    <Cell><Data ss:Type="String">Terminate calling process (function)</Data></Cell>
    <Cell><Data ss:Type="String">(status)</Data></Cell>
    <Cell><Data ss:Type="String">Status code.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">boolalpha(ios_base&amp; str)Param: (Stream object whose format flag is affected.)\t\nDesc: Alphanumerical bool values (function)\t\nProto: ios_base&amp; boolalpha (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; boolalpha (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">boolalpha</Data></Cell>
    <Cell><Data ss:Type="String">Alphanumerical bool values (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">dec(ios_base&amp; str)Param: (Stream object whose basefield format flag is affected.)\t\nDesc: Use decimal base (function)\t\nProto: ios_base&amp; dec (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; dec (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">dec</Data></Cell>
    <Cell><Data ss:Type="String">Use decimal base (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose basefield format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">defaultfloat(ios_base&amp; str)Param: (Stream object whose floatfield format flag is affected.)\t\nDesc: no-Description (other)\t\nProto: ios_base&amp; defaultfloat (ios_base&amp; str);\t\n[cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; defaultfloat (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">defaultfloat</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose floatfield format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fixed(ios_base&amp; str)Param: (Stream object whose floatfield format flag is affected.)\t\nDesc: Use fixed floating-point notation (function)\t\nProto: ios_base&amp; fixed (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; fixed (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">fixed</Data></Cell>
    <Cell><Data ss:Type="String">Use fixed floating-point notation (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose floatfield format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">hex(ios_base&amp; str)Param: (Stream object whose basefield format flag is affected.)\t\nDesc: Use hexadecimal base (function)\t\nProto: ios_base&amp; hex (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; hex (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">hex</Data></Cell>
    <Cell><Data ss:Type="String">Use hexadecimal base (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose basefield format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">hexfloat(ios_base&amp; str)Param: (Stream object whose floatfield format flag is affected.)\t\nDesc: no-Description (other)\t\nProto: ios_base&amp; hexfloat (ios_base&amp; str);\t\n[cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; hexfloat (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">hexfloat</Data></Cell>
    <Cell><Data ss:Type="String">no-Description (other)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose floatfield format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">other</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">internal(ios_base&amp; str)Param: (Stream object whose adjustfield format flag is affected.)\t\nDesc: Adjust field by inserting characters at an internal position (function)\t\nProto: ios_base&amp; internal (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; internal (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">internal</Data></Cell>
    <Cell><Data ss:Type="String">Adjust field by inserting characters at an internal position (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose adjustfield format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">left(ios_base&amp; str)Param: (Stream object whose adjustfield format flag is affected.)\t\nDesc: Adjust output to the left (function)\t\nProto: ios_base&amp; left (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; left (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">left</Data></Cell>
    <Cell><Data ss:Type="String">Adjust output to the left (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose adjustfield format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">noboolalpha(ios_base&amp; str)Param: (Stream object whose format flag is affected.)\t\nDesc: No alphanumerical bool values (function)\t\nProto: ios_base&amp; noboolalpha (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; noboolalpha (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">noboolalpha</Data></Cell>
    <Cell><Data ss:Type="String">No alphanumerical bool values (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">noshowbase(ios_base&amp; str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not show numerical base prefixes (function)\t\nProto: ios_base&amp; noshowbase (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; noshowbase (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">noshowbase</Data></Cell>
    <Cell><Data ss:Type="String">Do not show numerical base prefixes (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">noshowpoint(ios_base&amp; str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not show decimal point (function)\t\nProto: ios_base&amp; noshowpoint (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; noshowpoint (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">noshowpoint</Data></Cell>
    <Cell><Data ss:Type="String">Do not show decimal point (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">noshowpos(ios_base&amp; str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not show positive signs (function)\t\nProto: ios_base&amp; noshowpos (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; noshowpos (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">noshowpos</Data></Cell>
    <Cell><Data ss:Type="String">Do not show positive signs (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">noskipws(ios_base&amp; str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not skip whitespaces (function)\t\nProto: ios_base&amp; noskipws (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; noskipws (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">noskipws</Data></Cell>
    <Cell><Data ss:Type="String">Do not skip whitespaces (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">nounitbuf(ios_base&amp; str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not force flushes after insertions (function)\t\nProto: ios_base&amp; nounitbuf (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; nounitbuf (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">nounitbuf</Data></Cell>
    <Cell><Data ss:Type="String">Do not force flushes after insertions (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">nouppercase(ios_base&amp; str)Param: (Stream object whose format flag is affected.)\t\nDesc: Do not generate upper case letters (function)\t\nProto: ios_base&amp; nouppercase (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; nouppercase (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">nouppercase</Data></Cell>
    <Cell><Data ss:Type="String">Do not generate upper case letters (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">oct(ios_base&amp; str)Param: (Stream object whose basefield format flag is affected.)\t\nDesc: Use octal base (function)\t\nProto: ios_base&amp; oct (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; oct (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">oct</Data></Cell>
    <Cell><Data ss:Type="String">Use octal base (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose basefield format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">right(ios_base&amp; str)Param: (Stream object whose adjustfield format flag is affected.)\t\nDesc: Adjust output to the right (function)\t\nProto: ios_base&amp; right (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; right (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">right</Data></Cell>
    <Cell><Data ss:Type="String">Adjust output to the right (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose adjustfield format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">scientific(ios_base&amp; str)Param: (Stream object whose floatfield format flag is affected.)\t\nDesc: Use scientific floating-point notation (function)\t\nProto: ios_base&amp; scientific (ios_base&amp; str);\t\n[arm cpp98 cpp11] [&lt;ios&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base&amp; str)</Data></Cell>
    <Cell><Data ss:Type="String">ios_base&amp; scientific (ios_base&amp; str);</Data></Cell>
    <Cell><Data ss:Type="String">scientific</Data></Cell>
    <Cell><Data ss:Type="String">Use scientific floating-point notation (function)</Data></Cell>
    <Cell><Data ss:Type="String">(str)</Data></Cell>
    <Cell><Data ss:Type="String">Stream object whose floatfield format flag is affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ios&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Input-Output base classes</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">resetiosflags(ios_base::fmtflags mask)Param: (Mask representing the flags to be reset.)\t\nDesc: Reset format flags (function)\t\nProto: /*unspecified*/ resetiosflags (ios_base::fmtflags mask);\t\n[arm cpp98 cpp11] [&lt;iomanip&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ios_base::fmtflags mask)</Data></Cell>
    <Cell><Data ss:Type="String">/*unspecified*/ resetiosflags (ios_base::fmtflags mask);</Data></Cell>
    <Cell><Data ss:Type="String">resetiosflags</Data></Cell>
    <Cell><Data ss:Type="String">Reset format flags (function)</Data></Cell>
    <Cell><Data ss:Type="String">(mask)</Data></Cell>
    <Cell><Data ss:Type="String">Mask representing the flags to be reset.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iomanip&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">IO Manipulators</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">setjmp(jmp_buf env)Param: (Object of type jmp_buf where the environment information is stored.)\t\nDesc: Save calling environment for long jump (macro)\t\nProto: int setjmp (jmp_buf env);\t\n[c90 c99 arm cpp98 cpp11] [&lt;csetjmp&gt; (setjmp.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(jmp_buf env)</Data></Cell>
    <Cell><Data ss:Type="String">int setjmp (jmp_buf env);</Data></Cell>
    <Cell><Data ss:Type="String">setjmp</Data></Cell>
    <Cell><Data ss:Type="String">Save calling environment for long jump (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(env)</Data></Cell>
    <Cell><Data ss:Type="String">Object of type jmp_buf where the environment information is stored.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;csetjmp&gt; (setjmp.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Non local jumps</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">longjmp(jmp_buf env, int val)Param: (Object of type jmp_buf filled by a previous call to setjmp that contains information to restore the environment to that point.)\t\nDesc: Long jump (function)\t\nProto: void longjmp (jmp_buf env, int val);\t\n[c90 c99 arm cpp98 cpp11] [&lt;csetjmp&gt; (setjmp.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(jmp_buf env, int val)</Data></Cell>
    <Cell><Data ss:Type="String">void longjmp (jmp_buf env, int val);</Data></Cell>
    <Cell><Data ss:Type="String">longjmp</Data></Cell>
    <Cell><Data ss:Type="String">Long jump (function)</Data></Cell>
    <Cell><Data ss:Type="String">(env)</Data></Cell>
    <Cell><Data ss:Type="String">Object of type jmp_buf filled by a previous call to setjmp that contains information to restore the environment to that point.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;csetjmp&gt; (setjmp.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Non local jumps</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">labs(long int n)Param: (Integral value.)\t\nDesc: Absolute value (function)\t\nProto: long int labs (long int n);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(long int n)</Data></Cell>
    <Cell><Data ss:Type="String">long int labs (long int n);</Data></Cell>
    <Cell><Data ss:Type="String">labs</Data></Cell>
    <Cell><Data ss:Type="String">Absolute value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(n)</Data></Cell>
    <Cell><Data ss:Type="String">Integral value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ldiv(long int numer, long int denom)Param: (Numerator.)\t\nDesc: Integral division (function)\t\nProto: ldiv_t ldiv (long int numer, long int denom);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(long int numer, long int denom)</Data></Cell>
    <Cell><Data ss:Type="String">ldiv_t ldiv (long int numer, long int denom);</Data></Cell>
    <Cell><Data ss:Type="String">ldiv</Data></Cell>
    <Cell><Data ss:Type="String">Integral division (function)</Data></Cell>
    <Cell><Data ss:Type="String">(numer)</Data></Cell>
    <Cell><Data ss:Type="String">Numerator.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">llabs(long long int n)Param: (Integral value.)\t\nDesc: Absolute value (function)\t\nProto: long long int llabs (long long int n);\t\n[c99 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(long long int n)</Data></Cell>
    <Cell><Data ss:Type="String">long long int llabs (long long int n);</Data></Cell>
    <Cell><Data ss:Type="String">llabs</Data></Cell>
    <Cell><Data ss:Type="String">Absolute value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(n)</Data></Cell>
    <Cell><Data ss:Type="String">Integral value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">lldiv(long long int numer, long long int denom)Param: (Numerator.)\t\nDesc: Integral division (function)\t\nProto: lldiv_t lldiv (long long int numer, long long int denom);\t\n[c99 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(long long int numer, long long int denom)</Data></Cell>
    <Cell><Data ss:Type="String">lldiv_t lldiv (long long int numer, long long int denom);</Data></Cell>
    <Cell><Data ss:Type="String">lldiv</Data></Cell>
    <Cell><Data ss:Type="String">Integral division (function)</Data></Cell>
    <Cell><Data ss:Type="String">(numer)</Data></Cell>
    <Cell><Data ss:Type="String">Numerator.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_signal_fence(memory_order sync) noexcept;Param: (Synchronization mode for the operation.)\t\nDesc: Signal fence (function)\t\nProto: extern &quot;C&quot; void atomic_signal_fence (memory_order sync) noexcept;\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(memory_order sync) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">extern &quot;C&quot; void atomic_signal_fence (memory_order sync) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">atomic_signal_fence</Data></Cell>
    <Cell><Data ss:Type="String">Signal fence (function)</Data></Cell>
    <Cell><Data ss:Type="String">(sync)</Data></Cell>
    <Cell><Data ss:Type="String">Synchronization mode for the operation.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_thread_fence(memory_order sync) noexcept;Param: (Synchronization mode for the operation.)\t\nDesc: Thread fence (function)\t\nProto: extern &quot;C&quot; void atomic_thread_fence (memory_order sync) noexcept;\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(memory_order sync) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">extern &quot;C&quot; void atomic_thread_fence (memory_order sync) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">atomic_thread_fence</Data></Cell>
    <Cell><Data ss:Type="String">Thread fence (function)</Data></Cell>
    <Cell><Data ss:Type="String">(sync)</Data></Cell>
    <Cell><Data ss:Type="String">Synchronization mode for the operation.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">get_money(moneyT&amp; mon, bool intl = false)Param: (Object where the monetary value is stored.)\t\nDesc: Get monetary value (function)\t\nProto: template &lt;class moneyT&gt;\t\n/*unspecified*/ get_money (moneyT&amp; mon, bool intl = false);\t\n[cpp11] [&lt;iomanip&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(moneyT&amp; mon, bool intl = false)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class moneyT&gt;\t\n/*unspecified*/ get_money (moneyT&amp; mon, bool intl = false);</Data></Cell>
    <Cell><Data ss:Type="String">get_money</Data></Cell>
    <Cell><Data ss:Type="String">Get monetary value (function)</Data></Cell>
    <Cell><Data ss:Type="String">(mon)</Data></Cell>
    <Cell><Data ss:Type="String">Object where the monetary value is stored.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iomanip&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">IO Manipulators</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">try_lock(Mutex1&amp; a, Mutex2&amp; b, Mutexes&amp;... cde)Param: (Objects to try-lock.)\t\nDesc: Try to lock multiple mutexes (function template)\t\nProto: template &lt;class Mutex1, class Mutex2, class... Mutexes&gt;\t\nint try_lock (Mutex1&amp; a, Mutex2&amp; b, Mutexes&amp;... cde);\t\n[cpp11] [&lt;mutex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(Mutex1&amp; a, Mutex2&amp; b, Mutexes&amp;... cde)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Mutex1, class Mutex2, class... Mutexes&gt;\t\nint try_lock (Mutex1&amp; a, Mutex2&amp; b, Mutexes&amp;... cde);</Data></Cell>
    <Cell><Data ss:Type="String">try_lock</Data></Cell>
    <Cell><Data ss:Type="String">Try to lock multiple mutexes (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(a, b, cde)</Data></Cell>
    <Cell><Data ss:Type="String">Objects to try-lock.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;mutex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Mutex</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">set_new_handler(new_handler new_p) throw()Param: (Function that takes no arguments and returns no value ()\t\nDesc: Set new handler function (function)\t\nProto: new_handler set_new_handler (new_handler new_p) throw();\t\n[cpp98 cpp11] [&lt;new&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(new_handler new_p) throw()</Data></Cell>
    <Cell><Data ss:Type="String">new_handler set_new_handler (new_handler new_p) throw();</Data></Cell>
    <Cell><Data ss:Type="String">set_new_handler</Data></Cell>
    <Cell><Data ss:Type="String">Set new handler function (function)</Data></Cell>
    <Cell><Data ss:Type="String">(new_p)</Data></Cell>
    <Cell><Data ss:Type="String">Function that takes no arguments and returns no value (</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;new&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Dynamic memory</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">nullptr_t(nullptr) nullptr_t;Param: ()\t\nDesc: Null pointer type (C++) (type)\t\nProto: typedef decltype(nullptr) nullptr_t;\t\n[cpp11] [&lt;cstddef&gt; (stddef.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(nullptr) nullptr_t;</Data></Cell>
    <Cell><Data ss:Type="String">typedef decltype(nullptr) nullptr_t;</Data></Cell>
    <Cell><Data ss:Type="String">nullptr_t</Data></Cell>
    <Cell><Data ss:Type="String">Null pointer type (C++) (type)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">type</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstddef&gt; (stddef.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">call_once(once_flag&amp; flag, Fn&amp;&amp; fn, Args&amp;&amp;... args)Param: (Object used by the function to track the state of invocations.)\t\nDesc: Call function once (public member function)\t\nProto: template &lt;class Fn, class... Args&gt; void call_once (once_flag&amp; flag, Fn&amp;&amp; fn, Args&amp;&amp;... args);\t\n[cpp11] [&lt;mutex&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(once_flag&amp; flag, Fn&amp;&amp; fn, Args&amp;&amp;... args)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Fn, class... Args&gt; void call_once (once_flag&amp; flag, Fn&amp;&amp; fn, Args&amp;&amp;... args);</Data></Cell>
    <Cell><Data ss:Type="String">call_once</Data></Cell>
    <Cell><Data ss:Type="String">Call function once (public member function)</Data></Cell>
    <Cell><Data ss:Type="String">(flag)</Data></Cell>
    <Cell><Data ss:Type="String">Object used by the function to track the state of invocations.</Data></Cell>
    <Cell><Data ss:Type="String">public member function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;mutex&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Mutex</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">endl(ostream&amp; os)Param: (Output stream object affected.)\t\nDesc: Insert newline and flush (function)\t\nProto: for ostream\t\nostream&amp; endl (ostream&amp; os);basic template\t\ntemplate &lt;class charT, class traits&gt;\t\nbasic_ostream&lt;charT,traits&gt;&amp; endl (basic_ostream&lt;charT,traits&gt;&amp; os);\t\n[arm cpp98 cpp11] [&lt;ostream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ostream&amp; os)</Data></Cell>
    <Cell><Data ss:Type="String">for ostream\t\nostream&amp; endl (ostream&amp; os);basic template\t\ntemplate &lt;class charT, class traits&gt;\t\nbasic_ostream&lt;charT,traits&gt;&amp; endl (basic_ostream&lt;charT,traits&gt;&amp; os);</Data></Cell>
    <Cell><Data ss:Type="String">endl</Data></Cell>
    <Cell><Data ss:Type="String">Insert newline and flush (function)</Data></Cell>
    <Cell><Data ss:Type="String">(os)</Data></Cell>
    <Cell><Data ss:Type="String">Output stream object affected.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ostream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Output stream</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ends(ostream&amp; os)Param: (Output stream object where character is inserted.)\t\nDesc: Insert null character (function)\t\nProto: for ostream\t\nostream&amp; ends (ostream&amp; os);basic template\t\ntemplate &lt;class charT, class traits&gt;\t\nbasic_ostream&lt;charT,traits&gt;&amp; ends (basic_ostream&lt;charT,traits&gt;&amp; os);\t\n[arm cpp98 cpp11] [&lt;ostream&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(ostream&amp; os)</Data></Cell>
    <Cell><Data ss:Type="String">for ostream\t\nostream&amp; ends (ostream&amp; os);basic template\t\ntemplate &lt;class charT, class traits&gt;\t\nbasic_ostream&lt;charT,traits&gt;&amp; ends (basic_ostream&lt;charT,traits&gt;&amp; os);</Data></Cell>
    <Cell><Data ss:Type="String">ends</Data></Cell>
    <Cell><Data ss:Type="String">Insert null character (function)</Data></Cell>
    <Cell><Data ss:Type="String">(os)</Data></Cell>
    <Cell><Data ss:Type="String">Output stream object where character is inserted.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ostream&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Output stream</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fill_n(OutputIterator first, Size n, const T&amp; val)Param: (Output iterators to the initial position in a sequence of at least n elements that support being assigned a value of type T.)\t\nDesc: Fill sequence with value (function template)\t\nProto: template &lt;class OutputIterator, class Size, class T&gt; void fill_n (OutputIterator first, Size n, const T&amp; val);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(OutputIterator first, Size n, const T&amp; val)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class OutputIterator, class Size, class T&gt; void fill_n (OutputIterator first, Size n, const T&amp; val);</Data></Cell>
    <Cell><Data ss:Type="String">fill_n</Data></Cell>
    <Cell><Data ss:Type="String">Fill sequence with value (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first)</Data></Cell>
    <Cell><Data ss:Type="String">Output iterators to the initial position in a sequence of at least n elements that support being assigned a value of type T.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">generate_n(OutputIterator first, Size n, Generator gen)Param: (Output iterators to the initial positions in a sequence of at least n elements that support being assigned a value of the type returned by gen.)\t\nDesc: Generate values for sequence with function (function template)\t\nProto: template &lt;class OutputIterator, class Size, class Generator&gt; void generate_n (OutputIterator first, Size n, Generator gen);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(OutputIterator first, Size n, Generator gen)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class OutputIterator, class Size, class Generator&gt; void generate_n (OutputIterator first, Size n, Generator gen);</Data></Cell>
    <Cell><Data ss:Type="String">generate_n</Data></Cell>
    <Cell><Data ss:Type="String">Generate values for sequence with function (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first)</Data></Cell>
    <Cell><Data ss:Type="String">Output iterators to the initial positions in a sequence of at least n elements that support being assigned a value of the type returned by gen.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">random_shuffle(RandomAccessIterator first, RandomAccessIterator last)Param: (Random-access iterators to the initial and final positions of the sequence to be shuffled.)\t\nDesc: Randomly rearrange elements in range (function template)\t\nProto: template &lt;class RandomAccessIterator&gt; void random_shuffle (RandomAccessIterator first, RandomAccessIterator last);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(RandomAccessIterator first, RandomAccessIterator last)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RandomAccessIterator&gt; void random_shuffle (RandomAccessIterator first, RandomAccessIterator last);</Data></Cell>
    <Cell><Data ss:Type="String">random_shuffle</Data></Cell>
    <Cell><Data ss:Type="String">Randomly rearrange elements in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Random-access iterators to the initial and final positions of the sequence to be shuffled.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">nth_element(RandomAccessIterator first, RandomAccessIterator nth,RandomAccessIterator last)Param: (Random-access iterators to the initial and final positions of the sequence to be used.)\t\nDesc: Sort element in range (function template)\t\nProto: template &lt;class RandomAccessIterator&gt; void nth_element (RandomAccessIterator first, RandomAccessIterator nth,RandomAccessIterator last);\t\n[cpp98 cpp11] [&lt;algorithm&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(RandomAccessIterator first, RandomAccessIterator nth,RandomAccessIterator last)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RandomAccessIterator&gt; void nth_element (RandomAccessIterator first, RandomAccessIterator nth,RandomAccessIterator last);</Data></Cell>
    <Cell><Data ss:Type="String">nth_element</Data></Cell>
    <Cell><Data ss:Type="String">Sort element in range (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(first, last)</Data></Cell>
    <Cell><Data ss:Type="String">Random-access iterators to the initial and final positions of the sequence to be used.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;algorithm&gt;</Data></Cell>
    <Cell><Data ss:Type="String">library</Data></Cell>
    <Cell><Data ss:Type="String">Standard Template Library: Algorithms</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mem_fn(Ret T::* pm)Param: (Pointer to a member function.)\t\nDesc: Convert member function to function object (function template)\t\nProto: template &lt;class Ret, class T&gt;\t\n/* unspecified */ mem_fn (Ret T::* pm);\t\n[cpp11] [&lt;functional&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(Ret T::* pm)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class Ret, class T&gt;\t\n/* unspecified */ mem_fn (Ret T::* pm);</Data></Cell>
    <Cell><Data ss:Type="String">mem_fn</Data></Cell>
    <Cell><Data ss:Type="String">Convert member function to function object (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(pm)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a member function.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;functional&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Function objects</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">calloc(size_t num, size_t size)Param: (Number of elements to allocate.)\t\nDesc: Allocate and zero-initialize array (function)\t\nProto: void* calloc (size_t num, size_t size);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(size_t num, size_t size)</Data></Cell>
    <Cell><Data ss:Type="String">void* calloc (size_t num, size_t size);</Data></Cell>
    <Cell><Data ss:Type="String">calloc</Data></Cell>
    <Cell><Data ss:Type="String">Allocate and zero-initialize array (function)</Data></Cell>
    <Cell><Data ss:Type="String">(num)</Data></Cell>
    <Cell><Data ss:Type="String">Number of elements to allocate.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">malloc(size_t size)Param: (Size of the memory block, in bytes.)\t\nDesc: Allocate memory block (function)\t\nProto: void* malloc (size_t size);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(size_t size)</Data></Cell>
    <Cell><Data ss:Type="String">void* malloc (size_t size);</Data></Cell>
    <Cell><Data ss:Type="String">malloc</Data></Cell>
    <Cell><Data ss:Type="String">Allocate memory block (function)</Data></Cell>
    <Cell><Data ss:Type="String">(size)</Data></Cell>
    <Cell><Data ss:Type="String">Size of the memory block, in bytes.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">operator new(std::size_t size) throw (std::bad_alloc)Param: (Size in bytes of the requested memory block.)\t\nDesc: Allocate storage space (function)\t\nProto: void* operator new (std::size_t size) throw (std::bad_alloc);\t\n[cpp98 cpp11] [&lt;new&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(std::size_t size) throw (std::bad_alloc)</Data></Cell>
    <Cell><Data ss:Type="String">void* operator new (std::size_t size) throw (std::bad_alloc);</Data></Cell>
    <Cell><Data ss:Type="String">operator new</Data></Cell>
    <Cell><Data ss:Type="String">Allocate storage space (function)</Data></Cell>
    <Cell><Data ss:Type="String">(size)</Data></Cell>
    <Cell><Data ss:Type="String">Size in bytes of the requested memory block.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;new&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Dynamic memory</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">operator new[](std::size_t size) throw (std::bad_alloc)Param: (Size in bytes of the requested memory block.)\t\nDesc: Allocate storage space for array (function)\t\nProto: void* operator new[] (std::size_t size) throw (std::bad_alloc);\t\n[cpp98 cpp11] [&lt;new&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(std::size_t size) throw (std::bad_alloc)</Data></Cell>
    <Cell><Data ss:Type="String">void* operator new[] (std::size_t size) throw (std::bad_alloc);</Data></Cell>
    <Cell><Data ss:Type="String">operator new[]</Data></Cell>
    <Cell><Data ss:Type="String">Allocate storage space for array (function)</Data></Cell>
    <Cell><Data ss:Type="String">(size)</Data></Cell>
    <Cell><Data ss:Type="String">Size in bytes of the requested memory block.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;new&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Dynamic memory</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mktime(struct tm * timeptr)Param: (Pointer to a tm structure that contains a calendar time broken down into its components (see struct tm).)\t\nDesc: Convert tm structure to time_t (function)\t\nProto: time_t mktime (struct tm * timeptr);\t\n[c90 c99 arm cpp98 cpp11] [&lt;ctime&gt; (time.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(struct tm * timeptr)</Data></Cell>
    <Cell><Data ss:Type="String">time_t mktime (struct tm * timeptr);</Data></Cell>
    <Cell><Data ss:Type="String">mktime</Data></Cell>
    <Cell><Data ss:Type="String">Convert tm structure to time_t (function)</Data></Cell>
    <Cell><Data ss:Type="String">(timeptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a tm structure that contains a calendar time broken down into its components (see struct tm).</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ctime&gt; (time.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Time Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">get_time(struct tm* tmb, const charT* fmt)Param: (Pointer to an object of type struct tm where the time and date information extracted is stored.)\t\nDesc: Get date and time (function)\t\nProto: template &lt;class charT&gt;\t\n/*unspecified*/ get_time (struct tm* tmb, const charT* fmt);\t\n[cpp11] [&lt;iomanip&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(struct tm* tmb, const charT* fmt)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class charT&gt;\t\n/*unspecified*/ get_time (struct tm* tmb, const charT* fmt);</Data></Cell>
    <Cell><Data ss:Type="String">get_time</Data></Cell>
    <Cell><Data ss:Type="String">Get date and time (function)</Data></Cell>
    <Cell><Data ss:Type="String">(tmb)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an object of type struct tm where the time and date information extracted is stored.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;iomanip&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">IO Manipulators</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">kill_dependency(T y)Param: (A value.)\t\nDesc: Kill dependency (function)\t\nProto: template &lt;class T&gt;\t\nT kill_dependency (T y) noexcept;\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(T y)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt;\t\nT kill_dependency (T y) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">kill_dependency</Data></Cell>
    <Cell><Data ss:Type="String">Kill dependency (function)</Data></Cell>
    <Cell><Data ss:Type="String">(y)</Data></Cell>
    <Cell><Data ss:Type="String">A value.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">move_if_noexcept(T&amp; arg)Param: (An object.)\t\nDesc: Move if noexcept (function template)\t\nProto: !is_copy_constructible&lt;T&gt;::value,T&amp;&amp;, const T&amp; &gt;::type move_if_noexcept(T&amp; arg) noexcept;\t\n[cpp11] [&lt;utility&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(T&amp; arg)</Data></Cell>
    <Cell><Data ss:Type="String">!is_copy_constructible&lt;T&gt;::value,T&amp;&amp;, const T&amp; &gt;::type move_if_noexcept(T&amp; arg) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">move_if_noexcept</Data></Cell>
    <Cell><Data ss:Type="String">Move if noexcept (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(arg)</Data></Cell>
    <Cell><Data ss:Type="String">An object.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;utility&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Utility components</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">addressof(T&amp; ref)Param: (An object or function.)\t\nDesc: Address of object or function (function template)\t\nProto: template &lt;class T&gt; T* addressof (T&amp; ref) noexcept;\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(T&amp; ref)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; T* addressof (T&amp; ref) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">addressof</Data></Cell>
    <Cell><Data ss:Type="String">Address of object or function (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(ref)</Data></Cell>
    <Cell><Data ss:Type="String">An object or function.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">throw_with_nested(T&amp;&amp; e)Param: (An object or reference of a non-union class not derived from nested_exception.)\t\nDesc: Throw with nested (function)\t\nProto: [[noreturn]] template &lt;class T&gt;\t\nvoid throw_with_nested (T&amp;&amp; e);\t\n[cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(T&amp;&amp; e)</Data></Cell>
    <Cell><Data ss:Type="String">[[noreturn]] template &lt;class T&gt;\t\nvoid throw_with_nested (T&amp;&amp; e);</Data></Cell>
    <Cell><Data ss:Type="String">throw_with_nested</Data></Cell>
    <Cell><Data ss:Type="String">Throw with nested (function)</Data></Cell>
    <Cell><Data ss:Type="String">(e)</Data></Cell>
    <Cell><Data ss:Type="String">An object or reference of a non-union class not derived from nested_exception.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">return_temporary_buffer(T* p)Param: (Pointer to a block of temporary memory returned by a previous call to get_temporary_buffer.)\t\nDesc: Return block of temporary memory (function template)\t\nProto: template &lt;class T&gt; void return_temporary_buffer (T* p);\t\n[cpp98 cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(T* p)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; void return_temporary_buffer (T* p);</Data></Cell>
    <Cell><Data ss:Type="String">return_temporary_buffer</Data></Cell>
    <Cell><Data ss:Type="String">Return block of temporary memory (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(p)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a block of temporary memory returned by a previous call to get_temporary_buffer.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">undeclare_reachable(T* p)Param: (A pointer pointing to an object previously declared as reachable with declare_reachable.)\t\nDesc: Undeclare pointer as reachable (function template)\t\nProto: template &lt;class T&gt; T* undeclare_reachable (T* p);\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(T* p)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T&gt; T* undeclare_reachable (T* p);</Data></Cell>
    <Cell><Data ss:Type="String">undeclare_reachable</Data></Cell>
    <Cell><Data ss:Type="String">Undeclare pointer as reachable (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(p)</Data></Cell>
    <Cell><Data ss:Type="String">A pointer pointing to an object previously declared as reachable with declare_reachable.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">make_pair(T1 x, T2 y)Param: (Values for the members first and second, respectively, of the pair object being constructed.)\t\nDesc: Construct pair object (function template)\t\nProto: template &lt;class T1, class T2&gt; pair&lt;T1,T2&gt; make_pair (T1 x, T2 y);\t\n[cpp98 cpp11] [&lt;utility&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(T1 x, T2 y)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class T1, class T2&gt; pair&lt;T1,T2&gt; make_pair (T1 x, T2 y);</Data></Cell>
    <Cell><Data ss:Type="String">make_pair</Data></Cell>
    <Cell><Data ss:Type="String">Construct pair object (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(x, y)</Data></Cell>
    <Cell><Data ss:Type="String">Values for the members first and second, respectively, of the pair object being constructed.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;utility&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Utility components</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">set_terminate(terminate_handler f)Param: (Function that takes no parameters and returns no value ()\t\nDesc: Set terminate handler function (function)\t\nProto: terminate_handler set_terminate (terminate_handler f) throw();\t\n[cpp98 cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(terminate_handler f)</Data></Cell>
    <Cell><Data ss:Type="String">terminate_handler set_terminate (terminate_handler f) throw();</Data></Cell>
    <Cell><Data ss:Type="String">set_terminate</Data></Cell>
    <Cell><Data ss:Type="String">Set terminate handler function (function)</Data></Cell>
    <Cell><Data ss:Type="String">(f)</Data></Cell>
    <Cell><Data ss:Type="String">Function that takes no parameters and returns no value (</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">difftime(time_t end, time_t beginning)Param: (Higher bound of the time interval whose length is calculated.)\t\nDesc: Return difference between two times (function)\t\nProto: double difftime (time_t end, time_t beginning);\t\n[c90 c99 arm cpp98 cpp11] [&lt;ctime&gt; (time.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(time_t end, time_t beginning)</Data></Cell>
    <Cell><Data ss:Type="String">double difftime (time_t end, time_t beginning);</Data></Cell>
    <Cell><Data ss:Type="String">difftime</Data></Cell>
    <Cell><Data ss:Type="String">Return difference between two times (function)</Data></Cell>
    <Cell><Data ss:Type="String">(end)</Data></Cell>
    <Cell><Data ss:Type="String">Higher bound of the time interval whose length is calculated.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ctime&gt; (time.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Time Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">tuple_cat(Tuples&amp;&amp;... tpls)Param: (Comma-separated list of tuple objects.)\t\nDesc: Concatenate tuples (function template)\t\nProto: template &lt;class... Tuples&gt;\t\ntuple&lt;CTypes...&gt; tuple_cat (Tuples&amp;&amp;... tpls);\t\n[cpp11] [&lt;tuple&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(Tuples&amp;&amp;... tpls)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class... Tuples&gt;\t\ntuple&lt;CTypes...&gt; tuple_cat (Tuples&amp;&amp;... tpls);</Data></Cell>
    <Cell><Data ss:Type="String">tuple_cat</Data></Cell>
    <Cell><Data ss:Type="String">Concatenate tuples (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(tpls)</Data></Cell>
    <Cell><Data ss:Type="String">Comma-separated list of tuple objects.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;tuple&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Tuple library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">offsetof(type,member)Param: (A type in which member is a valid member designator.)\t\nDesc: Return member offset (macro)\t\nProto: offsetof (type,member)\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstddef&gt; (stddef.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(type,member)</Data></Cell>
    <Cell><Data ss:Type="String">offsetof (type,member)</Data></Cell>
    <Cell><Data ss:Type="String">offsetof</Data></Cell>
    <Cell><Data ss:Type="String">Return member offset (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(type)</Data></Cell>
    <Cell><Data ss:Type="String">A type in which member is a valid member designator.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstddef&gt; (stddef.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard definitions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">forward_as_tuple(Types&amp;&amp;... args)Param: (List of elements to be forwarded as a tuple object of references.)\t\nDesc: Forward as tuple (function template)\t\nProto: template&lt;class... Types&gt; tuple&lt;Types&amp;&amp;...&gt; forward_as_tuple (Types&amp;&amp;... args) noexcept;\t\n[cpp11] [&lt;tuple&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(Types&amp;&amp;... args)</Data></Cell>
    <Cell><Data ss:Type="String">template&lt;class... Types&gt; tuple&lt;Types&amp;&amp;...&gt; forward_as_tuple (Types&amp;&amp;... args) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">forward_as_tuple</Data></Cell>
    <Cell><Data ss:Type="String">Forward as tuple (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(args)</Data></Cell>
    <Cell><Data ss:Type="String">List of elements to be forwarded as a tuple object of references.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;tuple&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Tuple library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">make_tuple(Types&amp;&amp;... args)Param: (List of elements that the constructed tuple shall contain.)\t\nDesc: Construct tuple (function template)\t\nProto: template&lt;class... Types&gt;\t\ntuple&lt;VTypes...&gt; make_tuple (Types&amp;&amp;... args);\t\n[cpp11] [&lt;tuple&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(Types&amp;&amp;... args)</Data></Cell>
    <Cell><Data ss:Type="String">template&lt;class... Types&gt;\t\ntuple&lt;VTypes...&gt; make_tuple (Types&amp;&amp;... args);</Data></Cell>
    <Cell><Data ss:Type="String">make_tuple</Data></Cell>
    <Cell><Data ss:Type="String">Construct tuple (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(args)</Data></Cell>
    <Cell><Data ss:Type="String">List of elements that the constructed tuple shall contain.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;tuple&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Tuple library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">tie(Types&amp;... args)Param: (List of objects (lvalues) to be tied as elements of a tuple.)\t\nDesc: Tie arguments to tuple elements (function template)\t\nProto: template&lt;class... Types&gt; tuple&lt;Types&amp;...&gt; tie (Types&amp;... args) noexcept;\t\n[cpp11] [&lt;tuple&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(Types&amp;... args)</Data></Cell>
    <Cell><Data ss:Type="String">template&lt;class... Types&gt; tuple&lt;Types&amp;...&gt; tie (Types&amp;... args) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">tie</Data></Cell>
    <Cell><Data ss:Type="String">Tie arguments to tuple elements (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(args)</Data></Cell>
    <Cell><Data ss:Type="String">List of objects (lvalues) to be tied as elements of a tuple.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;tuple&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Tuple library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">set_unexpected(unexpected_handler f)Param: (Function that takes no parameters and returns no value ()\t\nDesc: Set unexpected handler function (function)\t\nProto: unexpected_handler set_unexpected (unexpected_handler f) throw();\t\n[cpp98 cpp11] [&lt;exception&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(unexpected_handler f)</Data></Cell>
    <Cell><Data ss:Type="String">unexpected_handler set_unexpected (unexpected_handler f) throw();</Data></Cell>
    <Cell><Data ss:Type="String">set_unexpected</Data></Cell>
    <Cell><Data ss:Type="String">Set unexpected handler function (function)</Data></Cell>
    <Cell><Data ss:Type="String">(f)</Data></Cell>
    <Cell><Data ss:Type="String">Function that takes no parameters and returns no value (</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;exception&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Standard exceptions</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">srand(unsigned int seed)Param: (An integer value to be used as seed by the pseudo-random number generator algorithm.)\t\nDesc: Initialize random number generator (function)\t\nProto: void srand (unsigned int seed);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(unsigned int seed)</Data></Cell>
    <Cell><Data ss:Type="String">void srand (unsigned int seed);</Data></Cell>
    <Cell><Data ss:Type="String">srand</Data></Cell>
    <Cell><Data ss:Type="String">Initialize random number generator (function)</Data></Cell>
    <Cell><Data ss:Type="String">(seed)</Data></Cell>
    <Cell><Data ss:Type="String">An integer value to be used as seed by the pseudo-random number generator algorithm.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">generate_canonical(URNG&amp; g)Param: (A floating-point type.)\t\nDesc: Generate canonical numbers (function template)\t\nProto: template &lt;class RealType, size_t bits, class URNG&gt;\t\nRealType generate_canonical (URNG&amp; g);\t\n[cpp11] [&lt;random&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(URNG&amp; g)</Data></Cell>
    <Cell><Data ss:Type="String">template &lt;class RealType, size_t bits, class URNG&gt;\t\nRealType generate_canonical (URNG&amp; g);</Data></Cell>
    <Cell><Data ss:Type="String">generate_canonical</Data></Cell>
    <Cell><Data ss:Type="String">Generate canonical numbers (function template)</Data></Cell>
    <Cell><Data ss:Type="String">(RealType)</Data></Cell>
    <Cell><Data ss:Type="String">A floating-point type.</Data></Cell>
    <Cell><Data ss:Type="String">function template</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;random&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Random</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">va_end(va_list ap)Param: (va_list object previously initialized by va_start or va_copy.)\t\nDesc: End using variable argument list (macro)\t\nProto: void va_end (va_list ap);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdarg&gt; (stdarg.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(va_list ap)</Data></Cell>
    <Cell><Data ss:Type="String">void va_end (va_list ap);</Data></Cell>
    <Cell><Data ss:Type="String">va_end</Data></Cell>
    <Cell><Data ss:Type="String">End using variable argument list (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(ap)</Data></Cell>
    <Cell><Data ss:Type="String">va_list object previously initialized by va_start or va_copy.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdarg&gt; (stdarg.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Variable arguments handling</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">va_start(va_list ap, paramN)Param: (Uninitialized object of type va_list.)\t\nDesc: Initialize a variable argument list (macro)\t\nProto: void va_start (va_list ap, paramN);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdarg&gt; (stdarg.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(va_list ap, paramN)</Data></Cell>
    <Cell><Data ss:Type="String">void va_start (va_list ap, paramN);</Data></Cell>
    <Cell><Data ss:Type="String">va_start</Data></Cell>
    <Cell><Data ss:Type="String">Initialize a variable argument list (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(ap)</Data></Cell>
    <Cell><Data ss:Type="String">Uninitialized object of type va_list.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdarg&gt; (stdarg.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Variable arguments handling</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">va_arg(va_list ap, type)Param: (Object of type va_list carrying information about the current retrieval state of a variable argument list.)\t\nDesc: Retrieve next argument (macro)\t\nProto: type va_arg (va_list ap, type)\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdarg&gt; (stdarg.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(va_list ap, type)</Data></Cell>
    <Cell><Data ss:Type="String">type va_arg (va_list ap, type)</Data></Cell>
    <Cell><Data ss:Type="String">va_arg</Data></Cell>
    <Cell><Data ss:Type="String">Retrieve next argument (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(ap)</Data></Cell>
    <Cell><Data ss:Type="String">Object of type va_list carrying information about the current retrieval state of a variable argument list.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdarg&gt; (stdarg.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Variable arguments handling</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">va_copy(va_list dest, va_list src)Param: (Uninitialized object of type va_list.)\t\nDesc: Copy variable argument list (macro)\t\nProto: void va_copy (va_list dest, va_list src);\t\n[c99 cpp11] [&lt;cstdarg&gt; (stdarg.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(va_list dest, va_list src)</Data></Cell>
    <Cell><Data ss:Type="String">void va_copy (va_list dest, va_list src);</Data></Cell>
    <Cell><Data ss:Type="String">va_copy</Data></Cell>
    <Cell><Data ss:Type="String">Copy variable argument list (macro)</Data></Cell>
    <Cell><Data ss:Type="String">(dest)</Data></Cell>
    <Cell><Data ss:Type="String">Uninitialized object of type va_list.</Data></Cell>
    <Cell><Data ss:Type="String">macro</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdarg&gt; (stdarg.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Variable arguments handling</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atexit(void (*func)(void))Param: (Function to be called.)\t\nDesc: Set function to be executed on exit (function)\t\nProto: int atexit (void (*func)(void));\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(void (*func)(void))</Data></Cell>
    <Cell><Data ss:Type="String">int atexit (void (*func)(void));</Data></Cell>
    <Cell><Data ss:Type="String">atexit</Data></Cell>
    <Cell><Data ss:Type="String">Set function to be executed on exit (function)</Data></Cell>
    <Cell><Data ss:Type="String">(function)</Data></Cell>
    <Cell><Data ss:Type="String">Function to be called.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">at_quick_exit(void (*func)(void))Param: (Function to be called.)\t\nDesc: Set function to be executed on quick exit (function)\t\nProto: int at_quick_exit (void (*func)(void));\t\n[c11 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(void (*func)(void))</Data></Cell>
    <Cell><Data ss:Type="String">int at_quick_exit (void (*func)(void));</Data></Cell>
    <Cell><Data ss:Type="String">at_quick_exit</Data></Cell>
    <Cell><Data ss:Type="String">Set function to be executed on quick exit (function)</Data></Cell>
    <Cell><Data ss:Type="String">(function)</Data></Cell>
    <Cell><Data ss:Type="String">Function to be called.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c11 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fegetround(void)Param: ()\t\nDesc: Get rounding direction mode (function)\t\nProto: int fegetround (void);\t\n[c99 cpp11] [&lt;cfenv&gt; (fenv.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(void)</Data></Cell>
    <Cell><Data ss:Type="String">int fegetround (void);</Data></Cell>
    <Cell><Data ss:Type="String">fegetround</Data></Cell>
    <Cell><Data ss:Type="String">Get rounding direction mode (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cfenv&gt; (fenv.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Floating-point environment</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">localeconv(void)Param: ()\t\nDesc: Get locale formatting parameters for quantities (function)\t\nProto: struct lconv* localeconv (void);\t\n[c90 c99 arm cpp98 cpp11] [&lt;clocale&gt; (locale.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(void)</Data></Cell>
    <Cell><Data ss:Type="String">struct lconv* localeconv (void);</Data></Cell>
    <Cell><Data ss:Type="String">localeconv</Data></Cell>
    <Cell><Data ss:Type="String">Get locale formatting parameters for quantities (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;clocale&gt; (locale.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C localization library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">abort(void)Param: ()\t\nDesc: Abort current process (function)\t\nProto: void abort (void);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(void)</Data></Cell>
    <Cell><Data ss:Type="String">void abort (void);</Data></Cell>
    <Cell><Data ss:Type="String">abort</Data></Cell>
    <Cell><Data ss:Type="String">Abort current process (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">rand(void)Param: ()\t\nDesc: Generate random number (function)\t\nProto: int rand (void);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(void)</Data></Cell>
    <Cell><Data ss:Type="String">int rand (void);</Data></Cell>
    <Cell><Data ss:Type="String">rand</Data></Cell>
    <Cell><Data ss:Type="String">Generate random number (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">clock(void)Param: ()\t\nDesc: Clock program (function)\t\nProto: clock_t clock (void);\t\n[c90 c99 arm cpp98 cpp11] [&lt;ctime&gt; (time.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(void)</Data></Cell>
    <Cell><Data ss:Type="String">clock_t clock (void);</Data></Cell>
    <Cell><Data ss:Type="String">clock</Data></Cell>
    <Cell><Data ss:Type="String">Clock program (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;ctime&gt; (time.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Time Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">getwchar(void)Param: ()\t\nDesc: Get wide character from stdin (function)\t\nProto: wint_t getwchar (void);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(void)</Data></Cell>
    <Cell><Data ss:Type="String">wint_t getwchar (void);</Data></Cell>
    <Cell><Data ss:Type="String">getwchar</Data></Cell>
    <Cell><Data ss:Type="String">Get wide character from stdin (function)</Data></Cell>
    <Cell><Data ss:Type="String">()</Data></Cell>
    <Cell ss:Index="8"><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">qsort(void* base, size_t num, size_t size, int (*compar)(const void*,const void*))Param: (Pointer to the first object of the array to be sorted, converted to a )\t\nDesc: Sort elements of array (function)\t\nProto: void qsort (void* base, size_t num, size_t size, int (*compar)(const void*,const void*));\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(void* base, size_t num, size_t size, int (*compar)(const void*,const void*))</Data></Cell>
    <Cell><Data ss:Type="String">void qsort (void* base, size_t num, size_t size, int (*compar)(const void*,const void*));</Data></Cell>
    <Cell><Data ss:Type="String">qsort</Data></Cell>
    <Cell><Data ss:Type="String">Sort elements of array (function)</Data></Cell>
    <Cell><Data ss:Type="String">(base)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the first object of the array to be sorted, converted to a </Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">declare_reachable(void* p)Param: (A safely-derived pointer, or a null pointer.)\t\nDesc: Declare pointer as reachable (function)\t\nProto: void declare_reachable (void* p);\t\n[cpp11] [&lt;memory&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(void* p)</Data></Cell>
    <Cell><Data ss:Type="String">void declare_reachable (void* p);</Data></Cell>
    <Cell><Data ss:Type="String">declare_reachable</Data></Cell>
    <Cell><Data ss:Type="String">Declare pointer as reachable (function)</Data></Cell>
    <Cell><Data ss:Type="String">(p)</Data></Cell>
    <Cell><Data ss:Type="String">A safely-derived pointer, or a null pointer.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;memory&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Memory elements</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">operator delete(void* ptr)Param: (A pointer to the memory block to be released, type-casted to a )\t\nDesc: Deallocate storage space (function)\t\nProto: void operator delete (void* ptr) throw();\t\n[cpp98 cpp11] [&lt;new&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(void* ptr)</Data></Cell>
    <Cell><Data ss:Type="String">void operator delete (void* ptr) throw();</Data></Cell>
    <Cell><Data ss:Type="String">operator delete</Data></Cell>
    <Cell><Data ss:Type="String">Deallocate storage space (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr)</Data></Cell>
    <Cell><Data ss:Type="String">A pointer to the memory block to be released, type-casted to a </Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;new&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Dynamic memory</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">operator delete[](void* ptr)Param: (A pointer to the memory block to be released, type-casted to a )\t\nDesc: Deallocate storage space of array (function)\t\nProto: void operator delete[] (void* ptr) throw();\t\n[cpp98 cpp11] [&lt;new&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(void* ptr)</Data></Cell>
    <Cell><Data ss:Type="String">void operator delete[] (void* ptr) throw();</Data></Cell>
    <Cell><Data ss:Type="String">operator delete[]</Data></Cell>
    <Cell><Data ss:Type="String">Deallocate storage space of array (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr)</Data></Cell>
    <Cell><Data ss:Type="String">A pointer to the memory block to be released, type-casted to a </Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;new&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Dynamic memory</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">free(void* ptr)Param: (Pointer to a memory block previously allocated with malloc, calloc or realloc.)\t\nDesc: Deallocate memory block (function)\t\nProto: void free (void* ptr);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(void* ptr)</Data></Cell>
    <Cell><Data ss:Type="String">void free (void* ptr);</Data></Cell>
    <Cell><Data ss:Type="String">free</Data></Cell>
    <Cell><Data ss:Type="String">Deallocate memory block (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a memory block previously allocated with malloc, calloc or realloc.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">realloc(void* ptr, size_t size)Param: (Pointer to a memory block previously allocated with malloc, calloc or realloc.)\t\nDesc: Reallocate memory block (function)\t\nProto: void* realloc (void* ptr, size_t size);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(void* ptr, size_t size)</Data></Cell>
    <Cell><Data ss:Type="String">void* realloc (void* ptr, size_t size);</Data></Cell>
    <Cell><Data ss:Type="String">realloc</Data></Cell>
    <Cell><Data ss:Type="String">Reallocate memory block (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a memory block previously allocated with malloc, calloc or realloc.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_flag_test_and_set(volatile atomic_flag* obj)Param: (Pointer to the atomic_flag object to set.)\t\nDesc: Test and set atomic flag (function)\t\nProto: bool atomic_flag_test_and_set (volatile atomic_flag* obj) noexcept;bool atomic_flag_test_and_set (atomic_flag* obj) noexcept;\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(volatile atomic_flag* obj)</Data></Cell>
    <Cell><Data ss:Type="String">bool atomic_flag_test_and_set (volatile atomic_flag* obj) noexcept;bool atomic_flag_test_and_set (atomic_flag* obj) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">atomic_flag_test_and_set</Data></Cell>
    <Cell><Data ss:Type="String">Test and set atomic flag (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the atomic_flag object to set.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_flag_clear(volatile atomic_flag* obj)Param: (Pointer to the atomic_flag object to clear.)\t\nDesc: Clear atomic flag (function)\t\nProto: void atomic_flag_clear (volatile atomic_flag* obj) noexcept;void atomic_flag_clear (atomic_flag* obj) noexcept;\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(volatile atomic_flag* obj)</Data></Cell>
    <Cell><Data ss:Type="String">void atomic_flag_clear (volatile atomic_flag* obj) noexcept;void atomic_flag_clear (atomic_flag* obj) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">atomic_flag_clear</Data></Cell>
    <Cell><Data ss:Type="String">Clear atomic flag (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the atomic_flag object to clear.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_flag_test_and_set_explicit(volatile atomic_flag* obj)Param: (Pointer to the atomic_flag object to set.)\t\nDesc: Test and set atomic flag (explicit memory order) (function)\t\nProto: bool atomic_flag_test_and_set (volatile atomic_flag* obj, memory_order sync) noexcept;bool atomic_flag_test_and_set (atomic_flag* obj, memory_order sync) noexcept;\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(volatile atomic_flag* obj)</Data></Cell>
    <Cell><Data ss:Type="String">bool atomic_flag_test_and_set (volatile atomic_flag* obj, memory_order sync) noexcept;bool atomic_flag_test_and_set (atomic_flag* obj, memory_order sync) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">atomic_flag_test_and_set_explicit</Data></Cell>
    <Cell><Data ss:Type="String">Test and set atomic flag (explicit memory order) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the atomic_flag object to set.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">atomic_flag_clear_explicit(volatile atomic_flag* obj)Param: (Pointer to the atomic_flag object to clear.)\t\nDesc: Clear atomic flag (explicit memory order) (function)\t\nProto: void atomic_flag_clear (volatile atomic_flag* obj, memory_order sync) noexcept;void atomic_flag_clear (atomic_flag* obj, memory_order sync) noexcept;\t\n[cpp11] [&lt;atomic&gt;]</Data></Cell>
    <Cell><Data ss:Type="String">(volatile atomic_flag* obj)</Data></Cell>
    <Cell><Data ss:Type="String">void atomic_flag_clear (volatile atomic_flag* obj, memory_order sync) noexcept;void atomic_flag_clear (atomic_flag* obj, memory_order sync) noexcept;</Data></Cell>
    <Cell><Data ss:Type="String">atomic_flag_clear_explicit</Data></Cell>
    <Cell><Data ss:Type="String">Clear atomic flag (explicit memory order) (function)</Data></Cell>
    <Cell><Data ss:Type="String">(obj)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the atomic_flag object to clear.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;atomic&gt;</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Atomic</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">vswprintf(wchar_t * ws, size_t len, const wchar_t * format, va_list arg )Param: (Pointer to a buffer where the resulting C wide string is stored.)\t\nDesc: Write formatted data from variable argument list to sized buffer (function)\t\nProto: int vswprintf (wchar_t * ws, size_t len, const wchar_t * format, va_list arg );\t\n[c99 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t * ws, size_t len, const wchar_t * format, va_list arg )</Data></Cell>
    <Cell><Data ss:Type="String">int vswprintf (wchar_t * ws, size_t len, const wchar_t * format, va_list arg );</Data></Cell>
    <Cell><Data ss:Type="String">vswprintf</Data></Cell>
    <Cell><Data ss:Type="String">Write formatted data from variable argument list to sized buffer (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ws)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a buffer where the resulting C wide string is stored.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">putwchar(wchar_t wc)Param: (The wide character to be written.)\t\nDesc: Write wide character to stdout (function)\t\nProto: wint_t putwchar (wchar_t wc);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t wc)</Data></Cell>
    <Cell><Data ss:Type="String">wint_t putwchar (wchar_t wc);</Data></Cell>
    <Cell><Data ss:Type="String">putwchar</Data></Cell>
    <Cell><Data ss:Type="String">Write wide character to stdout (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wc)</Data></Cell>
    <Cell><Data ss:Type="String">The wide character to be written.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fputwc(wchar_t wc, FILE * stream)Param: (The wide character to write.)\t\nDesc: Write wide character to stream (function)\t\nProto: wint_t fputwc (wchar_t wc, FILE * stream);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t wc, FILE * stream)</Data></Cell>
    <Cell><Data ss:Type="String">wint_t fputwc (wchar_t wc, FILE * stream);</Data></Cell>
    <Cell><Data ss:Type="String">fputwc</Data></Cell>
    <Cell><Data ss:Type="String">Write wide character to stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wc)</Data></Cell>
    <Cell><Data ss:Type="String">The wide character to write.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mbstowcs(wchar_t* dest, const char* src, size_t max)Param: (Pointer to an array of wchar_t elements long enough to contain the resulting sequence (at most, max wide characters).)\t\nDesc: Convert multibyte string to wide-character string (function)\t\nProto: size_t mbstowcs (wchar_t* dest, const char* src, size_t max);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* dest, const char* src, size_t max)</Data></Cell>
    <Cell><Data ss:Type="String">size_t mbstowcs (wchar_t* dest, const char* src, size_t max);</Data></Cell>
    <Cell><Data ss:Type="String">mbstowcs</Data></Cell>
    <Cell><Data ss:Type="String">Convert multibyte string to wide-character string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(dest)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an array of wchar_t elements long enough to contain the resulting sequence (at most, max wide characters).</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mbsrtowcs(wchar_t* dest, const char** src, size_t max, mbstate_t* ps)Param: (Pointer to an array of wchar_t elements long enough to store a string of max wide characters.)\t\nDesc: Convert multibyte string to wide-character string (function)\t\nProto: size_t mbsrtowcs (wchar_t* dest, const char** src, size_t max, mbstate_t* ps);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* dest, const char** src, size_t max, mbstate_t* ps)</Data></Cell>
    <Cell><Data ss:Type="String">size_t mbsrtowcs (wchar_t* dest, const char** src, size_t max, mbstate_t* ps);</Data></Cell>
    <Cell><Data ss:Type="String">mbsrtowcs</Data></Cell>
    <Cell><Data ss:Type="String">Convert multibyte string to wide-character string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(dest)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an array of wchar_t elements long enough to store a string of max wide characters.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcscat(wchar_t* destination, const wchar_t* source)Param: (Pointer to the destination array, which should contain a C wide string, and be large enough to contain the concatenated resulting string.)\t\nDesc: Concatenate wide strings (function)\t\nProto: wchar_t* wcscat (wchar_t* destination, const wchar_t* source);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* destination, const wchar_t* source)</Data></Cell>
    <Cell><Data ss:Type="String">wchar_t* wcscat (wchar_t* destination, const wchar_t* source);</Data></Cell>
    <Cell><Data ss:Type="String">wcscat</Data></Cell>
    <Cell><Data ss:Type="String">Concatenate wide strings (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array, which should contain a C wide string, and be large enough to contain the concatenated resulting string.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcscpy(wchar_t* destination, const wchar_t* source)Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Copy wide string (function)\t\nProto: wchar_t* wcscpy (wchar_t* destination, const wchar_t* source);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* destination, const wchar_t* source)</Data></Cell>
    <Cell><Data ss:Type="String">wchar_t* wcscpy (wchar_t* destination, const wchar_t* source);</Data></Cell>
    <Cell><Data ss:Type="String">wcscpy</Data></Cell>
    <Cell><Data ss:Type="String">Copy wide string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array where the content is to be copied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcsncat(wchar_t* destination, const wchar_t* source, size_t num)Param: (Pointer to the destination array, which should contain a C wide string, and be large enough to contain the concatenated resulting string, including the additional null wide character.)\t\nDesc: Append characters from wide string (function)\t\nProto: wchar_t* wcsncat (wchar_t* destination, const wchar_t* source, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* destination, const wchar_t* source, size_t num)</Data></Cell>
    <Cell><Data ss:Type="String">wchar_t* wcsncat (wchar_t* destination, const wchar_t* source, size_t num);</Data></Cell>
    <Cell><Data ss:Type="String">wcsncat</Data></Cell>
    <Cell><Data ss:Type="String">Append characters from wide string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array, which should contain a C wide string, and be large enough to contain the concatenated resulting string, including the additional null wide character.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcsncpy(wchar_t* destination, const wchar_t* source, size_t num)Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Copy characters from wide string (function)\t\nProto: wchar_t* wcsncpy (wchar_t* destination, const wchar_t* source, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* destination, const wchar_t* source, size_t num)</Data></Cell>
    <Cell><Data ss:Type="String">wchar_t* wcsncpy (wchar_t* destination, const wchar_t* source, size_t num);</Data></Cell>
    <Cell><Data ss:Type="String">wcsncpy</Data></Cell>
    <Cell><Data ss:Type="String">Copy characters from wide string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array where the content is to be copied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcsxfrm(wchar_t* destination, const wchar_t* source, size_t num)Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Transform wide string using locale (function)\t\nProto: size_t wcsxfrm (wchar_t* destination, const wchar_t* source, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* destination, const wchar_t* source, size_t num)</Data></Cell>
    <Cell><Data ss:Type="String">size_t wcsxfrm (wchar_t* destination, const wchar_t* source, size_t num);</Data></Cell>
    <Cell><Data ss:Type="String">wcsxfrm</Data></Cell>
    <Cell><Data ss:Type="String">Transform wide string using locale (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array where the content is to be copied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wmemcpy(wchar_t* destination, const wchar_t* source, size_t num)Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Copy block of wide characters (function)\t\nProto: wchar_t* wmemcpy (wchar_t* destination, const wchar_t* source, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* destination, const wchar_t* source, size_t num)</Data></Cell>
    <Cell><Data ss:Type="String">wchar_t* wmemcpy (wchar_t* destination, const wchar_t* source, size_t num);</Data></Cell>
    <Cell><Data ss:Type="String">wmemcpy</Data></Cell>
    <Cell><Data ss:Type="String">Copy block of wide characters (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array where the content is to be copied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wmemmove(wchar_t* destination, const wchar_t* source, size_t num)Param: (Pointer to the destination array where the content is to be copied.)\t\nDesc: Move block of wide characters (function)\t\nProto: wchar_t* wmemmove (wchar_t* destination, const wchar_t* source, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* destination, const wchar_t* source, size_t num)</Data></Cell>
    <Cell><Data ss:Type="String">wchar_t* wmemmove (wchar_t* destination, const wchar_t* source, size_t num);</Data></Cell>
    <Cell><Data ss:Type="String">wmemmove</Data></Cell>
    <Cell><Data ss:Type="String">Move block of wide characters (function)</Data></Cell>
    <Cell><Data ss:Type="String">(destination)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array where the content is to be copied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcsftime(wchar_t* ptr, size_t maxsize, const wchar_t* format,const struct tm* timeptr)Param: (Pointer to the destination array where the resulting C wide string is copied.)\t\nDesc: Format time as wide string (function)\t\nProto: size_t wcsftime (wchar_t* ptr, size_t maxsize, const wchar_t* format,const struct tm* timeptr);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* ptr, size_t maxsize, const wchar_t* format,const struct tm* timeptr)</Data></Cell>
    <Cell><Data ss:Type="String">size_t wcsftime (wchar_t* ptr, size_t maxsize, const wchar_t* format,const struct tm* timeptr);</Data></Cell>
    <Cell><Data ss:Type="String">wcsftime</Data></Cell>
    <Cell><Data ss:Type="String">Format time as wide string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the destination array where the resulting C wide string is copied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wmemset(wchar_t* ptr, wchar_t wc, size_t num)Param: (Pointer to the array to fill.)\t\nDesc: Fill array of wide characters (function)\t\nProto: wchar_t* wmemset (wchar_t* ptr, wchar_t wc, size_t num);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* ptr, wchar_t wc, size_t num)</Data></Cell>
    <Cell><Data ss:Type="String">wchar_t* wmemset (wchar_t* ptr, wchar_t wc, size_t num);</Data></Cell>
    <Cell><Data ss:Type="String">wmemset</Data></Cell>
    <Cell><Data ss:Type="String">Fill array of wide characters (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ptr)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to the array to fill.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mbtowc(wchar_t* pwc, const char* pmb, size_t max)Param: (Pointer to an object of type wchar_t.)\t\nDesc: Convert multibyte sequence to wide character (function)\t\nProto: int mbtowc (wchar_t* pwc, const char* pmb, size_t max);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cstdlib&gt; (stdlib.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* pwc, const char* pmb, size_t max)</Data></Cell>
    <Cell><Data ss:Type="String">int mbtowc (wchar_t* pwc, const char* pmb, size_t max);</Data></Cell>
    <Cell><Data ss:Type="String">mbtowc</Data></Cell>
    <Cell><Data ss:Type="String">Convert multibyte sequence to wide character (function)</Data></Cell>
    <Cell><Data ss:Type="String">(pwc)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an object of type wchar_t.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cstdlib&gt; (stdlib.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">C Standard General Utilities Library</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">mbrtowc(wchar_t* pwc, const char* pmb, size_t max, mbstate_t* ps)Param: (Pointer to an object of type wchar_t.)\t\nDesc: Convert multibyte sequence to wide character (function)\t\nProto: size_t mbrtowc (wchar_t* pwc, const char* pmb, size_t max, mbstate_t* ps);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* pwc, const char* pmb, size_t max, mbstate_t* ps)</Data></Cell>
    <Cell><Data ss:Type="String">size_t mbrtowc (wchar_t* pwc, const char* pmb, size_t max, mbstate_t* ps);</Data></Cell>
    <Cell><Data ss:Type="String">mbrtowc</Data></Cell>
    <Cell><Data ss:Type="String">Convert multibyte sequence to wide character (function)</Data></Cell>
    <Cell><Data ss:Type="String">(pwc)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an object of type wchar_t.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wcstok(wchar_t* wcs, const wchar_t* delimiters)Param: (C wide string to truncate.)\t\nDesc: Split wide string into tokens (function)\t\nProto: wchar_t* wcstok (wchar_t* wcs, const wchar_t* delimiters);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* wcs, const wchar_t* delimiters)</Data></Cell>
    <Cell><Data ss:Type="String">wchar_t* wcstok (wchar_t* wcs, const wchar_t* delimiters);</Data></Cell>
    <Cell><Data ss:Type="String">wcstok</Data></Cell>
    <Cell><Data ss:Type="String">Split wide string into tokens (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wcs)</Data></Cell>
    <Cell><Data ss:Type="String">C wide string to truncate.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">fgetws(wchar_t* ws, int num, FILE* stream)Param: (Pointer to an array of wchar_t where the wide string read is copied.)\t\nDesc: Get wide string from stream (function)\t\nProto: wchar_t* fgetws (wchar_t* ws, int num, FILE* stream);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* ws, int num, FILE* stream)</Data></Cell>
    <Cell><Data ss:Type="String">wchar_t* fgetws (wchar_t* ws, int num, FILE* stream);</Data></Cell>
    <Cell><Data ss:Type="String">fgetws</Data></Cell>
    <Cell><Data ss:Type="String">Get wide string from stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ws)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to an array of wchar_t where the wide string read is copied.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">swprintf(wchar_t* ws, size_t len, const wchar_t* format, ...)Param: (Pointer to a buffer where the resulting C wide string is stored.)\t\nDesc: Write formatted data to wide string (function)\t\nProto: int swprintf (wchar_t* ws, size_t len, const wchar_t* format, ...);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wchar_t* ws, size_t len, const wchar_t* format, ...)</Data></Cell>
    <Cell><Data ss:Type="String">int swprintf (wchar_t* ws, size_t len, const wchar_t* format, ...);</Data></Cell>
    <Cell><Data ss:Type="String">swprintf</Data></Cell>
    <Cell><Data ss:Type="String">Write formatted data to wide string (function)</Data></Cell>
    <Cell><Data ss:Type="String">(ws)</Data></Cell>
    <Cell><Data ss:Type="String">Pointer to a buffer where the resulting C wide string is stored.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswalnum(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is alphanumeric (function)\t\nProto: int iswalnum (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">int iswalnum (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">iswalnum</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character is alphanumeric (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswalpha(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is alphabetic (function)\t\nProto: int iswalpha (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">int iswalpha (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">iswalpha</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character is alphabetic (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswblank(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is blank (function)\t\nProto: int iswblank (wint_t c);\t\n[c99 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">int iswblank (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">iswblank</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character is blank (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c99 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswcntrl(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is a control character (function)\t\nProto: int iswcntrl (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">int iswcntrl (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">iswcntrl</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character is a control character (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswdigit(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is decimal digit (function)\t\nProto: int iswdigit (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">int iswdigit (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">iswdigit</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character is decimal digit (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswgraph(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character has graphical representation (function)\t\nProto: int iswgraph (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">int iswgraph (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">iswgraph</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character has graphical representation (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswlower(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is lowercase letter (function)\t\nProto: int iswlower (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">int iswlower (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">iswlower</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character is lowercase letter (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswprint(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is printable (function)\t\nProto: int iswprint (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">int iswprint (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">iswprint</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character is printable (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswpunct(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is punctuation character (function)\t\nProto: int iswpunct (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">int iswpunct (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">iswpunct</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character is punctuation character (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswspace(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is a white-space (function)\t\nProto: int iswspace (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">int iswspace (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">iswspace</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character is a white-space (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswupper(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is uppercase letter (function)\t\nProto: int iswupper (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">int iswupper (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">iswupper</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character is uppercase letter (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswxdigit(wint_t c)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character is hexadecimal digit (function)\t\nProto: int iswxdigit (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">int iswxdigit (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">iswxdigit</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character is hexadecimal digit (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">towupper(wint_t c)Param: (Wide character to be converted, casted to a wint_t value, or WEOF.)\t\nDesc: Convert lowercase wide character to uppercase (function)\t\nProto: wint_t towupper (wint_t c);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c)</Data></Cell>
    <Cell><Data ss:Type="String">wint_t towupper (wint_t c);</Data></Cell>
    <Cell><Data ss:Type="String">towupper</Data></Cell>
    <Cell><Data ss:Type="String">Convert lowercase wide character to uppercase (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be converted, casted to a wint_t value, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">towctrans(wint_t c, wctrans_t desc)Param: (Wide character to be transformed, casted to a wint_t value, or WEOF.)\t\nDesc: Convert using transformation (function)\t\nProto: wint_t towctrans(wint_t c, wctrans_t desc);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c, wctrans_t desc)</Data></Cell>
    <Cell><Data ss:Type="String">wint_t towctrans(wint_t c, wctrans_t desc);</Data></Cell>
    <Cell><Data ss:Type="String">towctrans</Data></Cell>
    <Cell><Data ss:Type="String">Convert using transformation (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be transformed, casted to a wint_t value, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">iswctype(wint_t c, wctype_t desc)Param: (Wide character to be checked, casted to a wint_t, or WEOF.)\t\nDesc: Check if wide character has property (function)\t\nProto: int iswctype(wint_t c, wctype_t desc);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwctype&gt; (wctype.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t c, wctype_t desc)</Data></Cell>
    <Cell><Data ss:Type="String">int iswctype(wint_t c, wctype_t desc);</Data></Cell>
    <Cell><Data ss:Type="String">iswctype</Data></Cell>
    <Cell><Data ss:Type="String">Check if wide character has property (function)</Data></Cell>
    <Cell><Data ss:Type="String">(c)</Data></Cell>
    <Cell><Data ss:Type="String">Wide character to be checked, casted to a wint_t, or WEOF.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwctype&gt; (wctype.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide character type</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">wctob(wint_t wc)Param: (The wint_t promotion of a wide character.)\t\nDesc: Convert wide character to single byte (function)\t\nProto: int wctob (wint_t wc);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t wc)</Data></Cell>
    <Cell><Data ss:Type="String">int wctob (wint_t wc);</Data></Cell>
    <Cell><Data ss:Type="String">wctob</Data></Cell>
    <Cell><Data ss:Type="String">Convert wide character to single byte (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wc)</Data></Cell>
    <Cell><Data ss:Type="String">The wint_t promotion of a wide character.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
   <Row ss:AutoFitHeight="0">
    <Cell
     ss:Formula="=RC[3]&amp;RC[1]&amp;&quot;Param: &quot;&amp;&quot;(&quot; &amp;RC[6] &amp;&quot;)&quot; &amp; &quot;\t\nDesc: &quot; &amp;RC[4] &amp;&quot;\t\nProto: &quot;&amp;RC[2]&amp;&quot;\t\n[&quot;&amp;RC[8]&amp;&quot;] [&quot;&amp;RC[9]&amp;&quot;]&quot;"><Data
      ss:Type="String">ungetwc(wint_t wc, FILE* stream)Param: (The wint_t promotion of the wide character to be put back.)\t\nDesc: Unget wide character from stream (function)\t\nProto: wint_t ungetwc (wint_t wc, FILE* stream);\t\n[c90 c99 arm cpp98 cpp11] [&lt;cwchar&gt; (wchar.h)]</Data></Cell>
    <Cell><Data ss:Type="String">(wint_t wc, FILE* stream)</Data></Cell>
    <Cell><Data ss:Type="String">wint_t ungetwc (wint_t wc, FILE* stream);</Data></Cell>
    <Cell><Data ss:Type="String">ungetwc</Data></Cell>
    <Cell><Data ss:Type="String">Unget wide character from stream (function)</Data></Cell>
    <Cell><Data ss:Type="String">(wc)</Data></Cell>
    <Cell><Data ss:Type="String">The wint_t promotion of the wide character to be put back.</Data></Cell>
    <Cell><Data ss:Type="String">function</Data></Cell>
    <Cell><Data ss:Type="String">c90 c99 arm cpp98 cpp11</Data></Cell>
    <Cell><Data ss:Type="String">&lt;cwchar&gt; (wchar.h)</Data></Cell>
    <Cell><Data ss:Type="String">header</Data></Cell>
    <Cell><Data ss:Type="String">Wide characters</Data></Cell>
   </Row>
  </Table>
  <WorksheetOptions xmlns="urn:schemas-microsoft-com:office:excel">
   <PageSetup>
    <Header x:Margin="0.30000000000000004"/>
    <Footer x:Margin="0.30000000000000004"/>
    <PageMargins x:Bottom="0.78740157500000008" x:Left="0.70000000000000007"
     x:Right="0.70000000000000007" x:Top="0.78740157500000008"/>
   </PageSetup>
   <Unsynced/>
   <Print>
    <ValidPrinterInfo/>
    <PaperSizeIndex>9</PaperSizeIndex>
    <HorizontalResolution>600</HorizontalResolution>
    <VerticalResolution>0</VerticalResolution>
   </Print>
   <Zoom>90</Zoom>
   <Selected/>
   <TopRowVisible>540</TopRowVisible>
   <Panes>
    <Pane>
     <Number>3</Number>
     <ActiveRow>540</ActiveRow>
     <RangeSelection>C1</RangeSelection>
    </Pane>
   </Panes>
   <ProtectObjects>False</ProtectObjects>
   <ProtectScenarios>False</ProtectScenarios>
  </WorksheetOptions>
 </Worksheet>
</Workbook>
